<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Unholy Rails: Adding JavaScript to Rails &#183; RailsApps</title>
    <link href="https://plus.google.com/u/0/b/117374718581973393536/117374718581973393536/posts/" rel="publisher" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/bootstrap.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/site.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/syntax.css" type="text/css" charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.6.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/gollum.js" type="text/javascript"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-5109366-14']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a href="http://railsapps.github.com/" class="brand">RailsApps Project</a>
        <ul class="pull-right nav">
          <li><a href="http://blog.railsapps.org/" class="twitter">Blog</a></li>
          <li><a href="http://twitter.com/rails_apps" class="twitter">Twitter</a></li>
          <li><a href="https://plus.google.com/117374718581973393536" class="google">Google +</a></li>
          <li><a href="https://github.com/RailsApps" class="github">GitHub Repository</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container"> 

    <div class="content wikistyle gollum textile">
      <h1>Unholy Rails: Adding JavaScript to Rails</h1>
<h4>by Daniel Kehoe</h4>
<p><em>Last updated 15 October 2012</em></p>
<p>Rails and JavaScript topics: How to include external JavaScript files and jQuery plugins in Rails 3.1 or newer. Using page-specific JavaScript in Rails. Organizing JavaScript files.</p>
<p>What is the best way to add a JavaScript library to a Rails application? Use the Rails asset pipeline? Or include directly in a view template? This article explains what to do when your application is not wholly Rails.</p>
<p>This is a guide for developers using the example apps from the RailsApps repository. The <a href="http://railsapps.github.com/">RailsApps project</a> provides open source applications and detailed tutorials for Rails. Next time you build an app, try using our <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool; it’s a better way to build a starter app.</p>
<p>Got feedback or a suggestion? <a href="#comment">Comments welcome</a> below.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#summary">Rules of Thumb</a></li>
	<li><a href="#principles">Principles for Performance</a></li>
	<li><a href="#missing">JavaScript’s Missing Directive</a></li>
	<li><a href="#pipeline">Rails and the Asset Pipeline</a></li>
	<li><a href="#locations">Where to Stick Your JavaScript</a></li>
	<li><a href="#external">External Scripts</a></li>
	<li><a href="#specific">Page-Specific JavaScript</a></li>
	<li><a href="#comment">Comments</a></li>
</ul><h2 id="summary">Rules of Thumb</h2>
<p>In summary, here are rules of thumb to guide your use of JavaScript in Rails:</p>
<ul>
<li>Logically organize your site-wide scripts in the <strong>app/assets/javascripts/</strong> folder.</li>
	<li>Copy external JavaScript libraries (such as jQuery plugins) to the <strong>vendor/assets/javascripts</strong> folder.</li>
	<li>Let the Rails asset pipeline combine them all in one minimized <strong>application.js</strong> file.</li>
	<li>List scripts in the <strong>app/assets/javascripts/application.js</strong> manifest.</li>
</ul><p>In almost all applications, there is no need to add external JavaScript libraries directly in a view template. Use the Rails asset pipeline, even for JavaScript used on just one page (page-specific JavaScript). Copy external scripts to your application and you’ll gain the performance benefits of the Rails asset pipeline and avoid complexity.</p>
<p>The Rails asset pipeline will become even more important in Rails 4.0 with the new <a href="https://github.com/rails/turbolinks">Turbolinks</a> feature. Turbolinks improves performance by keeping the current page instance alive and replacing only the page <span class="caps">BODY</span> (plus the title in the <span class="caps">HEAD</span>). As long as the <span class="caps">HEAD</span> element is identical between pages, the Turbolinks mechanism can deliver its “turbo” speed boost. This adds to the importance of avoiding any extra script tags on specific pages.</p>
<h2 id="principles">Principles for Performance</h2>
<p>It’s difficult to sort out all the advice and folklore around Rails and JavaScript. Here are basic principles to improve website performance.</p>
<p>JavaScript is single-threaded, meaning that only one operation can be performed at a time. The browser can only be executing JavaScript or rendering the UI at any moment.</p>
<p>Downloading files takes much longer than parsing and executing browser code. Modern web browsers can download files (scripts, <span class="caps">CSS</span> files, or images) in parallel. Modern web browsers cache files to minimize download requests, both within a site and across sites (in the case of popular JavaScript libraries such as Google Analytics or jQuery). But even with parallel downloads and caching, multiple files can be slower than single files.</p>
<p>Content delivery networks (CDNs) are faster at delivering popular JavaScript libraries than your own web server. However, once a file is cached (after the first download), CDNs offer no advantages. CDNs make sense for landing pages (the first page that a visitor encounters) but not so much for every page in a large site (where caching is at work). CDNs for popular JavaScript libraries offer no advantages if a visitor has a library cached from a visit to another site.</p>
<p>You can easily and cheaply set up a <span class="caps">CDN</span> for your own application with a service such as <a href="http://en.wikipedia.org/wiki/Amazon_CloudFront">CloudFront</a>. This gives you the advantage of a <span class="caps">CDN</span> for files you’ve added to the Rails asset pipeline, allowing you to combine popular JavaScript libraries with your own code for first-page delivery faster than your own server. But again, the only advantage is for first-page delivery.</p>
<p>Inline JavaScript (mixed in your <span class="caps">HTML</span> code) blocks loading and rendering the page. Plus it is messy to mix JavaScript, Ruby, and <span class="caps">HTML</span> in a view template. Keep JavaScript (or CoffeeScript) in its own files in the Rails assets directories.</p>
<p>The fewer <code>&lt;script&gt;</code> tags you use, the faster your pages will load. Modern web browsers download scripts in parallel but each script tag has to be parsed and evaluated to determine if a file is cached and current. Dynamic loading (from within another script) is faster than using an additional script tag.</p>
<p>Scripts that are concatenated into a single file (such as <em>application.js</em> with the Rails asset pipeline) minimize download time and can be cached for site-wide use.</p>
<p>External JavaScript libraries can be copied and concatenated into a single file to minimize download time. Make your own copy of an external library when your application requires a specific version. When you want to rely on a third party to update and maintain the library, don’t make a copy; use dynamic loading.</p>
<p>External JavaScript libraries that are likely to be cached from visits to other websites can be dynamically loaded from within your local JavaScript code. Dynamically loading scripts allows use of cached files, allows loading scripts asnychronously, and eliminates the overhead of parsing and evaluating multiple script tags.</p>
<p>Certain external JavaScript libraries that introduce security vulnerabilities, such as code that handles credit cards, should not be copied into your application asset directories. Instead, include the external script in an <em>application.js</em> script through dynamic loading.</p>
<p>When a single <em>application.js</em> script combines JavaScript used site-wide with JavaScript intended for use on individual pages, conditional execution of page-specific JavaScript tied to elements on an individual page reduces execution overhead.</p>
<p>In most cases, downloading a single script that combines site-wide and page-specific JavaScript (for a first page) and reading from a cache (for subsequent pages) will take less time than downloading multiple scripts on individual pages. The exception to this rule could be a very lengthy script that is used on only a single page that is not visited by most of the site’s visitors (for example, an administrative page). This exceptional case merits adding an additional script to an individual page using a second script tag, rather than including page-specific “big code” in the <em>application.js</em> script. Only performance testing can tell you whether this optimization is warranted.</p>
<p>Finally, a word about persistent folklore. You may have encountered the frequently repeated advice to “always place JavaScript at the bottom of the page just before the closing <code>&lt;/body&gt;</code> tag”. This was once true because web browsers loaded scripts sequentially and blocked loading and rendering until each script was complete. This is no longer true; modern browsers do “preload scanning” and begin loading all scripts in parallel, whether listed in the head element or at the bottom of the page. External JavaScript often is loaded asynchronously and is written so it won’t execute until the page is loaded and the <span class="caps">DOM</span> is ready. Loading a script in the head element is no longer a bad practice.</p>
<p>For a deeper and more detailed look at recommended practices for using JavaScript in a web application, look to advice from web performance optimization experts such as <a href="http://stevesouders.com/">Steve Souders</a> and <a href="http://www.nczonline.net/blog/">Nicholas C. Zakas</a>.</p>
<p>Now that we’ve considered principles to guide our evaluation, let’s look at the specifics of using JavaScript in Rails. But first, step back and consider why this is so complicated.</p>
<h2 id="missing">JavaScript’s Missing Directive</h2>
<p>The C language has <code>#include</code>, Java has <code>import</code>, Perl has <code>use</code> or <code>require</code>, <span class="caps">PHP</span> has <code>include</code> or <code>require</code>, and Ruby has <code>require</code>. These directives add the contents of one file into another. Often these directives are used to incorporate code libraries provided by other developers. Some languages also have a package manager that provides a standard format for distributing programs and libraries (Ruby has RubyGems). What’s the equivalent in JavaScript? Nothing. JavaScript doesn’t have a native package manager or import directive.</p>
<p>Instead, you’re expected to include all the JavaScript files you require for a web page in a series of <span class="caps">HTML</span>  <code>&lt;script&gt;</code> tags typically placed between the <code>&lt;head&gt;</code> tags at the top of an <span class="caps">HTML</span> file. The order of placement is important. The web browser compiles the JavaScript code sequentially. If your code requires an external library, the external script must be listed first. Each <code>&lt;script&gt;</code> tag requires a separate download and introduces a delay. JavaScript’s “missing include” leaves framework developers looking for ways to improve performance.</p>
<p>That’s where the Rails asset pipeline comes in.</p>
<h2 id="pipeline">Rails and the Asset Pipeline</h2>
<p>Rails 3.1 introduced the asset pipeline in August 2011.</p>
<p>Before 3.1, Rails did little to manage JavaScript. Developers used the <code>javascript_include_tag</code> helper to construct a <code>&lt;script&gt;</code> tag and add scripts directly to a view template or application layout. Before 3.1, developers used the helper to add every script required for an application.</p>
<p>The Rails asset pipeline improves website performance by concatenating multiple JavaScript files into a single script, allowing the developer to segregate code in separate files for development efficiency, but eliminating the performance penalty of multiple <code>&lt;script&gt;</code> tags.</p>
<p>The Rails asset pipeline adds some of the functionality of a package manager for project-specific JavaScript code. You can organize multiple JavaScript files in the <strong>app/assets/javascripts</strong> folder. The default <strong>app/assets/javascripts/application.js</strong> file serves as a manifest file, specifying which files you require. By default, the file’s <code>//= require_tree .</code> recursively includes all JavaScript files in the <strong>app/assets/javascripts</strong> directory. Sprockets, the mechanism that powers the Rails asset pipeline, will concatenate and minify all the specified JavaScript files into a single <em>application.js</em> script which you can include in your application layout with the <code>&lt;%= javascript_include_tag "application" %&gt;</code> statement. Sprockets also performs preprocessing so you can write JavaScript as CoffeeScript or include Ruby code as an <span class="caps">ERB</span> file. Order of execution is still important; a manifest file must list each JavaScript file in dependent order.</p>
<p>For more about the Rails asset pipeline, see:</p>
<ul>
<li>Rails Guide <a href="http://guides.rubyonrails.org/asset_pipeline.html">Asset Pipeline</a>
</li>
	<li>Railscasts <a href="http://railscasts.com/episodes/279-understanding-the-asset-pipeline">Understanding the Asset Pipeline</a>
</li>
	<li>Eric Berry’s <a href="http://coderberry.me/blog/2012/04/24/asset-pipeline-for-dummies/">Asset Pipeline for Dummies</a>
</li>
</ul><p>The Rails asset pipeline is innovative and useful. For the simplest use case, where a developer intends to use multiple scripts on every page of an application, the Rails asset pipeline is a no-brainer. But documentation for the Rails asset pipeline offers no guidance for two common implementation requirements: JavaScript libraries obtained from third parties (such as jQuery plugins) and scripts that are only used on a single page (page-specific JavaScript).</p>
<p>This article addresses these concerns.</p>
<h2 id="locations">Where to Stick Your JavaScript</h2>
<p>Whether you use the Rails asset pipeline or add a <code>&lt;script&gt;</code> tag directly to a view, you have to make a choice about where to put any local JavaScript file.</p>
<p>We have a choice of three locations for a local JavaScript file:</p>
<ul>
<li>the <strong>app/assets/javascripts</strong> folder</li>
	<li>the <strong>lib/assets/javascripts</strong> folder</li>
	<li>the <strong>vendor/assets/javascripts</strong> folder</li>
</ul><p>Here are guidelines for selecting a location for your scripts:</p>
<ul>
<li>Use <strong>app/assets/javascripts</strong> for JavaScript you create for your application.</li>
	<li>Use <strong>lib/assets/javascripts</strong> for scripts that are shared by many applications (but use a gem if you can).</li>
	<li>Use <strong>vendor/assets/javascripts</strong> for copies of jQuery plugins, etc., from other developers.</li>
</ul><p>In the simplest case, when all your JavaScript files are in the <strong>app/assets/javascripts</strong> folder, there’s nothing more you need to do.</p>
<p>Add JavaScript files anywhere else and you will need to understand how to modify a manifest file.</p>
<h2 id="manifest">Mysterious Manifests</h2>
<p>There are two kinds of files in a JavaScript assets folder:</p>
<ul>
<li>ordinary JavaScript files</li>
	<li>manifest files</li>
</ul><p>You can also have CoffeeScript files and <span class="caps">ERB</span> files which are variations on ordinary JavaScript files.</p>
<p>Manifest files have the same <em>.js</em> file extension as ordinary JavaScript files. Manifest files and ordinary JavaScript files can be combined in a single file. This makes manifest files mysterious, or at least non-obvious.</p>
<p>The default <strong>app/assets/javascripts/application.js</strong> file is a manifest file. It’s a manifest file because it contains directives:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require_tree .
</pre>
<p>Directives tell Sprockets which files should be combined to build a single JavaScript script. Each file that contains manifest directives becomes a single JavaScript script with the same name as the original manifest file. Thus the <strong>app/assets/javascripts/application.js</strong> manifest file becomes the <em>application.js</em> script.</p>
<p>All scripts in the <strong>app/assets/javascripts</strong> folder are automatically added to the default <em>application.js</em> script when the manifest file includes the default <code>//= require_tree .</code> directive. See below for suggestions why you might want to change this default.</p>
<p>If you add a script to the <em>vendor/…</em> folder and you wish to have it combined with your project code in the <em>application.js</em> script for use throughout your application, you must specify it with a directive in the manifest (details below). The same is true for the <em>lib/…</em> folder.</p>
<h2 id="organizing">Organizing Your Scripts</h2>
<p>Rails is all about following conventions to save effort and simplify teamwork. But there is no well-known and accepted practice for organizing your JavaScript files. Here’s advice I’ve found about organizing your scripts:</p>
<ul>
<li>Jerod Santo’s <a href="http://blog.jerodsanto.net/2012/02/a-simple-pattern-to-namespace-and-selectively-execute-certain-bits-of-javascript-depending-on-which-rails-controller-and-action-are-active/">A Simple Pattern to Namespace…</a>
</li>
	<li>Ken Collins’s <a href="https://speakerdeck.com/u/metaskills/p/secrets-of-the-asset-pipeline">Secrets Of The Asset Pipeline</a>
</li>
</ul><p>Leave a <a href="#comment">comment</a> below if you’d like to suggest ways to organize your JavaScript files. Here’s my advice about organizing your JavaScript files.</p>
<h3 id="default">Default Locations</h3>
<p>In a simple application, you can collect all the JavaScript files in the <strong>app/assets/javascripts</strong> folder and rely on the default <code>//= require_tree .</code> directive to combine the scripts into a single <em>application.js</em> script. Here we add <strong>google-analytics.js</strong> and <strong>admin.js</strong> files to the default directory.</p>
<pre>
+-javascripts/
| +-application.js (manifest)
| +-google-analytics.js
| +-admin.js
+-stylesheets/
</pre>
<p>There’s nothing to configure and it works as long as you don’t have any requirements to load the scripts in a particular order. Here’s the default <strong>app/assets/javascripts/application.js</strong> manifest file:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree .
</pre>
<p>The jQuery and Twitter Bootstrap scripts are included from gems and all scripts in the default directory are included.</p>
<p>In a complex application, use subdirectories to organize your scripts. Here are suggestions.</p>
<h3 id="sitewide">Site-wide Scripts</h3>
<p>You can create a folder <strong>app/assets/javascripts/sitewide</strong> for scripts that are used on all (or many) pages of the application. Here we place the <strong>google-analytics.js</strong> file in a directory we use for site-wide scripts:</p>
<pre>
+-javascripts/
| +-application.js (manifest)
| +-sitewide/
| | +-google_analytics.js
+-stylesheets/
</pre>
<p>In the manifest file <strong>app/assets/javascripts/application.js</strong>, remove the <code>//= require_tree .</code> directive and replace it with <code>//= require_tree ./sitewide</code> to automatically include all scripts in the <em>sitewide</em> directory.</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree ./sitewide
</pre>
<p>The jQuery and Twitter Bootstrap scripts are included from gems and any scripts in a <em>sitewide</em> directory are included.</p>
<p>There’s nothing more you need to do for site-wide scripts.</p>
<h3 id="specific">Page-Specific Scripts</h3>
<p>Following the principles described above, you will frequently include page-specific JavaScript in the <em>application.js</em> script to be combined with site-wide scripts. If you have only a few page-specific scripts, place them in the top-level <strong>app/assets/javascripts</strong> folder. For example, you might have an <em>admin.js</em> script you use on only a few administrative pages. Add it as <strong>app/assets/javascripts/admin.js</strong> file:</p>
<pre>
+-javascripts/
| +-application.js (manifest)
| +-admin.js
| +-sitewide/
| | +-google_analytics.js
+-stylesheets/
</pre>
<p>You’ll need to explicitly specify this script in the <strong>app/assets/javascripts/application.js</strong> manifest file if you’ve removed the <code>//= require_tree .</code> directive as described above. Note that we drop the file extension when we specify the filename in the manifest file. Set up the <strong>app/assets/javascripts/application.js</strong> manifest file like this:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree ./sitewide
//= require admin
</pre>
<p>The jQuery and Twitter Bootstrap scripts are included from gems; any scripts in a <em>sitewide</em> directory are included; and the <em>admin.js</em> script is included.</p>
<h3 id="namespace">Namespaces for Complex Applications</h3>
<p>In a complex application, you can use the assets directory structure to organize scripts for a “namespacing” effect. Choose an organizational structure that suits your application.</p>
<p>In this example, we have a single <em>admin.js</em> script that is used with all the views rendered by an AdminController. We have <em>articles.js</em> and <em>comments.js</em> scripts that correspond to view templates or partials that are used with a ContentController. You might consider another organizational scheme; the folder and file names can be anything that makes sense to you.</p>
<pre>
+-javascripts/
| +-application.js (manifest)
| +-admin/
| | +-admin.js
| +-content/
| | +-articles.js
| | +-comments.js
| +-sitewide/
| | +-google_analytics.js
+-stylesheets/
</pre>
<p>You’ll need to explicitly specify each script in the <strong>app/assets/javascripts/application.js</strong> manifest file. Set up the <strong>app/assets/javascripts/application.js</strong> manifest file like this:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree ./sitewide
//= require ./admin/admin
//= require ./content/articles
//= require ./content/comments
</pre>
<p>The jQuery and Twitter Bootstrap scripts are included from gems; any scripts in a <em>sitewide</em> directory are included; and the scripts in the <em>admin</em> and <em>content</em> directories are explicitly included.</p>
<h3>Create Your Own Gems When You Can</h3>
<p>By convention, <strong>lib/assets/javascripts</strong> is intended for scripts used on more than one project. Consider putting these in a gem to gain the benefits of RubyGems as a package manager if you use these scripts across different applications. You get easy version management and you can <code>bundle update &lt;gem&gt;</code> when you need the latest version of a JavaScript library.</p>
<p>The Rails asset pipeline will recognize scripts from any gem that contains files in these locations. If you wish to have a script from a gem combined with your project code in the <em>application.js</em> script for use throughout your application, you must specify it with a directive in the manifest.</p>
<p>Here’s where to place scripts in gems:</p>
<ul>
<li>
<strong>app/assets/javascripts</strong> will probably not be used for scripts in a gem</li>
	<li>
<strong>lib/assets/javascripts</strong> for scripts you share across your own projects</li>
	<li>
<strong>vendor/assets/javascripts</strong> for gemified jQuery plugins, etc., from open source projects</li>
</ul><p>Here’s an article that shows how to create a gem containing JavaScript code:</p>
<ul>
<li>Stephen Ball’s <a href="http://rakeroutes.com/blog/write-a-gem-for-the-rails-asset-pipeline/">How to Write (and Test) a Gem to Serve Static Files on the Rails Asset Pipeline</a>
</li>
</ul><h3>Use Open Source Gems</h3>
<p>It is ideal to use gemified versions of JavaScript code from open source projects such as jQuery because this gives you the advantage of RubyGems as a package manager. The <a href="https://github.com/joliss/jquery-ui-rails">jquery-ui-rails</a> gem from Jo Liss is an excellent example.</p>
<p>Unfortunately, few JavaScript projects are intended solely for Rails so there seldom is a gemified version of the JavaScript. Instead, the files are offered for downloading or from a content delivery network as external scripts.</p>
<p>External scripts are where JavaScript in Rails gets complicated.</p>
<h2 id="external">External Scripts</h2>
<p>The Rails asset pipeline is a powerful tool for managing project-specific JavaScript code; however, it doesn’t offer a facility for managing JavaScript files that are obtained outside of your own application. External scripts, those that are downloaded by a web browser from a remote web server, can be handled in three ways:</p>
<ul>
<li>copied locally and managed with the asset pipeline</li>
	<li>included from within another JavaScript file using a little-known Ajax technique</li>
	<li>added to an application layout or view with the <code>javascript_include_tag</code> helper</li>
</ul><h3>You Probably Should Use Not Use External Scripts</h3>
<p>The organizational and performance benefits of the Rails asset pipeline eliminate almost all reasons to use external scripts. In most cases, you’ll want to copy the external script locally and manage it with the asset pipeline. I’ll show you how to do that below.</p>
<p>Consider the benefits of the Rails asset pipeline. When there is a only a single <em>application.js</em> script to download, the browser will cache it on first encounter and after that will load it from the browser cache. Each script you add directly to a view using the <code>javascript_include_tag</code> will require an additional server hit.</p>
<p>For small applications with only a few pages, place the JavaScript code in its own file (for organizational efficiency) and give it a name that corresponds to the controller or view. Then let Sprockets concatenate and minify all your JavaScript files into a single <em>application.js</em> script. The default directive <code>//= require_tree .</code> in the  <strong>app/assets/javascripts/application.js</strong> manifest file will recursively include all JavaScript files in the <strong>app/assets/javascripts</strong> directory. Or remove the <code>//= require_tree .</code> directive and list each file individually. The script will be available throughout the application but you’ll only use it on a few pages. I’ll show you how to limit execution to a single page below.</p>
<p>For large applications, it may seem the browser will be more efficient if each page only gets the script it needs. In fact, the Rails asset pipeline will be faster delivering a single <em>application.js</em> file in almost all cases.</p>
<p>You’ll only know if there’s a performance benefit to downloading an external script if you actually profile performance. For rudimentary analysis, use the <em>Network</em> tab in the WebKit developer tool (in Chrome or Safari) or Firebug (in Firefox). You can use the <a href="http://developer.yahoo.com/yslow/">Yslow</a> tool for a detailed analysis of web page performance factors (see an article from New Relic on <a href="http://blog.newrelic.com/2012/09/04/improving-site-performance-with-yslow/">Improving Site Performance with YSlow</a>). The best tool for analysis of web page performance is the free <a href="http://www.webpagetest.org/">WebPagetest.org</a>.</p>
<h3 id="copy">Copy External Scripts Locally</h3>
<p>It’s easiest to simply copy an external script to your own application. By convention, the preferred location is in the <strong>vendor/assets/javascripts</strong> folder. It will work in the <strong>app/assets/javascripts</strong> folder but that’s not where it belongs.</p>
<p>Potential headaches with shifting versions can be minimized by using Michael Grosser’s <a href="https://github.com/grosser/vendorer">vendorer</a> gem to install and update external scripts.</p>
<p>To make a script available as part of the site-wide <em>application.js</em> script, you must specify it in your <strong>app/assets/javascripts/application.js</strong> manifest, like this:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require jquery.validate.min
</pre>
<p>In most cases, it is best to copy an external script locally and let the Rails asset pipeline combine it with your own project code. You’ll avoid complexity, gain the benefit of managing all your JavaScript in one place, and (in most cases) gain performance benefits.</p>
<p>Now let’s consider the edge cases where the use of an external script makes sense.</p>
<h3>Using External Scripts</h3>
<p>If a script is delivered by a content delivery network, likely to be cached in a web browser by visits to other sites, and used throughout your application, you might include the external script directly. The Google Analytics tracking script is an example.</p>
<p>You’d also want to use an external script when copying the script locally would introduce a security vulnerability. Scripts that process credit card data are an example.</p>
<p>Here we’ll look closely at how to use external scripts. First, we’ll consider how an external script interacts wih local scripts (dependencies). Then we’ll look at options for including external scripts in the asset pipeline. Finally we’ll look at the how to include an external script directly in a view as page-specific JavaScript.</p>
<h3 id="none">No Dependencies</h3>
<p>Some external scripts work independently of your project-specific JavaScript code. For example, you might add the HTML5Shiv <code>&lt;%= javascript_include_tag 'http://html5shiv.googlecode.com/svn/trunk/html5.js' %&gt;</code> to your application layout to support HTML5 tags in old versions of Internet Explorer. Your own JavaScript would not be dependent on the file. You could load it either before or after your <em>application.js</em> script (though in the case of HTML5Shiv you’d want to load it before any <span class="caps">CSS</span> files).</p>
<h3 id="simple">Simple Dependencies</h3>
<p>Some external scripts have simple dependency chains.</p>
<p>If you were going to use the Google Maps <span class="caps">API</span> throughout your application, here’s what you would add to your application layout file:</p>
<pre>
&lt;%= javascript_include_tag 'http://maps.googleapis.com/maps/api/js?sensor=false' %&gt;
&lt;%= javascript_include_tag 'application' %&gt;
</pre>
<p>You would load the Google Maps <span class="caps">API</span> before your <em>application.js</em> script with the <code>&lt;%= javascript_include_tag %&gt;</code>. Then you could write JavaScript code that uses methods from the Google Maps <span class="caps">API</span>.</p>
<h3 id="complex">Complex Dependencies</h3>
<p>Now consider the problem of external scripts that are dependent on jQuery. For example, you might wish to use a jQuery plugin. It has to be loaded after the <em>application.js</em> script which loads jQuery.</p>
<p>You could set up your application layout like this:</p>
<pre>
&lt;%= javascript_include_tag 'application' %&gt;
&lt;%= javascript_include_tag 'http://ajax.aspnetcdn.com/ajax/jquery.validate/1.9/jquery.validate.min.js' %&gt;
&lt;%= javascript_include_tag 'code_that_uses_the_validation_plugin' %&gt;
</pre>
<p>This is the kind of complexity that the asset pipeline is intended to eliminate. Instead of segregating your code and loading it as a separate file, use the asset pipeline. There are two ways to load the jQuery plugin in the middle of the <em>application.js</em> script. You can copy the external library to your own application as described above. Or you can include an external JavaScript file from within a local JavaScript file, which apparently cannot be done.</p>
<h3 id="including">Including a JavaScript File From Within a JavaScript File</h3>
<p>I said that <em>apparently</em> one cannot insert an external script in the middle of the asset pipeline. In fact it can be done, despite JavaScript’s lack of an import directive.</p>
<p>The technique is used on millions of web pages and you may have used it without realizing it:</p>
<pre>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXX-XX']);
_gaq.push(['_trackPageview']);
(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</pre>
<p>Does that look familar? It’s the Google Analytics tracking code. It creates a tiny script using <code>document.createElement</code> and inserts it into the page where it dynamically and asynchronously downloads the full Google Analytics script.</p>
<p>The Google Analytics tracking code is delivered by a content delivery network, likely to be cached in a web browser by visits to other sites, and used throughout an application. In this case, the Rails asset pipeline doesn’t offer any performance advantages so you might include the Google Analytics tracking code as an external script.</p>
<p>You could add it directly to the application layout. Instead, you can use the asset pipeline and include it from within another JavaScript file. Using the asset pipeline gives you a benefit: Your application layout is less cluttered when all your JavaScript is consolidated in the <em>application.js</em> script.</p>
<p>You can use the <code>document.createElement</code> method or let jQuery help you.</p>
<p>JQuery offers the <a href="http://api.jquery.com/jQuery.getScript/">jQuery getScript method</a>. It will load any JavaScript file from within a JavaScript file. The <code>getScript</code> method has one big limitation: It doesn’t retrieve scripts from the browser cache. To overcome this limitation, we can define a similar method that looks for a cached script before attempting a download of an external script.</p>
<p>Here’s how we use jQuery to download (or load from the cache) a JavaScript file from within the Rails asset pipeline. Create a file <strong>app/assets/javascripts/google_analytics.js.erb</strong>:</p>
<pre>
jQuery.externalScript = function(url, options) {
  // allow user to set any option except for dataType, cache, and url
  options = $.extend(options || {}, {
    dataType: "script",
    cache: true,
    url: url
  });
  // Use $.ajax() since it is more flexible than $.getScript
  // Return the jqXHR object so we can chain callbacks
  return jQuery.ajax(options);
};
</pre>
<p>With the <code>externalScript</code> function in place, we can add the Google Analytics script to our asset pipeline. Add to the file <strong>app/assets/javascripts/google_analytics.js.erb</strong>:</p>
<pre>
&lt;% if Rails.env == 'production' %&gt;
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-XXXXXXX-XX']);
  _gaq.push(['_trackPageview']);
  ga_src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  $.externalScript(ga_src).done(function(script, textStatus) {
    console.log('Script loading: ' + textStatus );
    if (typeof _gat != 'undefined') {
      console.log('Okay. GA file loaded.');
    }
    else
    {
      console.log('Problem. GA file not loaded.');
    }
  });
&lt;% end %&gt;
</pre>
<p>Notice that we only load the Google Analytics script for tracking traffic in production mode. To do so, we use the <em>.erb</em> file extension so it will be preprocessed by Tilt.</p>
<p>If you want to use the <code>externalScript</code> method in other JavaScript files, move it to <strong>app/assets/javascripts/application.js</strong> and add <code>//= require_self</code> to the manifest.</p>
<p>With this technique, you’ve added an external script to the site-wide <em>application.js</em> script without copying it locally.</p>
<p>Now let’s consider cases where you want to use JavaScript on a specific page, not throughout the entire application. If external scripts are complicated, page-specific JavaScript in Rails gets even more complex.</p>
<h2 id="specific">Page-Specific JavaScript</h2>
<p>First we’ll consider how to execute JavaScript on a specific page. Then we’ll consider where to put a local JavaScript file that contains page-specific JavaScript. Finally we’ll look at ways to combine a JavaScript library from an external script with local page-specific JavaScript.</p>
<h3 id="conditional">Conditional Execution of Page-Specific JavaScript</h3>
<p>Often JavaScript is written to interact with specific elements on a page; if so, the browser will evaluate the JavaScript on every page but only activate it if the appropriate page element is present. The JavaScript you need for that page can be part of the site-wide <em>application.js</em> script or it can be included on the page with a <code>javascript_include_tag</code> statement in the view or application layout.</p>
<p>JavaScript execution can be determined by</p>
<ul>
<li>the presence of unique elements on the page, or</li>
	<li>attributes in the <span class="caps">HTML</span> <code>body</code> tag.</li>
</ul><p>You can simply test for an element’s unique <span class="caps">HTML</span> element ID:</p>
<pre>
$('document').ready(function() {
  if($('#main').length){
    console.log("element exists");
  }
});
</pre>
<p>A more organized approach is to test for attributes in the <span class="caps">HTML</span> <code>body</code> tag:</p>
<ul>
<li>Set <code>class</code> or <code>id</code> attributes on your page’s body element.</li>
</ul><ul>
<li>Use functions in your JavaScript that parse those classes or ids and call the appropriate functions.</li>
</ul><p>First you must modify the application layout. Replace the <code>&lt;body&gt;</code> statement in the <strong>app/views/layouts/application.html.erb</strong> file:</p>
<pre>
&lt;body class="&lt;%= params[:controller] %&gt;"&gt;
</pre>
<p>Assuming a page is generated by a Projects controller, the rendered page will include:</p>
<pre>
&lt;body class="projects"&gt;
</pre>
<p>Use this condition in your JavaScript code:</p>
<pre>
$('document').ready(function() {
  if ($('body.projects').length) {
    console.log("Page generated by the projects controller.");
  }
});
</pre>
<p>This approach can be refined by setting both the controller name and action in the <span class="caps">HTML</span> <code>body</code> tag:</p>
<pre>
&lt;body class="&lt;%= controller_name %&gt; &lt;%= action_name %&gt;"&gt;
</pre>
<p>You have a choice of syntax: use either <code>&lt;%= params[:controller] %&gt;</code> or <code>&lt;%= controller_name %&gt;</code>.</p>
<p>Use John Firebaugh’s <a href="https://github.com/Verba/jquery-readyselector">jquery-readyselector</a> gem to extend the jQuery <code>.ready()</code> to simplify the conditional test:</p>
<pre>
$('.project.index').ready(function() {
  console.log("Page-specific JavaScript on the projects/index page.");
});
</pre>
<p>For a sophisticated variation on this approach, investigate the <a href="http://viget.com/inspire/extending-paul-irishs-comprehensive-dom-ready-execution">Garber-Irish</a> technique.</p>
<p>Now that we’ve seen how to execute JavaScript conditionally, let’s consider where to add the JavaScript file that contains the code.</p>
<h3 id="folder">Using the <em>lib/assets</em> Folder for Page-Specific JavaScript</h3>
<p>We have a choice of three locations for a local JavaScript file:</p>
<ul>
<li>the <strong>app/assets/javascripts</strong> folder</li>
	<li>the <strong>lib/assets/javascripts</strong> folder</li>
	<li>the <strong>vendor/assets/javascripts</strong> folder</li>
</ul><p>In development mode, Sprockets will precompile every file in each of these folders. See <a href="#precompiling">Precompiling in Production</a> (below) for configuration issues for deployment.</p>
<p>The best location for a page-specific JavaScript file is the <strong>lib/assets/javascripts</strong> folder if you want to leave the <strong>app/assets/javascripts/application.js</strong> file intact.</p>
<p>Consider the alternatives. If you place a page-specific JavaScript file in the <strong>app/assets/javascripts</strong> folder, Sprockets will combine it with all the other scripts in the folder and make it available throughout the application as part of a single large <em>application.js</em> script. You can change the Rails default configuration to prevent this by removing the <code>//= require_tree .</code> directive, but the change is not necessary if you place the script in the <strong>lib/assets/javascripts</strong> folder.</p>
<p>You can also place a page-specific JavaScript file in the <strong>vendor/assets/javascripts</strong> folder. That works but, by convention, that folder is for third-party assets such as jQuery plugins.</p>
<h3 id="adjusting">The Alternative to Using <strong>lib/assets/javascripts</strong>
</h3>
<p>Here’s another way to handle page-specific JavaScript. It allows you to place your page-specific scripts in the <strong>app/assets/javascripts</strong> folder. It requires you to remove the <code>//= require_tree .</code> directive from the manifest and specify each script individually (or specify other manifest files).</p>
<p>You may see other developers using this approach. They may be using it to enforce logical organization on their application-wide JavaScript. That’s a good reason to adopt this approach. However, this approach is not necessary if you simply want to accommodate page-specific scripts. Use the approach described above, instead.</p>
<p>First you must modify the <strong>app/assets/javascripts/application.js</strong> file to remove the <code>//= require_tree .</code> directive or else your page-specific JavaScript code will be included on every page. After removing the <code>//= require_tree .</code> directive, add a directive for each specific file you want compiled and concatenated into the <em>application.js</em> script. For example, if you want Twitter Bootstrap from the <a href="https://github.com/thomas-mcdonald/bootstrap-sass">bootstrap-sass</a> gem:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
</pre>
<p>Specifying each script in the manifest makes it possible to remove the <code>//= require_tree .</code> directive and still create a concatenated site-wide <em>application.js</em> script.</p>
<h3 id="appropriate">Where External Scripts and Page-Specific JavaScript are Appropriate</h3>
<p>Let’s consider cases where external scripts and page-specific JavaScript can be useful.</p>
<p>An external script and page-specific JavaScript has value when copying an external file to your server increases vulnerability.</p>
<p>Also, page-specific JavaScript may have value when a script is used on a single page that is not visited by most users.</p>
<p>Consider this example. I want to use the Stripe JavaScript library to initiate transactions for credit card payment. I don’t want to store the Stripe code on my server because of the risk that someone could gain access to my server and change the code to intercept credit card data.</p>
<p>We use the Stripe script only on a single page where the visitor makes a credit card payment. There will be a performance cost to download and cache the Stripe JavaScript file. We know that only a small number of visitors to the site will be visiting the payment page so using page-specific JavaScript reduces the performance hit for other users.</p>
<p>First, let’s write a local script that uses the the Stripe JavaScript library. Here is our example <strong>lib/assets/javascripts/payment.js</strong> file:</p>
<pre>
$(function() {
  if (typeof Stripe != 'undefined') {
    console.log('Stripe JavaScript file loaded.');
  }
  else
  {
    console.log('Problem: Stripe JavaScript file not loaded.');
  }
});
</pre>
<p>We can use it to test if the external JavaScript file is loaded.</p>
<p>Now we’ll consider how to add page-specific JavaScript directly to the view that renders the page.</p>
<h3 id="layout">Application Layout for Page-Specific JavaScript</h3>
<p>For page-specific JavaScript, you’ll need to add a <code>javascript_include_tag</code> to the <code>head</code> section of your page view. One approach is to modify your controller to use a custom layout for the view (see a range of approaches in the RailsGuide <a href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-render">Layouts and Rendering in Rails</a>). I suggest you leave your controller alone. Such a minor customization defeats the purpose of the site-wide application layout; fortunately, Rails offers a better option.</p>
<p>Set up your application layout with a <code>&lt;%= yield(:head) %&gt;</code> statement so you can inject additional tags in the <code>head</code> section of the view. See an example of a <a href="http://railsapps.github.com/rails-default-application-layout.html">Rails Default Application Layout</a> from the RailsApps project. Here’s an example of the <code>head</code> section in the <strong>app/views/layouts/application.html.erb</strong> file:</p>
<pre>
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;&lt;%= content_for?(:title) ? yield(:title) : "App_Name" %&gt;&lt;/title&gt;
  &lt;meta name="description" content="&lt;%= content_for?(:description) ? yield(:description) : "App_Name" %&gt;"&gt;
  &lt;%= stylesheet_link_tag "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  &lt;%= csrf_meta_tags %&gt;
  &lt;%= yield(:head) %&gt;
&lt;/head&gt;
</pre>
<p>The <code>&lt;%= yield(:head) %&gt;</code> statement follows the <code>&lt;%= javascript_include_tag "application" %&gt;</code> so you can add additional scripts and still use jQuery in any page-specific JavaScript code you add.</p>
<h3 id="contentfor">Using <em>content_for</em> for Page-Specific JavaScript</h3>
<p>Imagine a payment form used in our application. We want both the external Stripe script and our local <em>payment.js</em> script available on the payment page. We’ll use the <code>&lt;% content_for %&gt;</code> helper to include the two scripts.</p>
<p>Here’s our imaginary payment view:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;
  &lt;%= javascript_include_tag 'payment' %&gt;
&lt;% end %&gt;
&lt;h2&gt;Payment Page&lt;/h2&gt;
&lt;%= form_for(resource, :as =&gt; resource_name, :url =&gt; payment_path(resource_name)) do |f| %&gt;
  .
  .
  .
  (credit card data entered here)
  .
  .
  .
  &lt;div&gt;&lt;%= f.submit "Purchase" %&gt;&lt;/div&gt;
&lt;% end %&gt;
</pre>
<p>The <code>&lt;% content_for :head ... %&gt;</code> block allows us to add page-specific JavaScript files to the view.</p>
<p>The Rails asset pipeline will find our <em>payment.js</em> script in the <strong>lib/assets/javascripts</strong> folder and make it available so it appears with a path of <code>/assets/payment.js</code>.</p>
<p>If we view <span class="caps">HTML</span> source, we will see generated <span class="caps">HTML</span> that looks like this:</p>
<pre>
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;
  &lt;title&gt;App_Name&lt;/title&gt;
  &lt;meta name="description" content="App_Name"/&gt;
  &lt;link href="/assets/application.css" media="all" rel="stylesheet" type="text/css" /&gt;
  &lt;script src="/assets/application.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;meta content="authenticity_token" name="csrf-param" /&gt;
  &lt;meta content="..." name="csrf-token" /&gt;
  &lt;script src="https://js.stripe.com/v1/" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="/assets/payment.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
<p>In development mode, this works without any changes to the Rails default configuration.</p>
<h3 id="parameter">Script Name as Parameter</h3>
<p>You don’t need to specify the actual script name in the <code>javascript_include_tag</code>. You can give the script the same name as the controller and use:</p>
<pre>
&lt;%= javascript_include_tag "#{params[:controller]}" %&gt;
</pre>
<p>Or combine the controller name and view as the name of the script and use:</p>
<pre>
&lt;%= javascript_include_tag "#{params[:controller]}.#{params[:action}" %&gt;
</pre>
<p>This is useful for a complex application where you’ve organized the asset folder into subfolders and given each script a name that corresponds with a controller and view.</p>
<h3 id="precompiling">Precompiling in Production</h3>
<p>In development mode, nothing more is required to use our new <em>payment.js</em> script on any page where it is needed. The asset pipeline “live compiles” all the JavaScript files it finds and makes them available for use.</p>
<p>For production, we must make an important configuration change so our new script is precompiled and available on deployment.</p>
<p>Add this to the file <strong>config/environments/production.rb</strong>:</p>
<pre>
config.assets.precompile += %w( payment.js )
</pre>
<p>If we’ve created a CoffeeScript or <span class="caps">ERB</span> file, we don’t need to include the <strong>.coffee</strong> or <strong>.erb</strong> file extension.</p>
<p>When you precompile assets in production mode, the Rails asset pipeline will automatically process the <strong>app/assets/javascripts/application.js</strong> file and any additional files listed in its manifest to produce a concatenated and minified site-wide <em>application.js</em> script.</p>
<p>Any other scripts that you wish to use on a page in addition to the site-wide <em>application.js</em> script must be specified by the <code>config.assets.precompile</code> statement or else they will not be precompiled and made available in production mode.</p>
<p>Sprockets will look for files designated in the <code>config.assets.precompile</code> statement and create JavaScript files with the same names. If the file contains manifest directives, it will combine other files to make a single script.</p>
<p>If you don’t make this configuration change, you won’t see the error until your application is deployed in production.</p>
<h3>Page-Specific JavaScript Summary</h3>
<p>With these four steps, you’ll be able to easily use page-specific JavaScript code:</p>
<ul>
<li>Add any local script to the <strong>lib/assets/javascripts</strong> folder.</li>
	<li>Use <code>&lt;%= yield(:head) %&gt;</code> in the application layout.</li>
	<li>Use <code>&lt;% content_for :head ... %&gt;</code> in the view.</li>
	<li>Modify <strong>config/environments/production.rb</strong> to add <code>config.assets.precompile</code> for your script.</li>
</ul><h3 id="testing">Testing in Production Mode</h3>
<p>How can you tell if you’ve configured your application to serve the scripts needed in production?</p>
<p>Test it.</p>
<p>To test, you must enable your Rails web server to deliver static assets. Modify the <strong>config/environments/production.rb</strong> file:</p>
<pre>
# Disable Rails's static asset server (Apache or nginx will already do this)
config.serve_static_assets = true
</pre>
<p>Be sure to switch this back after trying out your application locally in production mode.</p>
<p>Then try running your server locally in production mode:</p>
<pre>
$ rake db:migrate RAILS_ENV=production
$ rake assets:precompile
$ rails server -e production
</pre>
<p>Visit the web pages that use your scripts and check functionality. In our Stripe example, we’ll see an error “payment.js isn’t precompiled” unless we set <code>config.assets.precompile</code> to include it.</p>
<p>Use <code>rake assets:clean</code> to remove the precompiled assets when you return to development mode.</p>
<h2 id="comment">Credits</h2>
<p>Daniel Kehoe wrote this article for the RailsApps project.</p>
<p>Was this useful to you? Follow me on Twitter: <a href="http://twitter.com/rails_apps">rails_apps</a> <br>
and tweet some praise. I’d love to know you were helped out by the article.</p>
<p>Thank you to Peter Cooper (<a href="http://twitter.com/peterc">@peterc</a>), Pat Shaughnessy (<a href="http://twitter.com/pat_shaughnessy">@pat_shaughnessy</a>), Eric Berry (<a href="http://twitter.com/cavneb">@cavneb</a>), Ken Collins (<a href="http://twitter.com/metaskills">@metaskills</a>), Jo Liss (<a href="http://twitter.com/jo_liss">@jo_liss</a>), Stephen Ball (<a href="http://twitter.com/StephenBallNC">@StephenBallNC</a>), and Andrey Koleshko (<a href="http://twitter.com/ka8725">@ka8725</a>) for technical review and advice.</p>
    </div><!-- class="content" -->
    
    <div class="comments">
      <div class="content wikistyle gollum">
        <h2>Comments</h2>
      </div>
      <p>Is this helpful? Your encouragement fuels the project. Please tweet or add a comment. Couldn't get something to work? For the example apps and tutorials, it's best to open an issue on GitHub so we can help you.</p> 
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'railsapps'; // required: replace example with your forum shortname
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div><!-- class="comments" -->

    <div class="footer row">
      <div class="span4">
      </div>
    
      <div class="span4">
       </div>

      <div class="span4">
      </div>
    </div>

  </div>
            
  </body>
</html>
