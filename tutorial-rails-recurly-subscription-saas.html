<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>tutorial rails recurly subscription saas &#183; RailsApps</title>
    <link href="https://plus.google.com/u/0/b/117374718581973393536/117374718581973393536/posts/" rel="publisher" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/bootstrap.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/site.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/syntax.css" type="text/css" charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.6.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/gollum.js" type="text/javascript"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-5109366-14']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a href="http://railsapps.github.com/" class="brand">RailsApps Project</a>
        <ul class="pull-right nav">
          <li><a href="http://blog.railsapps.org/" class="twitter">Blog</a></li>
          <li><a href="http://twitter.com/rails_apps" class="twitter">Twitter</a></li>
          <li><a href="https://plus.google.com/117374718581973393536" class="google">Google +</a></li>
          <li><a href="https://github.com/RailsApps" class="github">GitHub Repository</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container"> 

    <div class="content wikistyle gollum textile">
      <h1>Rails Tutorial for a Membership, Subscription, or SaaS Site with Recurly</h1>
<h4>by Daniel Kehoe</h4>
<p><em>Last updated 21 December 2012</em></p>
<h2>Introduction</h2>
<p>Ruby on Rails tutorial for a web application with recurring billing using Recurly. Use for a Rails membership site, subscription site, or SaaS site (software-as-a-service).</p>
<ul>
<li>
<a href="https://recurly.com/">Recurly</a> for recurring billing</li>
	<li>
<a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication</li>
	<li>
<a href="https://github.com/ryanb/cancan">CanCan</a> with <a href="https://github.com/EppO/rolify">Rolify</a> for authorization</li>
	<li>
<a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a> front-end framework for <span class="caps">CSS</span> styling</li>
</ul><h3>Screenshot</h3>
<p><img src="http://railsapps.github.com/images/rails-recurly-subscription-saas.png" title="Rails Application for a Membership, Subscription, or SaaS Site" alt="Rails Application for a Membership, Subscription, or SaaS Site"></p>
<p>This example application exists so you don’t have to build it yourself. It aims to:</p>
<ul>
<li>eliminate effort spent building an application that meets a common need;</li>
	<li>offer code that is already implemented and tested by a large community;</li>
	<li>provide a well-thought-out app containing most of the features you’ll need.</li>
</ul><p>Membership sites restrict access to content such as articles, videos, or user forums. Software-as-a-service (SaaS) sites limit use of web-based software to paid subscribers. The revenue model is the same whether the site provides high-value content or software as a service: A visitor purchases a subscription and gains access to restricted areas of the site. Typically, the subscription is repurchased monthly through a service that provides recurring billing.</p>
<h3>Functionality</h3>
<p>If you’re planning to build a SaaS application, a membership site, or some other subscription-based web service, your application will need the following rudimentary functionality:</p>
<ul>
<li>content or web functionality to deliver value</li>
	<li>landing pages to convert visitors to paying customers</li>
	<li>user management to register or remove users</li>
	<li>access control to limit site-wide access to authenticated users</li>
	<li>authorization management to restrict access to content or services based on role or other characteristics</li>
	<li>account management to maintain records of subscription status</li>
	<li>a recurring billing system for periodic payment transactions</li>
</ul><h3>Features</h3>
<p>The example application provides a complete and fully functional membership site.</p>
<ul>
<li>tiered pricing for multiple subscription plans</li>
	<li>optional “free trial” subscription as well as free accounts using Recurly</li>
	<li>uses Recurly for no local credit card storage</li>
	<li>Recurly accepts credit card payments from customers in any country or currency</li>
	<li>
<span class="caps">PCI</span> compliance using the Recurly JavaScript library</li>
	<li>Recurly handles recurring billing, retries if payment fails, and cancels subscription if retries fail</li>
	<li>paid subscriptions are created only after a successful credit card transaction</li>
	<li>subscribers can upgrade or downgrade subscription plans</li>
	<li>subscribers can cancel subscription plans</li>
	<li>configurable subscription renewal period (defaults to one month)</li>
	<li>administrator can change subscription plan or delete user</li>
</ul><h3>What is Not Implemented</h3>
<p>There are additional features you may want for a SaaS application, such as:</p>
<ul>
<li>Basecamp-style subdomains (each user gets their own subdomain)</li>
	<li>
<a href="http://en.wikipedia.org/wiki/Multitenancy">multitenancy</a> database segmentation</li>
</ul><p>These features are not included in this application. See the <a href="https://github.com/RailsApps/rails3-subdomains">rails3-subdomains</a> example application for help with subdomains. For multitenancy, try Brad Robertson’s <a href="https://github.com/bradrobertson/apartment">Apartment</a> gem.</p>
<h3>About the Gems</h3>
<p>RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a “gem”). Gems add functionality to a Rails app.</p>
<p>We use these gems:</p>
<ul>
<li>
<a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication</li>
	<li>
<a href="https://github.com/ryanb/cancan">CanCan</a> with <a href="https://github.com/EppO/rolify">Rolify</a> for authorization</li>
	<li>
<a href="https://recurly.com/">Recurly</a> for recurring billing</li>
</ul><h4>Devise</h4>
<p>Devise provides authentication, a system to securely identify users, making sure the user is who he represents himself to be.</p>
<p>We use Devise because it offers a full set of features used in more complex applications, such as recovering a user’s forgotten password or allowing users to invite friends. Should you need help in troubleshooting or customizing the implementation, you’ll be able to get help from a large community of developers using Devise.</p>
<h4>CanCan with Rolify</h4>
<p>CanCan provides a system for authorization to determine if an authenticated user should have access to secured resources. CanCan is often used to restrict access to administrative pages. This application will use CanCan to restrict access to content based on the price a user has paid for a subscription.</p>
<p>CanCan provides a mechanism for limiting access at the level of controller and controller method and expects you to set permissions based on user attributes you define. CanCan doesn’t provide default user attributes such as user roles based on subscription price; you must implement this outside of CanCan. There are many ways to implement role-based authorization for use with CanCan. For this example, we use Florent Monbillard’s Rolify gem to create a Role model, add methods to a User model, and generate a migration for a roles table.</p>
<h4>Recurly</h4>
<p>Recurly is a third-party billing service that provides an <span class="caps">API</span> and gem for integration with Rails applications. There are several other third-party billing services; for example, <a href="https://stripe.com/">Stripe</a> is popular and may be the least expensive and most popular for low-volume startups. (See the <a href="http://railsapps.github.com/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> application from the RailsApps project if you want to use Stripe.) Unlike Stripe, Recurly requires you to obtain a merchant bank account from a third party which requires an additional step and a few days lead time. Recurly charges a monthly minimum fee of $69 per month which makes the per-transaction cost higher than Stripe for low-volume businesses. Above a threshold of about 600 monthly users (at an average transaction of $10), Recurly will be less expensive than Stripe (see the <a href="http://www.billingsavvy.com/">BillingSavvy</a> calculator). Unlike Stripe, Recurly offers dunning management (sending emails to users with expired credit cards) that can increase customer retention. Stripe is available to businesses with US and Canadian bank accounts only; Recurly is available to businesses in many more countries. (Are there other reasons to use Recurly versus Stripe? <a href="#comments">Leave a comment</a>.)</p>
<h4>Database</h4>
<p>The tutorial shows how to set up the application using a <a href="http://www.sqlite.org/">SQLite</a> database. Rails uses the SQLite database by default. Mac OS X come with SQLite pre-installed and there’s nothing to configure. On Windows, if you use a pre-assembled package to install Rails, it will likely have SQLite pre-installed. On Ubuntu Linux, you can easily install SQLite. If you prefer to use MySQL or PostgreSQL, it’s easy to change the application Gemfile and no changes are required for the application.</p>
<h2>Architecture and Implementation</h2>
<p>Here is a high-level abstraction of the application, as a list of systems:</p>
<ul>
<li>user management with Devise (to register or remove users)</li>
	<li>authentication with Devise (log in and log out)</li>
	<li>authorization management with CanCan and Rolify (access determined by the subscription plan)</li>
	<li>account management to maintain records of subscription status</li>
	<li>recurring billing with Recurly</li>
	<li>landing pages</li>
	<li>content or service pages</li>
</ul><h3>User Management, Authentication, and Authorization</h3>
<p>The tutorial for the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application shows how to set up user management and authentication using Devise, as well as authorization management using CanCan and Rolify. The first step in the tutorial will be to generate the rails3-bootstrap-devise-cancan application as a starter app.</p>
<p>Users are managed with the User model, which has attributes for name, email, and password, as well as some fields provided by Devise such as sign_in_count. The Devise gem provides its own controllers for managing sessions, registration, email confirmation and similar functions. You won’t see these controllers as they are hidden in the gem itself.</p>
<p>CanCan uses an Ability model to set access control rules. We’ll modify the Ability model to set access rules based on subscription plans. We’ll use the Role model required by Rolify to define roles based on subscription plans.</p>
<h3>Account Management and Recurring Billing</h3>
<p>An account management system keeps subscription records so the access control system can determine which users are current subscribers. We’ll combine services offered by Recurly with user management provided by Devise for our account management system.</p>
<p>Recurly will provide the recurring billing system to store the users’ credit card data and initiate payment transactions.</p>
<p>We’ll use the Recurly <span class="caps">API</span> to create a new customer and specify a subscription plan. When the customer’s subscription expires due to failed payment, we’ll use Recurly “webhooks” to update our application’s user records.</p>
<p>We’ll provide options for the user to upgrade or downgrade subscription plans and cancel a subscription as an extension of the user management system provided by Devise. We’ll provide a link to Recurly’s subscription interface for the user to change credit cards.</p>
<p>Two approaches are possible in building a recurring billing system. You could implement a complete billing management system as part of the application. This would require building a mechanism to check for expiring subscriptions (typically a daily cron job) and initiate payment requests through Recurly when a user’s account comes due. With this approach, you would use Recurly only for processing credit card transactions. But there’s no reason to implement recurring billing yourself. Recurly provides a complete, well-tested, and hosted mechanism for recurring billing. We’ll use Recurly’s <span class="caps">API</span> to supply the recurring billing services we need.</p>
<p>A key requirement for the application is to keep the recurring billing and account management systems in sync. We face a problem if we establish a new subscription, hand off recurring billing to Recurly, and then months later find that the subscriber’s credit card has expired and can no longer be billed. We need a mechanism to update our subscription status when Recurly encounters a declined transaction. Recurly provides “webhooks” to set the status of a subscription. When Recurly encounters a declined transaction it will initiate an <span class="caps">HTTP</span> request to our application which we can decode to change a subscription status.</p>
<p>If we didn’t use the Recurly webhooks, we’d have to either query the Recurly <span class="caps">API</span> on each login or run a repeating cron job to check for subscription expiration. The application will be notified immediately by Recurly so there is no need for the overhead of checking on each login. The Recurly webhook mechanism is very robust: If for some reason it cannot make an <span class="caps">HTTP</span> request to our application, it will retry several times with exponential backoff.</p>
<p>A key requirement for any ecommerce site that takes credit cards is <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> to minimize risk of customer credit card exposure. Using Recurly, your server will never receive sensitive credit card details. Instead you’ll use a the Recurly JavaScript library on your subscription payment form which sends the credit card details directly to the Recurly servers. Your business can easily meet <span class="caps">PCI</span> compliance requirements of the “<span class="caps">PCI</span> <span class="caps">DSS</span> Self-Assessment Questionnaire A” if you solely accept payment information through the Recurly JavaScript library and serve your payment page over <span class="caps">SSL</span>.</p>
<h3>Landing Pages</h3>
<p>Landing pages serve to describe the value of the content or service and convince the visitor to purchase a subscription. For our example application, the home page of the application is our landing page.</p>
<h3>Content or Service</h3>
<p>We’ll create placeholder pages for content.</p>
<p>For your application, the content can be anything you like: photo galleries, videos, downloadable ebooks. For a SaaS site, subscribers would gain access to a web application.</p>
<h3>The Object Model</h3>
<p>Software engineering attempts to model real-world entities and behaviors. As developers, we try to choose descriptive names for objects and methods to reduce ambiguity and increase understanding. For this application, a User is our most important object. In other projects, we might call this object an “Account” or “Member.”</p>
<p>Users have several important attributes: email address, password, credit card number, subscription plan. A user also has less important attributes such as name or creation date. Any of these attributes could be separate objects that are associated with the user through an id or key. You could make “Subscription” or “Plan” an object associated with a user. To keep this application simple, we’ll define everything we need as attributes of the user, rather than separate objects.</p>
<p>We won’t include a credit card number as an attribute of a user because we don’t want the vulnerability of storing a credit card number in our database. Instead, we’ll send the credit card number directly to Recurly and set a unique customer id that we’ll use to identify the subscriber in both our application and the Recurly billing system.</p>
<p>Our authorization system is based on the concept of roles. The user’s role constrains his or her access to the website’s content pages. Though “Subcription Plan” and “Role” appear to be distinct concepts, in this application they functionally overlap. We’ll use the Role model supplied by the Rolify gem as an object that corresponds to a “Subcription Plan.” Each user will have a role id that describes the subscription plan (or access level) that he or she has purchased.</p>
<h2>Accounts You May Need</h2>
<p>Before you start, you will need accounts for <em>recurring billing</em>, a <em>merchant account</em>, <em>hosting</em>, <em>email</em>, and a <em>source control repository</em>. You should also consider how you will implement <span class="caps">SSL</span> for security.</p>
<h3>Billing</h3>
<p>Many providers of billing services want your business:</p>
<ul>
<li>
<a href="https://stripe.com/">Stripe</a> (2011)</li>
	<li>
<a href="http://saasy.com/">SaaSy</a> (2011)</li>
	<li>
<a href="http://www.fusebill.com/">Fusebill</a> (2011)</li>
	<li>
<a href="http://recurly.com/">Recurly</a> (2010)</li>
	<li>
<a href="http://www.earlyimpact.com/subscriptionbridge/">SubscriptionBridge</a> (2010)</li>
	<li>
<a href="http://chargify.com/">Chargify</a> (2009)</li>
	<li>
<a href="https://cheddargetter.com/">CheddarGetter</a> (2009)</li>
	<li>
<a href="http://www.braintreepayments.com/">Braintree</a> (2007)</li>
	<li>
<a href="http://spreedly.com/">Spreedly</a> (2007)</li>
	<li>
<a href="http://www.zuora.com/">Zuora</a> (2007)</li>
	<li>
<a href="http://www.adyen.com/">Adyen</a> (2006)</li>
	<li>
<a href="http://www.vindicia.com/">Vindicia</a> (2003)</li>
	<li>
<a href="http://www.ariasystems.com/">Aria Systems</a> (2003)</li>
</ul><p>The list shows the year each service was founded. In general, since the market is highly competetive, the newer services are less expensive and offer better integration, interfaces, and features.</p>
<p>Several blog posts compare services and pricing:</p>
<ul>
<li>
<a href="http://blog.subscrea.com/recurring-billing/peeling-the-onion-called-recurring-billing-part-ii/">Peeling the onion called recurring billing</a> (July 2012)</li>
	<li>
<a href="http://expletiveinserted.com/2011/03/18/comparing-recurring-payment-solutions/">Comparing Recurring Payment Solutions</a> (March 2011)</li>
</ul><p>You can use a web-based calculator to compare pricing of some services:</p>
<ul>
<li><a href="http://www.billingsavvy.com/">BillingSavvy</a></li>
</ul><p>BillingSavvy shows Stripe is cheaper than Recurly for less than 600 subscribers. Over 600 subscribers, Recurly becomes cheaper. Stripe and Recurly are always cheaper than Chargify, CheddarGetter and Spreedly for $12/month subscriptions.</p>
<p>In addition to offering a price advantage for high-volume sites, Recurly is available to businesses located outside of the US and Canada. And Recurly claims to offer better features for customer retention. Unlike Stripe, for example, Recurly’s dunning managagement feature sends emails to the customer when the customer’s credit card expires to encourage continuing the subscription.</p>
<p>This tutorial shows to set up recurring billing using Recurly. Before you start, go to the <a href="http://recurly.com/">Recurly website</a> and set up an account.</p>
<h3>Merchant Account</h3>
<p>Your business will need a merchant account in order to accept credit card payments. Here’s an explanation from Phillip Parker of <a href="http://www.cardpaymentoptions.com/">CardPaymentOptions.com</a>: “A merchant account is a line of credit account that allows a business to accept card payments from its customers. Similar to how a checking account allows you to deposit another person’s check into your checking account, a merchant account allows you to accept a card payment from a customer. Unlike a checking account, a merchant account doesn’t hold money. Instead, a card payment passes through the merchant account and is deposited into a checking account after the funds have been cleared through the merchant account.”</p>
<p>Unlike Stripe, Recurly does not include a merchant account as part of the service. If your business is established and already taking credit card payments, you will already have a merchant account. If not, you will have to obtain a merchant account. If you have a U.S.-based business, Recurly will refer you to their partner, <a href="http://www.tsysmerchantsolutions.com/mark/index.html"><span class="caps">TSYS</span> Merchant Solutions</a>, one of the largest credit card processors in the U.S., and a salesperson will contact you to send you an application form. It takes a few days to get approval so get the process started early.</p>
<p>Pricing and contract terms for merchant accounts can be complicated, confusing, and often misleading. <a href="http://www.cardpaymentoptions.com/">CardPaymentOptions.com</a> offers an ebook and reviews of credit card processors to help you compare offers. I was pleased to see <span class="caps">TSYS</span> Merchant Solutions offers favorable terms for Recurly customers. Here are the terms I received from <span class="caps">TSYS</span> Merchant Solutions for the RailsApps merchant account:</p>
<ul>
<li>no cancellation fee</li>
	<li>month-to-month contract</li>
	<li>setup fee $0</li>
	<li>monthly minimum $0</li>
	<li>monthly maintenance fee $0</li>
	<li>annual fee $0</li>
	<li>monthly regulatory and compliance fee $5</li>
	<li>Visa/MC/Discover Interchange Plus rate .30%</li>
	<li>authorization fee $0.08</li>
	<li>batch fee $0</li>
	<li>monthly <span class="caps">PCI</span> compliance $6.50</li>
	<li>Amex rate 3.50%</li>
</ul><p>Add Recurly’s fees:</p>
<ul>
<li>1.25% + $0.10/transaction</li>
	<li>$69/monthly minimum</li>
</ul><p>And you can see a total for the merchant account and Recurly:</p>
<ul>
<li>1.55% + $0.18/transaction</li>
	<li>$11.50/month fees</li>
	<li>$69/monthly minimum</li>
</ul><p>Compare to Stripe:</p>
<ul>
<li>2.9% + $0.30/transaction</li>
	<li>no monthly minimum</li>
	<li>no merchant account needed</li>
</ul><p>For 600 users per month at $10 per transaction, Recurly/<span class="caps">TSYS</span> will cost $212 and Stripe will cost $354.</p>
<h3>Hosting</h3>
<p>For easy deployment, use a “platform as a service” provider such as:</p>
<ul>
<li><a href="http://www.heroku.com/">Heroku</a></li>
	<li><a href="http://www.cloudfoundry.com/">CloudFoundry</a></li>
	<li><a href="http://www.engineyard.com/">EngineYard</a></li>
	<li><a href="https://openshift.redhat.com/app/">OpenShift</a></li>
</ul><p>Instructions are provided for deployment to Heroku.</p>
<p>It’s common for technically skilled people to want to set up their own servers. Please, do yourself a favor, and unless system administration is your most dearly loved recreation, let the platform providers do it for you.</p>
<h3><span class="caps">SSL</span></h3>
<p>Visitors to your website will be sending credit card information from their browser to Recurly’s servers when they sign up for a subscription. The Recurly JavaScript library will open an <span class="caps">SSL</span> connection to Recurly’s servers when the form is submitted.</p>
<p>You can host your membership site without <span class="caps">SSL</span> and your users’ credit card numbers will be protected on the way to Recurly’s servers. However, your security-conscious visitors will be uneasy if they see that the web <span class="caps">URL</span> for your regsitration page begins with <code>http://</code> and not <code>https://</code> (indicating an <span class="caps">SSL</span> connection). For their peace of mind (and the higher conversion rate that comes with trust), you should host your website with an <span class="caps">SSL</span> connection. Additionally, as a general practice, it is wise to host any webapp that requires login over an <span class="caps">SSL</span> connection.</p>
<p>If you’re deploying with Heroku, you can access any Heroku app over <span class="caps">SSL</span> at <code>https://myapp.herokuapp.com/</code>. For your custom domain, Heroku offers the <a href="https://devcenter.heroku.com/articles/ssl-endpoint"><span class="caps">SSL</span> Endpoint add-on</a> for a fee of $20/month. You’ll need to <a href="https://devcenter.heroku.com/articles/ssl-certificate">purchase a signed certificate from a certificate provider</a> for an annual fee (typically $20 a year). Setting up an <span class="caps">SSL</span> certificate for a custom domain on Heroku can be a hassle but there’s a convenient alternative that is a better value. You can purchase <a href="http://cloudflare.com/">CloudFlare</a> for $20/month and get <span class="caps">SSL</span> without purchasing or installing an <span class="caps">SSL</span> certificate. CloudFlare is a content delivery network (<span class="caps">CDN</span>) and website optimizer; the $20/month <a href="http://blog.cloudflare.com/easiest-ssl-ever-now-included-automatically-w">CloudFlare Pro plan includes <span class="caps">SSL</span></a>. If you use Cloudflare in combination with Heroku hosting, you can use the Heroku piggyback <span class="caps">SSL</span> to encrypt the traffic between Heroku and Cloudflare, and your website visitors will connect to Cloudfare with their web browsers, providing a complete <span class="caps">SSL</span> connection through Cloudfare to Heroku with your custom domain. Not only do you get <span class="caps">SSL</span> for no more than you’d pay at Heroku to use an <span class="caps">SSL</span> certificate, but you get the Cloudfare <span class="caps">CDN</span> services as part of the bargain.</p>
<p>If you’re deploying on Heroku, you can wait until you’ve deployed to sign up for a Cloudfare account.</p>
<p>If you’re deploying elsewhere, do your research early to find out how to set up <span class="caps">SSL</span> and apply for an <span class="caps">SSL</span> certificate if necessary.</p>
<h3>Email Service Providers</h3>
<p>You’ll need infrastructure for three types of email:</p>
<ul>
<li>company email</li>
	<li>email sent from the app (“transactional email”)</li>
	<li>broadcast email for newsletters or announcements</li>
</ul><p>No single vendor is optimal for all three types of email; you likely will use several vendors. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a> for suggestions for various types of email service providers.</p>
<h3>Domain Registration</h3>
<p>You’ve likely already selected and registered a domain name. If not, you’ll need a domain before you start sending email messages from the application. If you’re disgusted by GoDaddy, consider <a href="http://www.namecheap.com/">NameCheap</a> and other popular alternatives.</p>
<h3>GitHub</h3>
<p>Get a <a href="https://github.com/signup/free">free GitHub account</a> if you don’t already have one. You’ll use <a href="http://git-scm.com/">git</a> for version control and you should get a GitHub account for remote backup and collaboration. See <a href="http://railsapps.github.com/rails-git.html">GitHub and Rails</a> if you need more information about working with git and GitHub for code source control.</p>
<h2>Getting Started</h2>
<h3>Is It for You?</h3>
<p>This tutorial is for experienced developers as well as startup founders or hobbyist coders who are new to Rails.</p>
<p>Experienced developers will find the <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/">complete application on GitHub</a>; this tutorial provides the detail and background to understand the implementation in depth. For Rails beginners, this tutorial describes each step that you must follow to create the application. Every step is documented concisely, so you can create this application without any additional knowledge. However, the tutorial assumes you’ve already been introduced to Rails, so if you are a beginner, you may be overwhelmed unless you’ve been introduced to Rails elsewhere. See resources for getting started with <a href="http://railsapps.github.com/rails.html">Rails</a>.</p>
<h3>Where to Start</h3>
<p>This is one in a series of Rails example apps and tutorials from the <a href="http://railsapps.github.com/">RailsApps Project</a>. See a list of similar <a href="http://railsapps.github.com/rails-examples-tutorials.html">Rails examples, tutorials, and starter apps</a>.</p>
<p>This application is based on two simpler example apps:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><p>The first example shows how to set up Devise for user authentication. It also shows how to set up the app to use RSpec and Cucumber for testing.</p>
<p>The second example shows how to set up Devise and add CanCan and Rolify to manage access to administrative pages. It also shows how to set up Twitter Bootstrap as a front-end framework for <span class="caps">CSS</span> styling.</p>
<p>You can use this tutorial without studying these example applications; if you find you are lost, it may be helpful to look at the two simpler examples.</p>
<p>If you want to use the MongoDB datastore instead of ActiveRecord and a <span class="caps">SQL</span> database, look at the  <a href="https://github.com/RailsApps/rails3-mongoid-devise">rails3-mongoid-devise</a> example.</p>
<p>You might also be interested in the <a href="https://github.com/RailsApps/rails-prelaunch-signup">rails-prelaunch-signup</a> example if you are planning prelaunch promotion. Use it to announce your plans and collect email addresses from visitors for future notification of the site’s launch.</p>
<h3>About the Tutorial</h3>
<p>Most of the tutorials from the RailsApps project take about an hour to complete. This tutorial is more complex; it will take you about three hours to build the complete app. (Is our estimate accurate? Please <a href="#comments">leave a comment</a> when you are done.)</p>
<p>If you find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/issues">GitHub issue</a>.</p>
<p>You’ll find a comments section at the end of the tutorial. I encourage you to offer feedback to improve this tutorial.</p>
<h3>Before You Start</h3>
<p>If you follow this tutorial closely, you’ll have a working application that closely matches the example app in this GitHub repository. The example app in the <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/">rails-recurly-subscription-saas</a> repository is your reference implementation. If you find problems with the app you build from this tutorial, download the example app (in Git speak, clone it) and use a file compare tool to identify differences that may be causing errors. On a Mac, <a href="http://stackoverflow.com/questions/187064/graphical-diff-for-mac-os-x">good file compare tools</a> are <a href="http://en.wikipedia.org/wiki/Apple_Developer_Tools#FileMerge">FileMerge</a>, <a href="http://sourcegear.com/diffmerge/">DiffMerge</a>, <a href="http://www.kaleidoscopeapp.com/">Kaleidoscope</a>, or Ian Baird’s <a href="http://www.changesapp.com/">Changes</a>.</p>
<p>If you find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/issues">GitHub issue</a>. It’s best to clone and check the example application from the GitHub repository before you report an issue, just to make sure the error isn’t a result of your own mistake.</p>
<p>The online edition of this tutorial contains a comments section at the end of the tutorial. I encourage you to offer feedback to improve this tutorial.</p>
<h3>Assumptions</h3>
<p>Before beginning this tutorial, you need to install</p>
<ul>
<li>The Ruby language (version 1.9.3)</li>
	<li>Rails 3.2</li>
</ul><p>Check that appropriate versions of Ruby and Rails are installed in your development environment:<br><code>$ ruby -v</code><br><code>$ rails -v</code></p>
<p>Be sure to read <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a> to make sure your development environment is set up properly.</p>
<p>I recommend using <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager to manage your Rails versions and create a dedicated gemset for each application you build.</p>
<h2>Create the Application</h2>
<p>You have several options for getting the code. You can <em>copy from the tutorial</em>, <em>fork</em>, <em>clone</em>, or <em>generate</em>.</p>
<p>If you want to add this code to an existing application, you can follow the tutorial and cut and paste the code into your existing application, resolving any conflicts as needed.</p>
<h3>Copy from the Tutorial</h3>
<p>To create the application, you can cut and paste the code from the tutorial into your own files. It’s a bit tedious and error-prone but you’ll have a good opportunity to examine the code closely. Before you start, the tutorial will ask you to use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate a starter app to save some steps. Then you can follow the tutorial step-by-step to build the complete application.</p>
<h3>Other Options</h3>
<h4>Fork</h4>
<p>If you’d like to add features (or bug fixes) to improve the example application, you can fork the GitHub repo and <a href="http://help.github.com/send-pull-requests/">make pull requests</a>. Your code contributions are welcome!</p>
<h4>Clone</h4>
<p>If you want to copy and customize the app with changes that are only useful for your own project, you can download or clone the GitHub repo. You’ll need to search-and-replace the project name throughout the application. You probably should generate the app instead (see below). To clone:</p>
<pre>
$ git clone git://github.com/RailsApps/rails-recurly-subscription-saas.git
</pre>

<p>You’ll need <a href="http://git-scm.com/">git</a> on your machine. See <a href="http://railsapps.github.com/rails-git.html">Rails and Git</a>.</p>
<h4>Generate</h4>
<p>If you wish to skip the tutorial and build the application immediately, use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate the complete example app. You’ll be able to give it your own project name when you generate the app. Generating the application gives you additional options.</p>
<p>To build the complete example application immediately, see the instructions in the <span class="caps">README</span> for the <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/">rails-recurly-subscription-saas</a> example application.</p>
<h3>Building from Scratch</h3>
<p>Before you write any code, you’ll start by generating a starter app using the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool.</p>
<p>If you’ve developed other applications in Rails, you’ll know that the <code>rails new</code> command creates a basic Rails application. Here we’ll use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool (“like the ‘rails new’ command on steroids”) to create a starter app. The starter app saves us some steps. Devise will be installed with Cancan for authorization. Twitter Bootstrap will be set up as a front end for <span class="caps">CSS</span> styling. If you want to learn how the starter app is put together, see the <a href="http://railsapps.github.com/tutorial-rails-bootstrap-devise-cancan.html">rails3-bootstrap-devise-cancan</a> tutorial.</p>
<p>For the starter app we need, use the command:</p>
<pre>
$ rails new rails-recurly-subscription-saas -m https://raw.github.com/RailsApps/rails-composer/master/composer.rb -T
</pre>
<p>Use the <code>-T</code> flag to skip Test::Unit files since we’ll be using RSpec.</p>
<p>The <code>$</code> character indicates a shell prompt; don’t include it when you run the command.</p>
<p>This creates a new Rails app named <code>rails-recurly-subscription-saas</code> on your computer. You can use a different name if you wish.</p>
<p>You’ll see a prompt:</p>
<pre>
question  Install an example application?
      1)  I want to build my own application
      2)  rails-stripe-membership-saas
      3)  rails-recurly-subscription-saas
      4)  rails-prelaunch-signup
      5)  rails3-bootstrap-devise-cancan
      6)  rails3-devise-rspec-cucumber
      7)  rails3-mongoid-devise
      8)  rails3-mongoid-omniauth
      9)  rails3-subdomains
</pre>
<p>Choose <strong>rails3-bootstrap-devise-cancan</strong>. The Rails Composer tool may give you other options (other choices may have been added since this tutorial was written). <strong>Note:</strong> Don’t choose “rails-recurly-subscription-saas” (unless you want to skip the tutorial).</p>
<p>The application generator template will ask you for additional preferences:</p>
<pre>
 question  Web server for development?
       1)  WEBrick (default)
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Web server for production?
       1)  Same as development
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Template engine?
       1)  ERB
       2)  Haml
       3)  Slim
   extras  Set a robots.txt file to ban spiders? (y/n)
   extras  Create a project-specific rvm gemset and .rvmrc? (y/n)
   extras  Create a GitHub repository? (y/n)
</pre>
<h4>Web Servers</h4>
<p>Use the default WEBrick server for convenience. If you plan to deploy to Heroku, select “thin” as your production webserver.</p>
<h4>Template Engine</h4>
<p>The example application uses the default “<span class="caps">ERB</span>” Rails template engine. Optionally, you can use another template engine, such as Haml or Slim. See instructions for <a href="http://railsapps.github.com/rails-haml.html">Haml and Rails</a>.</p>
<h4>Other Choices</h4>
<p>Set a robots.txt file to ban spiders if you want to keep your new site out of Google search results.</p>
<p>It is a good idea to use <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager, and create a project-specific rvm gemset and .rvmrc file (not available on Windows). See <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a>.</p>
<p>If you choose to create a GitHub repository, the generator will prompt you for a GitHub username and password.</p>
<h4>Troubleshooting</h4>
<p>If you get an error “OpenSSL certificate verify failed” or “Gem::RemoteFetcher::FetchError: SSL_connect” see the article <a href="http://railsapps.github.com/openssl-certificate-verify-failed.html">OpenSSL errors and Rails</a>.</p>
<p>If you get an error like this:</p>
<pre>
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
    composer  Running 'after bundler' callbacks.
The template [...] could not be loaded.
Error: You have already activated ..., but your Gemfile requires .... 
Using bundle exec may solve this.
</pre>
<p>It’s due to conflicting gem versions. See the article <a href="http://railsapps.github.com/rails-error-you-have-already-activated.html">Rails Error: “You have already activated (…)”</a>.</p>
<h3>Begin Development</h3>
<p>After you create the application, switch to its folder to continue work directly in the application:</p>
<p><code>$ cd rails-recurly-subscription-saas</code></p>
<h3>Replace the READMEs</h3>
<p>Please edit the <span class="caps">README</span> files to add a description of the app and your contact info. Changing the <span class="caps">README</span> is important if your app will be publicly visible on GitHub. Otherwise, people will think I am the author of your app. If you like, add an acknowledgment and a link to the <a href="http://railsapps.github.com/">RailsApps project</a>.</p>
<h3>Set Up Source Control (Git)</h3>
<p>When you generate the starter app, the template sets up a source control repository and makes an initial commit of the code.</p>
<p>At your request, the template will also create a GitHub repository for your project.</p>
<p>See detailed instructions for <a href="http://railsapps.github.com/rails-git.html">Git and Rails</a>.</p>
<p>Git has already been initialized by the application template script. If you’ve selected the GitHub option, the template commits your code to your GitHub repository.</p>
<h3>Set Up Gems</h3>
<p>The Rails Composer program sets up your Gemfile and (if you are using rvm) creates a project-specific gemset.</p>
<p>Open your <strong>Gemfile</strong> and you should see the following. Gem version numbers may differ:</p>
<pre>
source 'https://rubygems.org'
gem 'rails', '3.2.9'
gem 'sqlite3'
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'
  gem 'uglifier', '&gt;= 1.0.3'
end
gem 'jquery-rails'
gem "rspec-rails", "&gt;= 2.11.0", :group =&gt; [:development, :test]
gem "email_spec", "&gt;= 1.2.1", :group =&gt; :test
gem "cucumber-rails", "&gt;= 1.3.0", :group =&gt; :test, :require =&gt; false
gem "database_cleaner", "&gt;= 0.9.1", :group =&gt; :test
gem "launchy", "&gt;= 2.1.2", :group =&gt; :test
gem "capybara", "&gt;= 1.1.2", :group =&gt; :test
gem "factory_girl_rails", "&gt;= 4.1.0", :group =&gt; [:development, :test]
gem "bootstrap-sass", "&gt;= 2.1.0.0"
gem "devise", "&gt;= 2.1.2"
gem "cancan", "&gt;= 1.6.8"
gem "rolify", "&gt;= 3.2.0"
gem "simple_form", "&gt;= 2.0.4"
gem "quiet_assets", "&gt;= 1.0.1", :group =&gt; :development
gem "better_errors", "&gt;= 0.0.8", :group =&gt; :development
gem "binding_of_caller", "&gt;= 0.6.8", :group =&gt; :development
</pre>
<p>Add the following gems which will be needed for the rails-recurly-subscription-saas application:</p>
<pre>
gem 'recurly', '&gt;= 2.1.5'
gem 'nokogiri', '&gt;= 1.5.5'
gem 'countries', '&gt;= 0.8.4'
gem 'httpi', '&gt;= 1.1.1'
gem 'httpclient', '&gt;= 2.3.0.1'
</pre>
<p>Check for the <a href="http://rubygems.org/gems/rails">current version of Rails</a> and replace <code>gem 'rails', '3.2.9'</code> accordingly.</p>
<p><em>Note:</em> Rails Composer templates are created by the <a href="https://github.com/RailsApps/rails_apps_composer">Rails Apps Composer Gem</a>. For that reason, groups such as <code>:development</code> or <code>:test</code> are specified inline. You can reformat the Gemfile to organize groups in an eye-pleasing block style. The functionality is the same.</p>
<h3>Install the Required Gems</h3>
<p>When you add a new gem to the Gemfile, you should run the <code>bundle install</code> command to install the required gems on your computer. Run:</p>
<pre>
bundle install
</pre>
<p>You can check which gems are installed on your computer with:</p>
<pre>
$ gem list
</pre>
<p>Keep in mind that you have installed these gems locally. When you deploy the app to another server, the same gems (and versions) must be available.</p>
<h3>Test the App</h3>
<p>You can check that your app runs properly by entering the command</p>
<pre>
$ rails server
</pre>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>. You should see the Rails default information page.</p>
<p>Stop the server with Control-C.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add gems"
</pre>
<h2>Test-Driven Development</h2>
<p>This example application uses Cucumber for integration testing and RSpec for unit testing.</p>
<p>Testing is at the center of any robust software development process. Integration tests determine whether the application’s features work as expected, testing the application from the point of view of the user. Unit tests confirm that small, discrete portions of the application continue working as developers add features and refactor code. RSpec is a popular choice for unit testing. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up RSpec and provides example specs for use with Devise. Cucumber is a popular choice for integration testing and behavior driven development. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up Cucumber and provides example scenarios for use with Devise.</p>
<p>To learn more about using RSpec, refer to <a href="http://www.pragprog.com/titles/achbd/the-rspec-book">The RSpec Book</a>.</p>
<p>To learn more about using Cucumber, refer to <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a> or the free introduction to Cucumber, <a href="http://cuke4ninja.com/">The Secret Ninja Cucumber Scrolls</a>.</p>
<p>This tutorial assumes you’ve learned to write tests elsewhere (see a list of <a href="http://railsapps.github.com/rails.html">recommended resources for Rails</a>). I won’t spend time showing you how to write tests but you can use tests to make sure the application works as expected.</p>
<h3>Tests Installed by Rails Composer</h3>
<p>The Rails Composer tool creates a starter app that is set up for RSpec and Cucumber test frameworks.</p>
<p>The starter app includes RSpec and Cucumber test suites designed for the features of the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application.</p>
<h4>Running RSpec Tests</h4>
<p>The starter app script sets up RSpec for unit testing. You should be able to run <code>rake spec</code> to run all specs provided with the example app after the database is set up.</p>
<h4>Running Cucumber Tests</h4>
<p>The starter app script sets up Cucumber for specifications and acceptance testing.</p>
<p>You should be able to run <code>rake cucumber</code>, or more simply, <code>cucumber</code>, to run the Cucumber scenarios and steps provided with the example app after the database is set up. You can run a single Cucumber feature with a command such as:</p>
<pre>
$ cucumber features/visitors/request_invitation.feature
</pre>
<p>If you’ve used Cucumber, you may know that you need to add <code>--require features</code> to run a single Cucumber feature. Here it is not necessary to do so; the starter app script sets up the <strong>config/cucumber.yml</strong> file so it is not necessary to add <code>--require features</code>.</p>
<h3>Installing Tests from the Example Application</h3>
<p>The starter app only installs tests designed for the features of the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application. However, a full suite of tests for the <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/">rails-recurly-subscription-saas</a> example application are available in the GitHub repository.</p>
<p>You can copy the RSpec unit tests and Cucumber integration tests from the GitHub repository. Replace both the <strong>spec</strong> and <strong>features</strong> directories entirely. Copying all the files will include necessary configuration and helper files.</p>
<p>Run <code>rake -T</code> to check that rake tasks for RSpec and Cucumber are available. You won’t be able to run <code>rake spec</code> or <code>rake cucumber</code> until the database is set up.</p>
<h2>Configuration</h2>
<h3>Configuration File</h3>
<p>See the article <a href="http://railsapps.github.com/rails-environment-variables.html">Rails Environment Variables</a> for more information.</p>
<p>The application uses the <a href="https://github.com/laserlemon/figaro">figaro gem</a> to set environment variables. The starter app sets up the figaro gem and generates a <strong>config/application.yml</strong> file and lists it in your <strong>.gitignore</strong> file.</p>
<p>Credentials for your administrator account and email account are set in the <strong>config/application.yml</strong> file. The <strong>.gitignore</strong> file prevents the <strong>config/application.yml</strong> file from being saved in the git repository so your credentials are kept private.</p>
<p>Modify the file <strong>config/application.yml</strong>:</p>
<pre>
# Add account credentials and API keys here.
# See http://railsapps.github.com/rails-environment-variables.html
# This file should be listed in .gitignore to keep your settings secret!
# Each entry sets a local environment variable and overrides ENV variables in the Unix shell.
# For example, setting:
# GMAIL_USERNAME: Your_Gmail_Username
# makes 'Your_Gmail_Username' available as ENV["GMAIL_USERNAME"]
# Add application configuration variables here, as shown below.
#
GMAIL_USERNAME: Your_Username
GMAIL_PASSWORD: Your_Password
ADMIN_FIRST_NAME: First
ADMIN_LAST_NAME: User
ADMIN_EMAIL: user@example.com
ADMIN_PASSWORD: please
ROLES: [admin, silver, gold, platinum]
RECURLY_API_KEY: = recurly_api_key
RECURLY_JS_PRIVATE_KEY: = recurly_js_private_key
RECURLY_SUBDOMAIN: myapp
</pre>
<p>Set the user name and password needed for the application to send email.</p>
<p>If you wish, set your name, email address, and password for an administrator’s account. If you prefer, you can use the default to sign in to the application and edit the account after deployment. It is always a good idea to change the administrator’s password after the application is deployed.</p>
<p>The roles you specify in the configuration file are the subscription plans that will be available to the application’s users. You will need an “admin” role. Keep the “silver”, “gold”, and “platinum” roles while you are testing the application. You can change these roles later, after you familiarize yourself with the application and begin to customize it for your own needs.</p>
<p>The Recurly gem requires an <span class="caps">API</span> key to operate. We’ll also need to supply a private key so the Recurly gem can generate a cryptographic signature. You can find both keys on your Recurly account profile under “<span class="caps">API</span> Credentials”.</p>
<p>We’ll also set a <code>RECURLY_SUBDOMAIN</code> environment variable that we’ll use in the JavaScript code that initiates the Recurly transaction. Recurly creates a customer-facing website and <span class="caps">API</span> interface with a subdomain on the Recurly website. The <span class="caps">URL</span> will look like this: <code>https://myapp.recurly.com/</code> where “myapp” is the name of your company or service. You’ll use the subdomain “myapp” to form the <span class="caps">URL</span> that makes requests to the Recurly <span class="caps">API</span> interface. The Recurly subdomain is listed on your Recurly account profile.</p>
<p>All configuration values in the <strong>config/application.yml</strong> file are available anywhere in the application as environment variables. For example, <code>ENV["GMAIL_USERNAME"]</code> will return the string “Your_Username”.</p>
<p>If you prefer, you can delete the <strong>config/application.yml</strong> file and set each value as an environment variable in the Unix shell.</p>
<h3>Configure Email</h3>
<p>The starter app script sets up a default email configuration. You must configure the application for your email account. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a>.</p>
<p>The starter app has already configured ActionMailer but you must set your email account details.</p>
<p>Replace <code>example.com</code> in the <strong>config/environments/production.rb</strong> file:</p>
<pre>
config.action_mailer.default_url_options = { :host =&gt; 'example.com' }
# ActionMailer Config
# Setup for production - deliveries, no errors raised
config.action_mailer.delivery_method = :smtp
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = false
config.action_mailer.default :charset =&gt; "utf-8"
</pre>
<p>The example application will deliver email in production. Email messages are visible in the log file so there is no need to send email in development.</p>
<p>In production, you should use an email service provider such as <a href="http://mandrill.com/">Mandrill</a> to increase deliverability for email messages from your app.</p>
<p>Use Gmail for experimenting, if you want to keep things simple.</p>
<p>The file <strong>config/environments/production.rb</strong> is set to use:</p>
<pre>
config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: "example.com",
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
</pre>
<p>You can replace <code>ENV["GMAIL_USERNAME"]</code> and <code>ENV["GMAIL_PASSWORD"]</code> with your Gmail username and password. However, committing the file to a public GitHub repository will expose your secret password. Instead, use local environment variables from the <strong>config/application.yml</strong> file to keep email account passwords secret.</p>
<h3>Configure Devise for Email</h3>
<p>Complete your email configuration by modifying</p>
<p><strong>config/initializers/devise.rb</strong></p>
<p>and setting the <code>config.mailer_sender</code> option for the return email address for messages that Devise sends from the application.</p>
<h3>Recurly Initializer</h3>
<p>You’ve set the Recurly <span class="caps">API</span> key and private key in your <strong>config/application.yml</strong> file. The file is there for security so your credentials won’t be exposed publicly on a GitHub repo.</p>
<p>We’ll use an initializer file to set the data.</p>
<p>Create a file <strong>config/initializers/recurly.rb</strong>:</p>
<pre>
Recurly.api_key = ENV['RECURLY_API_KEY']
Recurly.js.private_key = ENV['RECURLY_JS_PRIVATE_KEY']
RECURLY_SUBDOMAIN = ENV['RECURLY_SUBDOMAIN']
# Recurly.default_currency = 'USD'
</pre>
<p>If you’re not operating with US dollars as your currency, you can change the default in the initializer file.</p>
<p>We are using local environment variables from the <strong>config/application.yml</strong> file. The <code>Recurly.api_key</code> and <code>Recurly.js.private_key</code> values should be kept secret so no other developer can use your Recurly account. The <code>RECURLY_SUBDOMAIN</code> constant does not need to be kept secret but we set it in the <strong>config/application.yml</strong> file for convenience, so all your configuration settings are in one location.</p>
<p>Remember you’ll need to restart your server before testing because you’ve made a change to configuration files.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "configure"
</pre>
<h2>Layout and Stylesheets</h2>
<p>Rails will use the layout defined in the file <strong>app/views/layouts/application.html.erb</strong> as a default for rendering any page. See the article <a href="http://railsapps.github.com/rails-default-application-layout.html">Rails Default Application Layout</a> for an explanation of each of the elements in the application layout.</p>
<p>The starter app adds navigation links, includes flash messages for errors and notifications, and applies <span class="caps">CSS</span> styling using Twitter Bootstrap.</p>
<p>The file <strong>app/views/layouts/_navigation.html.erb</strong> contains navigation links.</p>
<p>The file <strong>app/views/layouts/_messages.html.erb</strong> contains flash messages.</p>
<p>This tutorial shows code using <span class="caps">ERB</span>, the default Rails templating language. If you prefer, you can generate the starter app with Haml instead of <span class="caps">ERB</span>. Then convert the <span class="caps">ERB</span> in the tutorial to Haml. See instructions for <a href="http://railsapps.github.com/rails-haml.html">Haml and Rails</a>.</p>
<h2>Authentication</h2>
<p>This application uses <a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication. Devise provides a system to securely identify users, making sure the user is really who he represents himself to be. Devise provides everything needed to implement user registration with log in and log out.</p>
<p>The starter app script sets up Devise:</p>
<ul>
<li>adds the Devise gem to the Gemfile</li>
	<li>runs <code>$ rails generate devise:install</code>
</li>
	<li>uses Devise to generate a User model and database migration</li>
	<li>prevents logging of passwords</li>
	<li>adds a sign-in form that uses the SimpleForm and Twitter Bootstrap</li>
</ul><p>For details about how Devise is used in the starter application, see the tutorials:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>Authorization</h2>
<p>This application uses <a href="https://github.com/ryanb/cancan">CanCan</a> for authorization, to restrict access to pages that should only be viewed by an authorized user. CanCan offers an architecture that centralizes all authorization rules (permissions or “abilities”) in a single location, the CanCan <code>Ability</code> class. CanCan provides a mechanism for limiting access at the level of controller and controller method and expects you to set permissions based on user attributes you define. This application uses Florent Monbillard’s <a href="https://github.com/EppO/rolify">Rolify</a> gem to create a Role model and add methods to a User model that are used to set CanCan permissions.</p>
<p>The starter app script sets up CanCan and Rolify:</p>
<ul>
<li>adds the CanCan and Rolify gems to the Gemfile</li>
	<li>creates the CanCan <code>Ability</code> class</li>
	<li>configures CanCan exception handling</li>
	<li>sets up User roles with Rolify</li>
</ul><p>For details about how authorization is implemented in the starter application, see the tutorial:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>User Management</h2>
<p>By default, Devise uses an email address to identify users. The starter application adds a “name” attribute as well.</p>
<p>Devise provides all the functionality for a user to log in and view and edit the user’s profile. The user’s profile only includes an email address, a name, and a password. You’ll likely customize the User model and user pages for your own application.</p>
<p>The starter application:</p>
<ul>
<li>adds a name attribute to the User model</li>
	<li>limits mass-assignment operations with the <code>attr_accessible</code> method</li>
	<li>provides custom views for registering and editing users</li>
</ul><p>For details about how user management is set up in the starter application, see the tutorials:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h3>Add Fields for Recurly</h3>
<p>Recurly customer accounts require both a first name and last name.</p>
<p>We’ll also need a customer id that will be used to match our application users with Recurly customer accounts.</p>
<p>We’ll change our User model and database schema accordingly.</p>
<h3>Migration for the User Model</h3>
<p>Create a database migration with this command:</p>
<pre>
$ rails generate migration ChangesForRecurlyToUsers
</pre>
<p>Modify the resulting file <strong>db/migrate/xxxxxxx__changes_for_recurly_to_users.rb</strong>:</p>
<pre>
class ChangesForRecurlyToUsers &lt; ActiveRecord::Migration
  def change
    change_table :users do |t|
      t.rename :name, :first_name
      t.string :last_name
      t.string :customer_id
    end
  end
end
</pre>
<p>After you’ve created the migration, update the database:</p>
<pre>
$ rake db:migrate
</pre>
<p>Now we’ll modify the User model.</p>
<h3>Modify the User Model</h3>
<p>We’ll add new attributes to the User model to accommodate Recurly billing.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :customer_id

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end
  
end
</pre>
<p>First we remove the <code>attr_accessible :role_ids, :as =&gt; :admin</code> statement. This statement gives the administrator the power to override the mass assignment protection for the role attribute. The statement is no longer necessary because we will add a method that allows both the user and an administrator to reset the role.</p>
<p>We add <code>first_name</code>, <code>last_name</code>, and <code>customer_id</code> to the <code>attr_accessible</code> method so we can set these attributes from our registration form.</p>
<p>We’ve also defined a method that concatenates the <code>first_name</code> and <code>last_name</code> to return a full name.</p>
<p>With these changes to our User model, we are ready to seed the database.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "update user model"
</pre>
<h2>Initial Data</h2>
<h3>Set Up a Database Seed File</h3>
<p>You’ll want to set up default users so you can test the application. We’ll add three users with different subscription plans.</p>
<p>The file <strong>db/seeds.rb</strong> already contains:</p>
<pre>
puts 'ROLES'
YAML.load(ENV['ROLES']).each do |role|
  Role.find_or_create_by_name({ :name =&gt; role }, :without_protection =&gt; true)
  puts 'role: ' &lt;&lt; role
end
puts 'DEFAULT USERS'
user = User.find_or_create_by_email :name =&gt; ENV['ADMIN_NAME'].dup, :email =&gt; ENV['ADMIN_EMAIL'].dup, :password =&gt; ENV['ADMIN_PASSWORD'].dup, :password_confirmation =&gt; ENV['ADMIN_PASSWORD'].dup
puts 'user: ' &lt;&lt; user.name
user.add_role :admin
</pre>
<p>Replace <strong>db/seeds.rb</strong> with:</p>
<pre>
puts 'ROLES'
YAML.load(ENV['ROLES']).each do |role|
  Role.find_or_create_by_name({ :name =&gt; role }, :without_protection =&gt; true)
  puts 'role: ' &lt;&lt; role
end
puts 'DEFAULT USERS'
user = User.find_or_create_by_email :first_name =&gt; ENV['ADMIN_FIRST_NAME'].dup, :last_name =&gt; ENV['ADMIN_LAST_NAME'].dup, :email =&gt; ENV['ADMIN_EMAIL'].dup, :password =&gt; ENV['ADMIN_PASSWORD'].dup, :password_confirmation =&gt; ENV['ADMIN_PASSWORD'].dup
puts 'user: ' &lt;&lt; user.name
user.add_role :admin
user2 = User.find_or_create_by_email :first_name =&gt; 'Silver', :last_name =&gt; 'User', :email =&gt; 'user2@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user2.add_role :silver
user3 = User.find_or_create_by_email :first_name =&gt; 'Gold', :last_name =&gt; 'User', :email =&gt; 'user3@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user3.add_role :gold
user4 = User.find_or_create_by_email :first_name =&gt; 'Platinum', :last_name =&gt; 'User', :email =&gt; 'user4@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user4.add_role :platinum
puts "users: #{user2.name}, #{user3.name}, #{user4.name}"
</pre>
<p>The <strong>db/seeds.rb</strong> file reads a list of roles from the <strong>config/application.yml</strong> file and adds the roles to the database. In fact, any new role can be added to the roles datatable with a statement such <code>user.add_role :superhero</code>. Setting the roles in the <strong>db/seeds.rb</strong> file simply makes sure each role is listed and available should a user wish to change roles.</p>
<p>Next we add an administrator and three sample users. Our User model now has separate first and last names to accommodate Recurly’s customer schema.</p>
<p>We’ve added a user with an administrator role using vales from the <strong>config/application.yml</strong> file. You can log in with this account for access as an administrator.</p>
<p>You can change the administrator name, email, and password in this file but it is better to make the changes in the <strong>config/application.yml</strong> file to keep the credentials private. If you decide to include your private password in the <strong>db/seeds.rb</strong> file, be sure to add the filename to your <strong>.gitignore</strong> file so that your password doesn’t become available in your public GitHub repository.</p>
<p>Note that it’s not necessary to personalize the <strong>db/seeds.rb</strong> file before you deploy your app. You can deploy the app with an example user and then use the application’s “Edit Account” feature to change name, email address, and password after you log in. Use this feature to log in as an administrator and change the user name and password to your own.</p>
<p>We’ve added three users and assigned “silver,” “gold,” and “platinum” roles corresponding to a tiered subscription plan.</p>
<h3>Using “example.com” Email Addresses</h3>
<p>We want the application to handle the administrator’s account and any “example.com” email addresses as a special case. Users with an “example.com” domain will not be added to Recurly as subscribers; they will only be added to the application database. This makes it possible to run <code>rake db:seed</code> to add the administrator and set up sample users for development and testing.</p>
<p>Later we’ll add two statements in an <code>update_recurly</code> method in the <strong>app/models/user.rb</strong> file implement the special case so that the Recurly server is not contacted:</p>
<pre>
def update_recurly
  return if email.include?(ENV['ADMIN_EMAIL'])
  return if email.include?('@example.com') and not Rails.env.production?
  .
  .
  .
end
</pre>
<p>As you can see from the code, the “example.com” email addresses will not be special cased in production. That means <code>rake db:seed</code> will fail with errors if you attempt to run it after deployment. You should remove the sample users (but not the administrator) from the <strong>db/seeds.rb</strong> file before deploying to production. See the section “Customize, Test, and Deploy” for advice about deploying to Heroku.</p>
<h3>Seed the Database</h3>
<p>The starter app script has already set up the database and added the default user by running:</p>
<pre>
$ rake db:migrate
$ rake db:seed
</pre>
<p>We’ll need to reset the database because we’ve added new users:</p>
<pre>
$ rake db:reset
</pre>
<p>You can run <code>$ rake db:reset</code> whenever you need to recreate the database.</p>
<p>You’ll also need to set up the database for testing:</p>
<pre>
$ rake db:test:prepare
</pre>
<p>If you’re not using <a href="https://rvm.io/">rvm</a>, you should preface each rake command with <code>bundle exec</code>. You don’t need to use <code>bundle exec</code> if you are using rvm version 1.11.0 or newer.</p>
<h3>Commit to Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "initial data"
</pre>
<h3>Test the Starter App</h3>
<p>At this point, the app is almost identical to the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> starter app.</p>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>. You should see the default users listed on the home page. When you click on a user’s name, you should be required to log in before seeing the user’s detail page.</p>
<p>If you sign in as the first user, you will have administrative privileges. You’ll see an “Admin” link in the navigation bar. Clicking the “Admin” link will display the administrative dashboard. Each user will be listed with buttons to “Change role” or “Delete user.”</p>
<p>Stop the server with Control-C.</p>
<h4>When to Restart</h4>
<p>If you install new gems, you’ll have to restart the server to see any changes. The same is true for changes to configuration files in the config folder. This can be confusing to new Rails developers because you can change files in the app folders without restarting the server. As a rule, remember to restart the server when you add gems, change routes, or change anything in the config folder; leave the server running whn you change models, controllers, views or anything else in app folder.</p>
<h2>Home Page</h2>
<h3>Replace the Home Page</h3>
<p>If you’ve tested the example app, you’ve seen that any user who logs in will see a list of all the users on the home page. That’s fine for an example app but it’s not what we want for a subscription site.</p>
<h3>Home Page with Subscription Plans</h3>
<p>We’ll put our subscription offer and pricing plan on the home page. For this tutorial, it’s simplest to show the offer and prices right on the home page. For a real application, you might describe your offer on the home page and show pricing on a separate page.</p>
<p>Replace the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_silver_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_gold_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_platinum_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We apply <span class="caps">CSS</span> classes from Twitter Bootstrap to style the page. We’ll create a few additional <span class="caps">CSS</span> classes in the next step.</p>
<p>The page contains a “hero unit” for your key marketing message plus three boxes describing subscription plans.</p>
<p>Each box contains a link to a content page. The content pages don’t yet exist; we’ll need to create a Content controller, routes, and views to implement the content pages. Later, we’ll change the links to open a subsciption purchase page instead of a content page.</p>
<h3>
<span class="caps">CSS</span> for Subscription Plans</h3>
<p>We’ll provide some rudimentary <span class="caps">CSS</span> rules to style the home page. We’re using Twitter Bootstrap so we’ll get an attractive design with only a few <span class="caps">CSS</span> rules.</p>
<p>First, modify the <strong>app/assets/stylesheets/application.css.scss</strong> file to remove the following <span class="caps">CSS</span> rules. These rules were useful for the starter app but will not be used in our application:</p>
<pre>
.content {
  background-color: #eee;
  padding: 20px;
  margin: 0 -20px; /* negative indent the amount of the padding to maintain the grid system */
  -webkit-border-radius: 0 0 6px 6px;
  -moz-border-radius: 0 0 6px 6px;
  border-radius: 0 0 6px 6px;
  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  -moz-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  box-shadow: 0 1px 2px rgba(0,0,0,.15);
}
</pre>
<p>Next we’ll add <span class="caps">CSS</span> assets to style the home page.</p>
<p>Create a file <strong>app/assets/stylesheets/pricing.css.scss</strong>:</p>
<pre>
.plans{
  text-align: center;
}
.featured{
  -webkit-transform:scale(1.15); 
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.67);
}
.plan{
  background-color: #111575;
}
.plan.featured-plan{
  background-color: #CCAB00;
}
.plan h2{
  line-height: 100px;
  color: #fff;
}
</pre>
<p>This stylesheet gets added automatically to the asset pipeline because any files in the same folder as the <strong>app/assets/stylesheets/application.css.scss</strong> file are added by the <code>*= require_tree .</code> statement.</p>
<p>This <span class="caps">CSS</span> will provide the design elements that are commonly seen on a pricing page: boxes for each plan with an enlarged box for a “featured plan.”</p>
<p>The design is adequate for our tutorial but you may want to improve it to be more effective. If you’re not a designer, you may want to look at the Twitter Bootstrap themes available in the <a href="https://wrapbootstrap.com/">WrapBootstrap</a> marketplace. The theme for <a href="https://wrapbootstrap.com/theme/css3-pricing-tables-WB00H9006">CSS3 Pricing Tables</a> is particularly interesting. It is similar to our home page but adds animated effects. The theme only costs $6 and you can easily integrate it into our application by copying the contents of the designer’s <strong>css/custom.css</strong> file into our <strong>app/assets/stylesheets/pricing.css.scss</strong> file and replacing styles in our <strong>app/views/home/index.html.erb</strong> file.</p>
<h3>Modify the Home Controller</h3>
<p>Modify the file <strong>app/controllers/home_controller.rb</strong> to remove the <code>index</code> method:</p>
<pre>
class HomeController &lt; ApplicationController
end
</pre>
<h3>Commit to Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "home page update"
</pre>
<h2>Administrative Page</h2>
<p>This application provides the <strong>Users#index</strong> page as an administrative dashboard. The CanCan authorization system restricts access to this page to only users in the “admin” role.</p>
<p>The starter application sets up the administrative page:</p>
<ul>
<li>lists users and shows the date each registered</li>
	<li>displays email addresses and roles</li>
	<li>provides buttons to change roles and delete users</li>
</ul><p>For details about how the administrative page is set up by the starter application, see the tutorial:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>Content Pages</h2>
<p>This application can be used for a Software-as-a-Service (SaaS) website or it can be used to limit access to pages containing content such as articles, photos, or video. For purposes of demonstration, we’ll set up the site so a membership is required to view some placeholder content.</p>
<p>Let’s add pages for our placeholder content.</p>
<p>First let’s consider a git workflow for adding a new feature.</p>
<h3>Git Workflow</h3>
<p>When you are using git for version control, you can commit every time you save a file, even for the tiniest typo fixes. If only you will ever see your git commits, no one will care. But if you are working on a team, either commercially or as part of an open source project, you will drive your fellow programmers crazy if they try to follow your work and see such “granular” commits. Instead, get in the habit of creating a git branch each time you begin work to implement a feature. When your new feature is complete, merge the branch and “squash” the commits so your comrades see just one commit for the entire feature.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b content-pages
</pre>
<p>The command creates a new branch named “content-pages” and switches to it, analogous to copying all your files to a new directory and moving to work in the new directory (though that is not really what happens with git).</p>
<h3>Create the Content Controller and Views</h3>
<p>Use the <code>rails generate</code> command to create a controller and associated views:</p>
<pre>
$ rails generate controller content silver gold platinum --skip-stylesheets --skip-javascripts
</pre>
<p>We’ve named the controller the “ContentController.” The default route will put our content pages in an apparent “content” directory with the <span class="caps">URL</span> path <a href="http://localhost:3000/content/">http://localhost:3000/content/</a>. You could give the controller another name if you want a different <span class="caps">URL</span> path but it’s easier to keep the same controller name and change the path in the <strong>config/routes.rb</strong> file (described below).</p>
<p>We’ve asked for three views, corresponding to the three subscription plans we’ll offer. We’ll use <code>--skip-stylesheets --skip-javascripts</code> to avoid cluttering our application with stylesheet and JavaScript files we don’t need.</p>
<p>The Rails generator will create these files for you:</p>
<pre>
app/controllers/content_controller.rb
app/helpers/content_helper.rb
app/views/content/gold.html.erb
app/views/content/platinum.html.erb
app/views/content/silver.html.erb
spec/controllers/content_controller_spec.rb
</pre>
<p>It also modifies the <strong>config/routes.rb</strong> file to add three routes:</p>
<pre>
get "content/silver"
get "content/gold"
get "content/platinum"
</pre>
<p>If you want a different <span class="caps">URL</span> path, you could specify a different path like this: <code>get "articles/silver" =&gt; "content#silver", :as =&gt; :content_silver</code>. Visitors will see a <span class="caps">URL</span> path <a href="http://localhost:3000/articles/silver">http://localhost:3000/articles/silver</a> but you won’t need to make any other changes to the application. We won’t do this; we’ll just use the supplied path.</p>
<p>If you look at <strong>app/controllers/content_controller</strong> controller, you’ll see it is very simple:</p>
<pre>
class ContentController &lt; ApplicationController

  def silver
  end

  def gold
  end
  
  def platinum
  end
end
</pre>
<p>It may be odd to see a controller that doesn’t contain the familar <code>index</code>, <code>show</code>, etc. methods of a RESTful controller. This is a case where a RESTful controller is not needed or appropriate. By default, the controller will render a view corresponding to each action.</p>
<h3>Check the Content Views</h3>
<p>Open each of the view files to see the placeholder content.</p>
<p><strong>app/views/content/silver.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#silver&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/silver.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/gold.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#gold&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/gold.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/platinum.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#platinum&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/platinum.html.erb&lt;/p&gt;
</pre>
<p>If you’re building a real application, you’ll want to provide content that is more useful than our placeholders. For a membership site that delivers content such as ebooks or videos, you could use a structure such as this, where we’ll restrict access to pages in a <strong>content</strong> directory based on the user’s subscription plan. For a site that delivers software as a service, the structure of your application will necessarily be more complex.</p>
<h3>Test the Content Pages</h3>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your subscription offer.</p>
<p>Visit <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a> to see one of the content pages.</p>
<p>Next we’ll set up access control to limit access to the content pages.</p>
<h3>Git Workflow</h3>
<p>If you haven’t commited any changes yet, commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add content pages"
</pre>
<p>Since the new feature is complete, merge the working branch to “master” and squash the commits so you have just one commit for the entire feature:</p>
<pre>
$ git checkout master
$ git merge --squash content-pages
$ git commit -m "add content pages"
</pre>
<p>You can delete the working branch when you’re done:</p>
<pre>
$ git branch -D content-pages
</pre>
<h2>Limit Access to Content</h2>
<p>We’ve got a home page with links to content pages for Silver, Gold, and Platinum subscribers. And we have created three users: Silver User, Gold User, and Platinum User. Now we’ll set limits on access to the content.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b authorization
</pre>
<h3>Set CanCan Ability</h3>
<p>Modify the <strong>app/models/ability.rb</strong> class to set access limits:</p>
<pre>
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new # guest user (not logged in)
    if user.has_role? :admin
      can :manage, :all
    else
      can :view, :silver if user.has_role? :silver
      can :view, :gold if user.has_role? :gold
      can :view, :platinum if user.has_role? :platinum
    end
  end
end
</pre>
<p>CanCan takes advantage of the Ruby language’s facility to create a <span class="caps">DSL</span> (Domain Specific Language). If you ignore the cryptic punctuation, it’s possible to read the <span class="caps">DSL</span> as if it was English. The statement <code>can :view, :silver if user.has_role? :silver</code> does what it says: If the user has a role of “silver” he or she can view “silver” content. Actually, a good portion of this is arbitrary. CanCan allows us to pass arbitrary parameters to the authorization method and I’ve simply chosen “view” and “silver” to be descriptive. All that matters is to use the same symbols in the Ability class as in the <code>authorize!</code> call in the controller. In the next step, you’ll see how we add the <code>authorize!</code> call to the controller.</p>
<h3>Set Access Limits in the Content Controller</h3>
<p>We’ll modify the <strong>app/controllers/content_controller</strong> file to set access limits:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!
  
  def silver
    authorize! :view, :silver, :message =&gt; 'Access limited to Silver Plan subscribers.'
  end
  
  def gold
    authorize! :view, :gold, :message =&gt; 'Access limited to Gold Plan subscribers.'
  end

  def platinum
    authorize! :view, :platinum, :message =&gt; 'Access limited to Platinum Plan subscribers.'
  end
end
</pre>
<p>We add <code>before_filter :authenticate_user!</code> (provided by Devise) to force a visitor to log in before any action.</p>
<p>We use the CanCan <code>authorize!</code> method to check the user’s role (corresponding to their subscription plan) on the actions that render the content pages. We pass two symbols to both <code>authorize!</code> (in the controller) and <code>can</code> (in the Ability class). The symbols can represent anything. By convention, the first symbol is the “action” one is trying to perform and the second symbol is the subject or target the action is being performed on. Our action is to “view” content but we could also say “see”, “access”, or “unlock.” We’ve defined one target as “silver” but it could be “silver_content”, “tier1”, or “plan-A” as long as we are consistent between the controller and Ability class. The CanCan documentation describes <a href="https://github.com/ryanb/cancan/wiki/Non-RESTful-Controllers">CanCan with Non-RESTful Controllers</a>.</p>
<h3>Alternative Implementation</h3>
<p>Keep in mind that we use CanCan only for convenience. You might not agree that CanCan provides benefit, especially when you consider that the CanCan <span class="caps">DSL</span> obscures the authorization mechanism. Cancan offers the advantage of collecting all authorization rules in the Ability class so the rules are easy to find and change. And it provides a familiar idiom for authorization so it is easy for other Rails developers (those who use CanCan) to understand your code.</p>
<p>If CanCan seems mysterious, it might help to see an alternative implementation without CanCan.</p>
<p>Here’s the <strong>app/controllers/content_controller</strong> file without CanCan:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!
  
  def silver
    if (current_user.has_role? :silver) || (current_user.has_role? :admin)
      render :silver
    else
      redirect_to :back, :notice =&gt; 'Access limited to Silver Plan subscribers.'
    end
  end
 
  def gold
   if (current_user.has_role? :gold) || (current_user.has_role? :admin)
      render :gold
    else
      redirect_to :back, :notice =&gt; 'Access limited to Gold Plan subscribers.'
    end
  end
  
  def platinum
    if (current_user.has_role? :platinum) || (current_user.has_role? :admin)
      render :platinum
    else
      redirect_to :back, :notice =&gt; 'Access limited to Platinum Plan subscribers.'
    end
  end
end
</pre>
<p>By using the <code>:authenticate_user!</code> before_filter, Devise makes available the <code>current_user</code> instance of the User model. We still use the <code>has_role?</code> method provided by Rolify. If the current_user has an appropriate role, we render the appropriate page. If not, we redirect to the previous page and display a notice. The code is much easier to understand without CanCan but it is lengthy and repetitive.</p>
<p><em>Note:</em> Please don’t blindly paste the alternative implementation into the <strong>app/controllers/content_controller</strong> file if you want to follow the tutorial. We’ll continue to use CanCan.</p>
<h3>Test Authorization</h3>
<p>You can check that the authorization limits work by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Log in as the first user (the administrator) with “user@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan grants you access as an administrator to any page. Log out.</p>
<p>Log in as the second user (assigned a “silver plan”) with “user2@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan only grants access to the “silver” content page.</p>
<p>Next we’ll set up a page where a visitor can register to use the site after choosing a subscription plan.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add authorization"
$ git checkout master
$ git merge --squash authorization
$ git commit -m "add authorization"
$ git branch -D authorization
</pre>
<h2>Registration Page</h2>
<p>Now that we have a home page with links to our placeholder content pages, plus authorization limits to restrict access based on subscription plan, let’s create a page where a visitor can register for the site and sign up for a subscription.</p>
<p>For the initial version of our registration page, we’ll let the visitor sign up for any subscription for free. Later, we’ll integrate Recurly billing services for purchase of a subscription plan.</p>
<p>The Devise authentication gem provides user management, including signing up users on a registration page. Our starter app already has a User model and uses a Devise controller and views to sign up visitors, asking for a name and email address and creating a user account. We could add a new “subscription purchase” page. Instead, since we already have a sign-up form provided by Devise, it’ll be easier to adapt the existing Devise registration page.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b registration
</pre>
<h3>Modify the Home Page</h3>
<p>We’ll change the links on the home page to direct the visitors to the Devise registration page.</p>
<p>Update the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'silver'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'gold'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'platinum'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We’ve replaced the <span class="caps">URL</span> helper for each of the links:</p>
<ul>
<li>
<code>content_silver_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'silver')</code>
</li>
	<li>
<code>content_gold_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'gold')</code>
</li>
	<li>
<code>content_platinum_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'platinum')</code>
</li>
</ul><p>Notice that we append a parameter to each link to indicate the subscription plan selected by the visitor. We are initiating an <span class="caps">HTTP</span> <span class="caps">GET</span> request so you’ll see a <span class="caps">URL</span> like this: <code>http://lvh.me:3000/users/sign_up?plan=silver</code>.</p>
<h3>Modify the Navigation Links</h3>
<p>Currently visitors see a “Sign up” link on the home page if they are not logged in. We’ll remove the “Sign up” link in the navigation bar because we want them to sign up by selecting a subscription plan.</p>
<p>Modify the file <strong>app/views/layouts/_navigation.html.erb</strong>:</p>
<pre>
&lt;%= link_to "Rails Recurly Subscription Saas", root_path, :class =&gt; 'brand' %&gt;
&lt;ul class="nav"&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Logout', destroy_user_session_path, :method=&gt;'delete' %&gt;        
    &lt;/li&gt;
  &lt;% else %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Login', new_user_session_path %&gt;  
    &lt;/li&gt;
  &lt;% end %&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Edit account', edit_user_registration_path %&gt;
    &lt;/li&gt;
    &lt;% if current_user.has_role? :admin %&gt;
      &lt;li&gt;
      &lt;%= link_to 'Admin', users_path %&gt;
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</pre>
<p>We’ve removed the “Sign up” link.</p>
<h3>Override the Devise Registrations Controller</h3>
<p>Create a file <strong>app/controllers/registrations_controller.rb</strong> to override the Devise registrations controller:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    if @plan
      super
    else
      redirect_to root_path, :notice =&gt; 'Please select a subscription plan below'
    end
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
  end
end
</pre>
<p>Devise provides a Registrations controller inside the Devise gem. It contains standard RESTful controller actions, including <code>new</code> and <code>create</code> (see <a href="https://github.com/plataformatec/devise/blob/master/app/controllers/devise/registrations_controller.rb">Devise::RegistrationsController</a> on GitHub).</p>
<p>We override the controller <code>new</code> action to set the <em>plan</em> variable. This allows us to display the name of the selected subscription plan on the registration page. When we modify the registration form, we’ll include the <em>plan</em> variable in a hidden input field. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons.</p>
<p>Notice that the <em>plan</em> parameter must be present or we redirect back to the home page and display a message “Please select a subscription plan below.”</p>
<p>Before calling <code>new</code> or <code>create</code>, the Devise Registrations controller initializes a new User with a private method named <code>build_resource</code>. The default <code>build_resource</code> method won’t assign an authorization role to our user. We override the <code>build_resource</code> method, first using the <code>super</code> method to call the parent <code>build_resource</code> method. Then we check if the <em>plan</em> parameter is available. On a <code>new</code> action, it will be available as a parameter passed from the home page. On a <code>create</code> action, it will be passed as a parameter from a hidden input field on the registration form.</p>
<p>If you’re wondering why you don’t see the User model as a <em>@user</em> variable, Devise has aliased it as the <em>resource</em> instance variable (<em>resource</em> allows Devise to accommodate models with names other than User, such as Account or Person).</p>
<p>Rolify has added the <code>add_role</code> method to the User model, so we call <code>add_role</code> to assign the plan as an authorization role.</p>
<p>Instead of overriding the controller <code>new</code> action, we could use a <code>before_filter</code> to set the <em>plan</em> variable before the <code>new</code> method is called. We could do this:</p>
<pre>
  before_filter :set_plan, :only =&gt; :new

  def set_plan
    @plan = params[:plan]
  end
</pre>
<p>Either implementation is effective; we’ve chosen to  override the <code>new</code> method rather than using a <code>before_filter</code>.</p>
<h3>Override the Devise Routes</h3>
<p>Modify <strong>config/routes.rb</strong> to use the new controller. Replace <code>devise_for :users</code> with:</p>
<pre>
devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
</pre>
<p>You’ve modified the routes file, so you must restart the server for any changes to take effect.</p>
<h3>Modify the Devise Registration Page</h3>
<p>We’ll use the Devise registration page as our subscription sign-up form.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong> to add details about the subscription plan:</p>
<pre>
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form form-vertical' }) do |f| %&gt;
  &lt;h3&gt;&lt;%= params[:plan].titleize if params[:plan] %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= hidden_field_tag 'plan', params[:plan] %&gt;
  &lt;%= f.hidden_field :customer_id %&gt;
  &lt;%= f.input :first_name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :last_name %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>We display the name of the selected subscription plan. The <code>titleize</code> method transforms the <em>plan</em> string from lowercase to titlecase.</p>
<p>We add a hidden input field with <code>hidden_field_tag</code> to include a parameter identifying the selected subscription plan. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons and set as a variable by our Registrations controller. We also include the <code>customer_id</code> as a hidden field.</p>
<p>We add input fields for Recurly’s required <code>first_name</code> and <code>last_name</code>.</p>
<p>We remove the <code>&lt;%= render "devise/shared/links" %&gt;</code> navigation links because we already have a login link in the page navigation bar.</p>
<p>When we submit the form, Rails does its form processing magic, including validation of the model attributes, and saves the new User record to the database.</p>
<h3>Test Registration</h3>
<p>You can check that registration works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in and submit the form. You’ll see a message “Welcome! You have signed up successfully.” Note that we’re not using the Devise Confirmable module so the application doesn’t send a confirmation email. You’ll be logged in as the new user as soon as you submit the form.</p>
<p>If you’ve selected the Silver Plan for the new user, try visiting <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a>. You should be able to view the page. You should see an error message if you attempt to visit  <a href="http://localhost:3000/content/gold">http://localhost:3000/content/gold.html</a>.</p>
<p>Now we have a registration page that assigns a subscription plan when a visitor signs up for the site. In the next step, we’ll make sure the user gets redirected to an appropriate page after sign up or log in.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add registration"
$ git checkout master
$ git merge --squash registration
$ git commit -m "add registration"
$ git branch -D registration
</pre>
<h2>Redirect After Sign Up or Log In</h2>
<p>As currently implemented, when a user signs up or logs in, they see the home page with a confirmation message. Instead, we want a user to be redirected to a page that is an appropriate hub for their role or subscription tier.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b redirect
</pre>
<h3>Modify the Application Controller</h3>
<p>Modify the file <strong>app/controllers/application_controller.rb</strong>:</p>
<pre>
class ApplicationController &lt; ActionController::Base
  protect_from_forgery

  rescue_from CanCan::AccessDenied do |exception|
    redirect_to root_path, :alert =&gt; exception.message
  end

  def after_sign_in_path_for(resource)
    case current_user.roles.first.name
      when 'admin'
        users_path
      when 'silver'
        content_silver_path
      when 'gold'
        content_gold_path
      when 'platinum'
        content_platinum_path
      else
        root_path
    end
  end
  
end
</pre>
<p>The <code>after_sign_in_path_for(resource)</code> method will redirect a user to an appropriate page after sign in or sign up. The <code>case</code> statement checks the user’s role and redirects to the appropriate content page, or if an administrator, to the administrative dashboard.</p>
<p>When we use Rolify, each user can have multiple roles. We only assign a single role in this application, so we ask for the first role associated with the user. When a role object is displayed as a string, it will be a number, so we ask for the name attribute of the role.</p>
<p>Devise also offers an <code>after_sign_up_path_for(resource)</code> method that allows a different redirect after a user registers. You could implement the <code>after_sign_up_path_for(resource)</code> method if you wanted the new user to see a special page after sign up (for example, a thank you or introduction).</p>
<h3>Test Redirect</h3>
<p>You can check that the redirect works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Subscribe to any subscription plan. You should be redirected to the appropriate page and see a message “Welcome! You have signed up successfully.” Log out and log in. You should be redirected to the appropriate page.</p>
<p>In the next step, we’ll integrate Recurly payment for subscription plans.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "redirect after log in"
$ git checkout master
$ git merge --squash redirect
$ git commit -m "redirect after log in"
$ git branch -D redirect
</pre>
<h2>Recurly Integration</h2>
<p>We’ve got a fully functional web application that serves up placeholder content to registered users and restricts access based on the subscription plan the user has selected. Now we’ll integrate Recurly billing so we can charge users for subscriptions.</p>
<p>Remember we’re using our Devise registration page for subscription sign up. We’ll make this our payment page. We’ll ask the visitor to enter credit card data on this page.</p>
<p>Here’s the most obvious way to implement billing:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>data is received by your application on your server</li>
	<li>an application controller <code>create</code> action initiates a request to the payment processor</li>
	<li>the <code>create</code> method receives an acknowledgment of a completed or declined transaction</li>
	<li>the <code>create</code> method saves the user data (and creates an account) or shows an error message</li>
</ul><p>There’s a big drawback to this approach: Credit card data is sent to your server. Your server becomes a target for thieves and you must secure the server and maintain <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> (the credit card industry security standard).</p>
<p>Instead, we can implement an architecture that cuts risk and makes it much easier to meet <span class="caps">PCI</span> compliance requirements.</p>
<p>Recurly offers the <a href="https://docs.recurly.com/recurlyjs">Recurly.js JavaScript library</a> which generates a subscription form dynamically. The JavaScript library submits the credit card data directly to the Recurly servers, bypassing your server completely. Unfortunately, the Recurly.js JavaScript library is not well-suited for integration with a Rails application. It is standalone code that only provides what is needed to create a Recurly subscription. To be used with our application, we’d have to implement a complicated two-step registration process that uses a typical Rails form to create an account (with user name and password) and a separate JavaScript-based form for subscription payment. As Rails developers, we’d like to use the native Rails form helpers to build a single form that registers a new user and collects subscription payment information. To do so, we’ll borrow some code from the Recurly.js JavaScript library and create our own recurly.js script so we can send billing information to Recurly securely while processing a new user registration on our own server.</p>
<p>Here is our preferred program flow:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>a JavaScript function sends the card data to Recurly’s servers</li>
	<li>Recurly’s servers create a customer record and process a credit card transaction</li>
	<li>a JavaScript callback receives a Recurly token or an error message</li>
	<li>the JavaScript function submits the form to our server</li>
	<li>a User model <code>before_create</code> method checks that a Recurly customer account exists</li>
	<li>a Registrations controller <code>create</code> action creates a new user</li>
</ul><p>This hybrid approach makes implementation more complex but the result is robust and secure. Recurly takes responsibility for the security of the credit card data and it never touches our server.</p>
<p>This approach is not original. It is very similar to the implementation used in the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> example application which, in turn, was inspired by Ryan Bates’s implementation from his RailsCast <a href="http://railscasts.com/episodes/288-billing-with-stripe">Billing with Stripe</a>. Thank you, Ryan!</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b billing
</pre>
<h3>Prepare Your Recurly Account</h3>
<p>Before we can submit a billing request to Recurly, we have to set up our subscription plans in Recurly.</p>
<p>We’ll tell Recurly that we have three plans named “Silver”, “Gold”, and “Platinum” that will be billed monthly at rates of $9, $19, and $29. Once a customer is created and assigned a plan, Recurly will do all the work of notifying the user, initiating monthly billing, and contacting the user when a credit card is declined or expires.</p>
<p>Go to your Recurly account profile to create a subscription plan. Look for “Configuration/Subscription Plans.” Recurly offers <a href="https://docs.recurly.com/subscriptions">documentation about creating subscriptions</a> and <a href="https://docs.recurly.com/api/subscriptions">additional detail about subscriptions</a>.</p>
<p>Create three different plans with the following values:</p>
<table>
<tr>
<th>Plan Name </th>
		<th>Plan Code </th>
		<th>Pricing </th>
		<th>Interval </th>
	</tr>
<tr>
<td> Silver </td>
		<td> silver </td>
		<td> 9.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> Gold </td>
		<td> gold </td>
		<td> 19.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> Platinum </td>
		<td> platinum </td>
		<td> 29.00 </td>
		<td> monthly </td>
	</tr>
</table><p>“Plan Name” is displayed on invoices and in the Recurly web interface. “Plan Code” is a unique string of your choice that is used to identify the plan when subscribing a customer. The “Plan Code” should correspond to a role we’ve created to manage access. “Pricing” is the subscription price. You’ll specify the billing frequency. Optionally, you can specify a free trial period. If you include a trial period, the customer won’t be billed for the first time until the trial period ends. If the customer cancels before the trial period is over, she’ll never be billed at all.</p>
<p>Now that Recurly knows about our subscription plans, we’ll add attributes to our User model.</p>
<h3>Add a Virtual Attribute to the User Model</h3>
<p>When a new user signs up for a subscription, we’ll use JavaScript on the registration page to submit credit card data to Recurly. A successful transaction will return a Recurly token. The Recurly token will be included as a hidden field when the user submits the registration form.</p>
<p>Before we can include a hidden field in the form, we must modify the User model to accept this field. It doesn’t need to be added to the User database schema as it will only be used when the form is processed by the Registrations controller. We’ll add it as a virtual attribute. For more on virtual attributes, see the RailsCast <a href="http://railscasts.com/episodes/16-virtual-attributes-revised">Virtual Attributes</a>.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :customer_id, :card_token
  attr_accessor :card_token

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end

end
</pre>
<p>We add the virtual attribute with <code>attr_accessor</code> which will automatically create getter and setter methods and store the <code>card_token</code> value as an instance variable. Also we add the new <code>card_token</code> field to the <code>attr_accessible</code> list so that it can be set through mass assignment.</p>
<p>With the virtual attribute in place, we will modify the Registrations controller and add fields for credit card data to the form.</p>
<h3>Modify the Registrations Controller</h3>
<p>Modify the file <strong>app/controllers/registrations_controller.rb</strong>:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    if @plan
      @signature = Recurly.js.sign :subscription =&gt; { :plan_code =&gt; @plan }
      super
    else
      redirect_to root_path, :notice =&gt; 'Please select a subscription plan below'
    end
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
    resource.customer_id ||= SecureRandom.uuid
  end
end
</pre>
<p>We add a statement to each method.</p>
<p>For the <code>new</code> method, we add:</p>
<pre>
@signature = Recurly.js.sign :subscription =&gt; { :plan_code =&gt; @plan }
</pre>
<p>For the <code>new</code> method, if the <em>plan</em> parameter is present, we obtain a Recurly cryptographic signature and then call the <code>super</code> method to inherit the original controller <code>new</code> action.</p>
<p>Recurly requires a <a href="https://docs.recurly.com/recurlyjs/signatures">cryptographic signature</a> to verify information sent to Recurly from the visitor’s browser. The signature validates that parameters submitted from the form have not been tampered with before being received by Recurly. The Recurly gem provides a method <code>Recurly.js.sign</code> to generate the cryptographic signature. The <code>Recurly.js.sign</code> method <a href="http://docs.recurly.com/api/recurlyjs/integration#create-signature">takes various parameters</a> such as subscription, account, or transaction; in this case, we are creating a subscription so we pass the <em>plan</em> parameter to the <code>Recurly.js.sign</code> method. The resulting cryptographic signature contains an authentication code combined with the encoded <em>plan</em> parameter. When the Recurly servers parse the form submission, the authentication code guarantees the authenticity of the message and the encoded plan parameter should match the <em>plan</em> parameter submitted via the form.</p>
<p>For the <code>build_resource</code> method, we add:</p>
<pre>
resource.customer_id ||= SecureRandom.uuid
</pre>
<p>We set a customer id for the User object. The customer id is essential, as it allows us to maintain concurrency between Recurly’s customer records and our own. Recurly wants us to assign a unique identifier when we create a customer record. As a Rails ActiveRecord object, our User model will get a unique object id when the database record is created. But we are creating a Recurly customer record before we create the ActiveRecord object so the ActiveRecord object id is not yet available. We surmount this obstacle by using the Ruby <a href="http://apidock.com/ruby/SecureRandom/uuid/class">SecureRandom.uuid</a> method to generate a unique identifier. This will be our customer id for both Recurly’s customer records and our own.</p>
<h3>Add Credit Card Data to the Registration Form</h3>
<p>We’ll need fields for a credit card number, security code, and expiration date.</p>
<p>We’ll also add a placeholder <code>div</code> for any error messages returned by the Recurly server.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong>:</p>
<pre>
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;div id="card_error" class="alert alert-error" style="display:none" &gt;&lt;/div&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form form-vertical', 'data-subdomain' =&gt; RECURLY_SUBDOMAIN, 'data-signature' =&gt; @signature, 'data-ip_address' =&gt; request.remote_ip}) do |f| %&gt;
  &lt;h3&gt;&lt;%= params[:plan].titleize if params[:plan] %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= hidden_field_tag 'plan', params[:plan] %&gt;
  &lt;%= f.hidden_field :customer_id %&gt;
  &lt;%= f.input :first_name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :last_name %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;% if @user.card_token %&gt;
    &lt;p&gt;Credit card acceptance is pending.&lt;/p&gt;
  &lt;% else %&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :country, "Country" %&gt;
      &lt;%= select_tag 'country', country_options_for_select(selected = 'US', priority_countries = 'US') %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
      &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
      &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_month, "Card Expiration" %&gt;
      &lt;%= select_month nil, {add_month_numbers: true}, {name: nil, id: "card_month"}%&gt;
      &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :coupon, "Promotional Coupon (if any)" %&gt;
      &lt;%= text_field_tag :coupon, nil, name: nil %&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  &lt;%= f.hidden_field :card_token %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>Take a look at <code>div id="card_error"</code>. We give it the “alert alert-error” style from Twitter Bootstrap. It remains hidden with a <code>style="display:none"</code> unless we use JavaScript to show it when we receive an error message from the Recurly server. We’ll add the necessary JavaScript soon.</p>
<p>If you examine the <span class="caps">HTML</span> source, you will see:</p>
<pre>
&lt;form accept-charset="UTF-8" action="/users" class="card_form form-vertical" data-subdomain="..." data-signature="..." data-ip_address="..." id="new_user" method="post"&gt;
</pre>
<p>The Rails form builder creates a form with the id <code>new_user</code>. The id is generated automatically from the controller name “user” and action name “new”.</p>
<p>We use an HTML5 technique for embedding data within the page that will be used by our JavaScript code. We set form tag attributes <code>data-subdomain</code>, <code>data-signature</code>, and <code>data-ip_address</code>. The <code>data-subdomain</code> value is set with the <code>RECURLY_SUBDOMAIN</code> constant that we set in our <strong>config/initializers/recurly.rb</strong> file (which was originally set in the <strong>config/application.yml</strong> file). Recurly needs the user’s IP address (for credit card fraud prevention) and a cryptographic signature (to guarantee the form data is tamperproof). The IP address is obtained from the Rails <code>request</code> object and the cryptographic signature is generated in the Registrations controller <code>new</code> action.</p>
<p>We also pass the customer_id attribute as a hidden field. This will be used by the JavaScript library when the credit card data is submitted to Recurly to create a customer record. It will also be used to set the User model customer_id attribute when our application saves the record in our database.</p>
<p>We’ve added fields for credit card data but we’ve made inclusion of the fields conditional on the absence of the <code>@user.card_token</code> attribute. This accommodates a situation where correct credit card data is provided but the form fails to pass a validation test (such as a blank email address). If Recurly accepts the credit card data and provides a <code>card_token</code> but there’s no email address, we’ll save the Recurly token in a hidden field and prompt the user to correct the email address.</p>
<p>Notice the differences between the credit card data fields and the previous data fields.</p>
<p>The first_name, last_name, email, and password fields correspond to attributes of the User model. We use the Rails form builder object (the <em>f</em> variable) to bind the form to the User model. Methods such as <code>f.text_field</code> create form controls using the form builder object which automatically populate the attributes of the User model.</p>
<p>The credit card data fields do not correspond to attributes of the User model so we can’t use the form builder object. We use the more primitive <code>label_tag</code> and <code>text_field_tag</code> instead. Notice we specify the <code>name:</code> of the element as nil. For the expiration <code>select_month</code> and <code>select_year</code> we also set an element ID to replace the ID that the Rails form helper generates. Thus the fields will be available to our JavaScript code but will not be submitted to the server.</p>
<p>It’s not strictly necessary to provide the customer’s IP address and country to Recurly but it improves credit card fraud detection. We use a country_select form helper from Josh Robinson’s <a href="https://github.com/hexorx/countries">countries gem</a> to provide a list of countries that returns an <span class="caps">ISO</span> two digit country code. “US” is set as the selected country but you can change this as necessary.</p>
<p>Now we’ll add JavaScript to submit credit card data from the form to the Recurly server.</p>
<h3>Add the Recurly JavaScript Library</h3>
<p>You can learn more about the <a href="http://js.recurly.com/">Recurly JavaScript library</a> (with examples), see the <a href="https://docs.recurly.com/recurlyjs">Recurly JavaScript library documentation</a>, or download the code from the <a href="https://github.com/recurly/recurly-js">Recurly.js GitHub repository</a>. The Recurly JavaScript library is intended to be used to generate a form dynamically using JavaScript. We’ve hacked the code to create our own <em>recurly.js</em> script that allows us to submit a billing request to the Recurly servers from our own Rails-based form. The hacked code is not elegant. You may wish to rewrite it using CoffeeScript (if you do, please contribute it to the project).</p>
<p>Create a file <strong>app/assets/javascripts/recurly.js</strong>:</p>
<pre>
// Recurly.js
// JavaScript library for the Recurly API
// adapted for the rails-recurly-subscription-saas example application
// from https://github.com/recurly/recurly-js

function createObject(o) {
  function F() {}
  F.prototype = o || this;
  return new F();
};

var Recurly = {};

$('.registrations.new').ready(function() {
  
  Recurly.settings = {
    enableGeoIP: true
  , acceptedCards: ['american_express', 'discover', 'mastercard', 'visa']
  , oneErrorPerField: true
  , baseURL: 'https://api.recurly.com/jsonp/' + $('#new_user').data('subdomain') + '/'
  };

  Recurly.version = '2.1.3';

  Recurly.ajax = function(options) {
    options.data = $.extend({js_version: Recurly.version}, options.data);
    return $.ajax(options);
  };

  Recurly.flattenErrors = function(obj, attr) {
    var arr = [];
    var attr = attr || '';
    if(  typeof obj == 'string'
      || typeof obj == 'number'
      || typeof obj == 'boolean') {
      if (attr == 'base') {
        return [obj];
      }
      return ['' + attr + ' ' + obj];
    }
    for(var k in obj) {
      if(obj.hasOwnProperty(k)) {
        // Inherit parent attribute names when property key
        // is a numeric string; how we deal with arrays
        attr = (parseInt(k).toString() == k) ? attr : k;
        var children = Recurly.flattenErrors(obj[k], attr);
        for(var i=0, l=children.length; i &lt; l; ++i) {
          arr.push(children[i]);
        }
      }
    }
    return arr;
  };

  Recurly.Account = {
    create: createObject
  , toJSON: function(card) {
      return {
        first_name: card.first_name
      , last_name: card.last_name
      , account_code: card.customer_id
      , email: card.email
      };
    }
  };

  Recurly.BillingInfo = {
    create: createObject
  , toJSON: function(card) {
      return {
        first_name: card.first_name
      , last_name: card.last_name
      , month: card.expMonth
      , year: card.expYear
      , number: card.number
      , verification_value: card.cvc
      , country: card.country
      , ip_address: card.ip_address
      };
    }
  };

  Recurly.Subscription = {
    create: createObject
  , plan: Recurly.Plan
  , addOns: []

  , calculateTotals: function() {
      var totals = {
        stages: {}
      };

      // PLAN
      totals.plan = this.plan.cost.mult(this.plan.quantity);

      // ADD-ONS
      totals.allAddOns = new Recurly.Cost(0);
      totals.addOns = {};
      for(var l=this.addOns.length, i=0; i &lt; l; ++i) {
        var a = this.addOns[i],
            c = a.cost.mult(a.quantity);
        totals.addOns[a.code] = c;
        totals.allAddOns = totals.allAddOns.add(c);
      }

      totals.stages.recurring = totals.plan.add(totals.allAddOns);

      totals.stages.now = totals.plan.add(totals.allAddOns);

      // FREE TRIAL 
      if(this.plan.trial) {
        totals.stages.now = Recurly.Cost.FREE; 
      }

      // COUPON
      if(this.coupon) {
        var beforeDiscount = totals.stages.now;
        var afterDiscount = totals.stages.now.discount(this.coupon);
        totals.coupon = afterDiscount.sub(beforeDiscount);
        totals.stages.now = afterDiscount;
      }

      // SETUP FEE
      if(this.plan.setupFee) {
        totals.stages.now = totals.stages.now.add(this.plan.setupFee);
      }

      // VAT
      if(this.billingInfo &amp;&amp; Recurly.isVATChargeApplicable(this.billingInfo.country,this.billingInfo.vatNumber)) {
        totals.vat = totals.stages.now.mult( (Recurly.settings.VATPercent/100) );
        totals.stages.now = totals.stages.now.add(totals.vat);
      }

      return totals;
    }
  , redeemAddOn: function(addOn) {
    var redemption = addOn.createRedemption();
    this.addOns.push(redemption); 
    return redemption;
  }

  , removeAddOn: function(code) {
    for(var a=this.addOns, l=a.length, i=0; i &lt; l; ++i) {
      if(a[i].code == code) {
        return a.splice(i,1);
      }
    }
  }

  , findAddOnByCode: function(code) {
      for(var l=this.addOns.length, i=0; i &lt; l; ++i) {
        if(this.addOns[i].code == code) {
          return this.addOns[i];
        }
      }
      return false;
    }

  , toJSON: function(plan, coupon) {
      var json = {
        plan_code: plan.plan_code
      , quantity: plan.quantity ? plan.quantity : 1
      , currency: plan.currency ? plan.quantity : 'USD'
      , coupon_code: coupon.coupon_code ? coupon.coupon_code : undefined
      , add_ons: []
      };

      for(var i=0, l=this.addOns.length, a=json.add_ons, b=this.addOns; i &lt; l; ++i) {
        a.push({
          add_on_code: b[i].code
        , quantity: b[i].quantity
        });
      }

      return json;
    }

  , save: function(signature, plan, coupon, card, callback) {
      var json = {
        subscription: this.toJSON(plan, coupon)
      , account: Recurly.Account.toJSON(card)
      , billing_info: Recurly.BillingInfo.toJSON(card)
      , signature: signature
      };

      Recurly.ajax({
        url: Recurly.settings.baseURL+'subscribe',
        data: json,
        dataType: "jsonp",
        jsonp: "callback",
        timeout: 60000,
        success: function(response){
          callback(response)
        },
        error: function() {
          console.log(['Unknown error processing transaction. Please try again later.']);
        }
      });

    }
  };
});
</pre>
<p>The code is idiosyncratic and can be improved. The best that can be said is that it works. Please feel free to improve it and contribute back to the project.</p>
<h3>Script for Conditional Execution of Page-Specific JavaScript</h3>
<p>We’ll use a technique described in the article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Adding JavaScript to Rails</a> to only execute our JavaScript library on the registration page. We’ll add a script named <em>jquery.readyselector.js</em> (from <a href="https://github.com/Verba/jquery-readyselector">John Firebaugh</a>) that allows us to execute JavaScript conditionally on a page.</p>
<p>First, make sure that the application layout file is set to provide parameters needed for the <em>jquery.readyselector.js</em> script. The default RailsApps application layout file should already contain a <code>&lt;body&gt;</code> tag that looks like this:</p>
<pre>
&lt;body class="&lt;%= controller_name %&gt; &lt;%= action_name %&gt;"&gt;
</pre>
<p>If it doesn’t, make sure to add it now.</p>
<p>We’ll add a script that will help us execute JavaScript conditionally on a page.</p>
<p>Create a file <strong>app/assets/javascripts/jquery.readyselector.js</strong>:</p>
<pre>
(function ($) {
  var ready = $.fn.ready;
  $.fn.ready = function (fn) {
    if (this.context === undefined) {
      // The $().ready(fn) case.
      ready(fn);
    } else if (this.selector) {
      ready($.proxy(function(){
        $(this.selector, this.context).each(fn);
      }, this));
    } else {
      ready($.proxy(function(){
        $(this).each(fn);
      }, this));
    }
  }
})(jQuery);
</pre>
<p>If you prefer CoffeeScript, you can convert JavaScript to CoffeeScript <a href="http://js2coffee.org/">here</a> or <a href="http://js2cs.nodejitsu.com/">here</a>.</p>
<p>If you haven’t changed the default manifest file, the <em>jquery.readyselector.js</em> script will be automatically loaded by the <code>//= require_tree .</code> directive in the <strong>app/assets/javascripts/application.js</strong> manifest file. If you’ve removed the <code>//= require_tree .</code> directive, specify the script in the <strong>app/assets/javascripts/application.js</strong> manifest file:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require jquery.readyselector
</pre>
<h3>Create a Registrations JavaScript File</h3>
<p>We’ll create a new file for our page-specific JavaScript and give the file the same name as the controller. For now, we’ll only create some test code.</p>
<p>Create a file <strong>app/assets/javascripts/registrations.js</strong>:</p>
<pre>
$('.home.index').ready(function() {
  console.log("Page-specific JavaScript on the home.index page.");
});

$('.registrations.new').ready(function() {
  console.log("Page-specific JavaScript on the registrations.new page.");
});
</pre>
<p>This code will test if JavaScript is executing conditionally on a page.</p>
<p>Later we will add the code that collects the credit card data from the subscription form and submits it to the Recurly server.</p>
<p>Start the server and visit the home page. Check the JavaScript console to observe the debugging messages.</p>
<p>Here’s how to use the JavaScript console. Every web browser provides access to the JavaScript console for debugging. In Chrome, choose the menu item <em>View/Developer/JavaScript Console</em>. Reload the page and you will see console messages. We’ve added console messages to trace the program flow as each function is executed. Use this technique for debugging if you have problems.</p>
<p>When you visit the home page, you should see a debugging message in the JavaScript console:</p>
<pre>
Page-specific JavaScript on the home.index page.
</pre>
<p>Click a “Subscribe” button. You should see the registration page. You’ll see more debugging messages in the JavaScript console:</p>
<pre>
Page-specific JavaScript on the registrations.new page.
</pre>
<p>If you see these messages, you’re ready to continue.</p>
<h3>Add JavaScript for Form Processing</h3>
<p>We need code that runs in the browser to submit the credit card data to Recurly and obtain a Recurly token before the form is sent to our server.</p>
<p>Replace the contents of <strong>app/assets/javascripts/registrations.js</strong> with this:</p>
<pre>
$('.registrations.new').ready(function() {
  var signature = $('#new_user').data('signature')
  var ip_address = $('#new_user').data('ip_address')
  var subscription = {
    setupForm: function() {
      console.log('function: setupForm')
      return $('.card_form').submit(function() {
        console.log('setupForm: form submitted')
        $('input[type=submit]').prop('disabled', true);
        if ($('#card_number').length) {
          subscription.processCard();
          return false;
        } else {
          return true;
        }
      });
    },
    processCard: function() {
      console.log('function: processCard');
      var plan;
      plan = {
        plan_code: $('#plan').val(),
      };
      var coupon;
      coupon = {
        coupon_code: $('#coupon').val(),
      };
      var card;
      card = {
        customer_id: $('#user_customer_id').val(),
        email: $('#user_email').val(),
        first_name: $('#user_first_name').val(),
        last_name: $('#user_last_name').val(),
        number: $('#card_number').val(),
        cvc: $('#card_code').val(),
        expMonth: $('#card_month').val(),
        expYear: $('#card_year').val(),
        country: $('#country').val(),
        ip_address: ip_address
      };
      return Recurly.Subscription.save(signature, plan, coupon, card, subscription.handleResponse);
    },
    handleResponse: function(response) {
      console.log('function: handleResponse');
      if(response.success) {
        return alert('Recurly response: ' + response.success.token);
      }
      else if(response.errors) {
        return alert('Recurly response: ' + Recurly.flattenErrors(response.errors));
      }
    }
  };
  return subscription.setupForm();
});
</pre>
<p>This is not the final version of the JavaScript code; it contains debugging messages so you can verify the code is working.</p>
<p>We add the functionality we need to process a form and submit the credit card data to the Recurly server. We’ll look closely at the code in the next section. For now, let’s test the new code.</p>
<p>Start the server and visit the page. Check the JavaScript console to observe the debugging messages. Fill out the form, using a fake credit card number.</p>
<p>Recurly provides a set of fake credit card numbers which will force various responses. See the Recurly <a href="https://docs.recurly.com/payment-gateways/test">Test Credit Card Numbers</a> documentation. Here are some useful numbers:</p>
<ul>
<li>a fake credit card: <em>4111-1111-1111-1111</em>
</li>
	<li>incorrect number: use a number that fails the checksum, e.g. <em>4242424242424241</em>
</li>
	<li>invalid expiry month: use an invalid month, e.g. <em>13</em>
</li>
	<li>invalid expiry year: use a year in the past, e.g. <em>1970</em>
</li>
	<li>invalid cvc: use a two digit number, e.g. <em>99</em>
</li>
</ul><p>Submit the form. You should see an alert displaying the response from the Recurly server.</p>
<p>It’s fun (for a few minutes) to enter various numbers and observe the response from the Recurly server.</p>
<p>Here’s what you should see in the JavaScript console:</p>
<pre>
function: setupForm
setupForm: form submitted
function: processCard
function: handleResponse
</pre>
<p>Yea! You’re communicating with the Recurly server.</p>
<p>Now that you’ve confirmed you can send credit card data to the Recurly server, remove the debugging code from the script. While we’re at it, we’ll add the code to handle the response from the Recurly server.</p>
<p>Replace the contents of <strong>app/assets/javascripts/registrations.js</strong> with this:</p>
<pre>
$('.registrations.new').ready(function() {
  var signature = $('#new_user').data('signature')
  var ip_address = $('#new_user').data('ip_address')
  var subscription = {
    setupForm: function() {
      return $('.card_form').submit(function() {
        $('input[type=submit]').prop('disabled', true);
        if ($('#card_number').length) {
          subscription.processCard();
          return false;
        } else {
          return true;
        }
      });
    },
    processCard: function() {
      var plan;
      plan = {
        plan_code: $('#plan').val(),
      };
      var coupon;
      coupon = {
        coupon_code: $('#coupon').val(),
      };
      var card;
      card = {
        customer_id: $('#user_customer_id').val(),
        email: $('#user_email').val(),
        first_name: $('#user_first_name').val(),
        last_name: $('#user_last_name').val(),
        number: $('#card_number').val(),
        cvc: $('#card_code').val(),
        expMonth: $('#card_month').val(),
        expYear: $('#card_year').val(),
        country: $('#country').val(),
        ip_address: ip_address
      };
      return Recurly.Subscription.save(signature, plan, coupon, card, subscription.handleResponse);
    },
    handleResponse: function(response) {
      if(response.success) {
        $('#user_card_token').val(response.success.token)
        $('.card_form')[0].submit()
      }
      else if(response.errors) {
        $('#card_error').text(Recurly.flattenErrors(response.errors)).show();
        return $('input[type=submit]').prop('disabled', false);
      }
    }
  };
  return subscription.setupForm();
});
</pre>
<p>Here’s an explanation of the JavaScript.</p>
<p>We restrict execution of the code to a page that has a class “registrations.new” In this case, the code will run on the Registrations#New page.</p>
<p>We set variables for <code>signature</code> and <code>ip_address</code> which we obtain from the HTML5 data attributes of the tag with the <code>#new_user</code> id.</p>
<p>We create a <code>subscription</code> object with several functions: <code>setupForm</code>, <code>processCard</code>, and <code>handleResponse</code>.</p>
<p>We call the <code>setupForm</code> function which listens for the form submission event. When the visitor submits the form, the submit button is disabled (so the user can’t press it repeatedly) and the <code>processCard</code> function is called. Returning <code>false</code> makes sure the form is not submitted to our server at this stage. Notice that we don’t call the <code>processCard</code> function if the credit card number is blank; instead we return “true” which submits the form. This will be true if the credit card data was previously accepted (and a Recurly token is included in the hidden field) but there was an error such as a missing email address.</p>
<p>The <code>processCard</code> function parses the form and obtains the credit card data. Then it calls a function from the Recurly library named <code>Subscription.save</code> which submits the card data to the Recurly server. When the Recurly server returns a response, we call the <code>handleResponse</code> function.</p>
<p>The <code>handleResponse</code> function checks the <code>response</code> object for a success boolean. If the success code is true, the function sets the <code>card_token</code> hidden field in the form (it has the <span class="caps">HTML</span> element ID “user_card_token”) and calls <code>submit</code> on the element with the “card_form” class (which is the form). If the status code is false, the function sets the error message from the Recurly server in the <code>card_error</code> div and re-enables the submit button.</p>
<p>In effect, we modify the form’s submit button so that the credit card data is first sent to the Recurly server, the response token is obtained and set in a hidden field, and then the form is submitted to our application for processing by our Registrations controller.</p>
<p>You can start the server and create a subscription. Use the fake credit card number <em>4111-1111-1111-1111</em>. You’ll see an error message on the page if the credit card data is incomplete. If the credit card data is accepted, a new User account will be created and you’ll be redirected to an appropriate content page where you’ll see a message “Welcome! You have signed up successfully.”</p>
<p>But wait. We’ve created a new User account but we should check with Recurly to make sure a new customer was created before we save the User record.</p>
<h3>Modify the User Model</h3>
<p>We want to make a request to Recurly to check that a customer record was created before a new user is saved. There are several ways we could do this:</p>
<ul>
<li>modify the Registrations controller <code>create</code> action to initiate a request to Recurly</li>
	<li>add a new method such as <code>save_new_customer</code> to the User model and swap it for the <code>save</code> method used in the Registrations controller <code>create</code> action</li>
	<li>add a <code>check_recurly</code> method to the User model and call it with <code>before_create</code> in the User model</li>
</ul><p>The first option, modifying the Registrations controller, results in the much-abhorred “fat controller” anti-pattern. We’ll avoid that. The second option moves the Recurly request to the model but there is no need to modify the Registrations controller to use an alternative to the <code>save</code> method. The third option is optimal. We’ll add a <code>check_recurly</code> method that is called before the user instance is created.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :card_token, :customer_id
  attr_accessor :card_token
  before_create :check_recurly

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end

  def check_recurly
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    false
  end

end
</pre>
<p>We add <code>before_create :check_recurly</code> to call the <code>check_recurly</code> method when the user is created.</p>
<p>The <code>check_recurly</code> method makes our request to the Recurly service. We skip the process if <code>customer_id</code> is nil. This allows us to run <code>rake db:seed</code> or <code>rake db:reset</code> to set up our administrative user and default sample accounts for this tutorial (we don’t set a <code>customer_id</code> for the admin and sample accounts).</p>
<p>If the user instance has a <code>customer_id</code>, we make a request using the Recurly <span class="caps">API</span> call <code>Recurly::Account.find</code> and look up the customer record using the <code>customer_id</code>. If the <span class="caps">API</span> call fails or the customer is not found, we don’t create a User record and we throw an error. If the customer is found, we obtain and set the last four digits of the user’s credit card number and the User record is created.</p>
<h3>Test Recurly Integration</h3>
<p>We have all the code needed for visitors to sign up for new subscriptions. Let’s test the application.</p>
<p>Start the web server:</p>
<pre>
$ rails server
</pre>
<p>Visit <a href="http://localhost:3000/">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in the form using the fake credit card number <em>4111-1111-1111-1111</em>. Submit the form.</p>
<p>You’ll be redirected to an appropriate page and see a message “Welcome! You have signed up successfully.” You’ll be logged in as a new user. If you’ve selected the Silver Plan for the new user, you should be on the page  <a href="http://localhost:3000/content/silver.html">http://localhost:3000/content/silver.html</a>. You should see an error message if you attempt to visit <a href="http://localhost:3000/content/gold.html">http://localhost:3000/content/gold.html</a>.</p>
<p>Visit your Recurly account profile and see the new customer you’ve created. Look for “Customer Service/Subscriptions.” If you check the customer details, you should see that the fake credit card was billed and the subscription status is “active.”</p>
<p>Pat yourself on the back! You’ve reached a milestone. You now can take credit card payments for subscriptions.</p>
<p>There’s more to do, however:</p>
<ul>
<li>modify “edit account” so users can change credit cards, change plans, and unsubscribe</li>
	<li>implement Recurly “webhooks” so expired subscribers will be denied access to the site</li>
</ul><p>Let’s update our Git repository before we continue.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add Recurly"
$ git checkout master
$ git merge --squash billing
$ git commit -m "add Recurly"
$ git branch -D billing
</pre>
<h2>Account Changes</h2>
<p>We’ve completed integration with Recurly so we can sign up new subscribers. Recurly will automatically bill their credit cards every month.</p>
<p>Our subscribers may need to make changes to their accounts. They may wish to change an email address or password, upgrade or downgrade a subscription plan, or change a credit card number.</p>
<p>Our “Edit account” page is very similar to the “New account” registration page. In its rudimentary form, it contains a simple form to change the user’s name, email address, or password. The <strong>app/views/devise/registrations/edit.html.erb</strong> file implements this feature using the Devise registrations controller. There’s no need to replace the existing form. We can use the existing form for changes to user name, email address, or password. We’ll add to this page to implement Recurly account changes.</p>
<p>Recurly provides a user-facing website where subscribers can change their credit card numbers. To make it easy for our subscribers to change a credit card number, we’ll add a link to the Recurly account page. We’re not storing credit card numbers in our application so there’s nothing more we need to do.</p>
<p>Changing subscription plans requires updating both our application User records and the Recurly account records. We’ll add a form to our “Edit Account” page and make changes to the registrations controller and User model to implement this functionality.</p>
<p>Get started by creating a new git branch for the account changes implementation:</p>
<pre>
$ git checkout -b change-acct
</pre>
<h3>Modify “Edit account” Page for “First Name” and “Last Name”</h3>
<p>Recurly customer accounts require both a first name and last name. We’ll modify the “Edit account” Page to add “First Name” and “Last Name”.</p>
<p>Modify the file <strong>app/views/devise/registrations/edit.html.erb</strong>.</p>
<p>Remove:</p>
<pre>
&lt;%= f.input :name, :autofocus =&gt; true %&gt;
</pre>
<p>and substitute:</p>
<pre>
&lt;%= f.input :first_name, :autofocus =&gt; true %&gt;
&lt;%= f.input :last_name %&gt;
</pre>
<p>Now the form matches the User model.</p>
<h3>Change the Style for the “Cancel My Account” Link on the “Edit account” Page</h3>
<p>We’re going to add small buttons using Twitter Bootstrap styles for our “Change Card” and “Change Plan” features.</p>
<p>Modify the file <strong>app/views/devise/registrations/edit.html.erb</strong>.</p>
<p>For stylistic consistency, replace the next statement with the following:</p>
<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete %&gt;.&lt;/p&gt;
</pre>

<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;
</pre>
<p>We’ve added a Twitter Bootstrap class that styles the “Cancel my account” link as a miniature button.</p>
<p>You can also remove the line:</p>
<pre>
&lt;%= link_to "Back", :back %&gt;
</pre>
<h3>Add a Link on the “Edit account” Page to “Change Card”</h3>
<p>For a “Change Card” feature, we’ll add a link to the user’s Recurly account page.</p>
<p>Modify the file <strong>app/views/devise/registrations/edit.html.erb</strong>. Add this code above the <code>&lt;h3&gt;Cancel my account&lt;/h3&gt;</code> statement:</p>
<pre>
&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Need to use a different credit card?
  &lt;a href="https://&lt;%= RECURLY_SUBDOMAIN %&gt;.recurly.com/" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;
</pre>
<p>This will add a link to the Recurly website. We apply a Twitter Bootstrap style to display the link as a button.</p>
<p>When the user visits the link, the user will see a page identified as “Subscription billing powered by Recurly.” They will enter their email address to receive a password to access their Recurly customer account. There are two limitations to this approach. First, the password they use for their Recurly customer account is different from the password they use to access your site. Second, the design of the Recurly customer account page will not be the same as your own site. If these limitations trouble you, you can implement your own “Change Card” functionality using the Recurly <span class="caps">API</span>. However, given the complexity of the additional code required to implement the alternative, and the fact that users will seldom need to change their credit cards, it is easier to simply provide a link to the Recurly customer account page.</p>
<h3>Add a Form to the “Edit account” Page to “Change Plan”</h3>
<p>Your site will likely have more than one subscription plan. Effective marketing often requires tiered plans at different price points. If so, you’ll want to provide an option for a user to upgrade plans. And they may want to downgrade plans, as well. When a subscriber changes subscription plans, we’ll need to inform Recurly as well as update our own user records.</p>
<p>Here’s where you’ll experience the benefits of using a billing service. Recurly manages all the complexity of prorating charges and issuing a credit or collecting additional fees (see details about <a href="https://docs.recurly.com/upgrades-downgrades">Recurly Upgrades and Downgrades</a>). If you were not using a billing service, you’d have to implement this complexity yourself.</p>
<p>To implement the “Change Plan” feature, we’ll add an additional form to the “Edit account” page. The form will be revealed as a modal window when a “Change plan” button is clicked.</p>
<p>First we’ll add a button that reveals the modal window containing the form.</p>
<p>Add this code before the <code>&lt;h3&gt;Cancel my account&lt;/h3&gt;</code> statement:</p>
<pre>
&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;
</pre>
<p>We display the name of the current subscription plan, which is derived from the roles object associated with the user. Rolify lets us set multiple roles (a feature we will not use in this application). We pick the first role (the only role), obtain its name, and “titleize” it to display it in titlecase. We add a link that is styled as a Twitter button. The link will open a Twitter Bootstrap modal window labeled “plan-options”, which we will add next.</p>
<p>Now we’ll add the code for the modal window containing a form. It doesn’t matter where the form is placed in the file as it will be hidden when the page is initially displayed and will appear as an overlay when revealed by a click on the appropriate link. For convenience, we’ll add it at the end of the file.</p>
<p>The form is identifed as “plan-options”:</p>
<pre>
&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name) , :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>We include this form in a div designated with the Twitter Bootstrap “modal” class. It will be displayed as an overlay when the user clicks the “Change plan” button.</p>
<p>We’re using helper methods provided by the <a href="http://simple-form.plataformatec.com.br/">simple_form gem</a>. It looks as if we <a href="http://guides.rubyonrails.org/form_helpers.html#binding-a-form-to-an-object">bind the form to an object</a> named “resource”; in fact, we bind the form to the User object. Devise abstracts the User object and names it “resource” which makes it possible to use objects with other names (such as Account or Member) in similar implementations. “Binding the form to the object” means the values for the form fields will be set with the attributes stored in the database.</p>
<p>The form has a section named “modal-header” that contains a link to close the modal window. We follow Twitter Bootstrap’s example and use <span class="caps">HTML</span> entity #215 (an “x” character) for the link.</p>
<p>The next section is named “modal-body” and it contains some of the most complex code we’ll use in this application.</p>
<p>We want to display a set of radio buttons that display a collection of all the subscription plans and, when selected, set a role id. A user’s subscription plan is encoded as a role id. Role ids are nested attributes of a User object and can be set as <code>user.role_ids</code>. So <code>:role_ids</code> is the first parameter we pass to the input field helper.</p>
<p>The input field helper wants a collection as the second parameter. We supply <code>Role.all</code> but we have to massage the list to remove the “admin” role. The Hash <code>delete_if</code> method is useful here. The block we supply to the <br><code>delete_if</code> method removes any role named “admin”.</p>
<p>We tell the input field helper we want to display the selection field as radio buttons. The <code>:item_wrapper_class =&gt; 'inline'</code> will display the radio buttons and labels horizontally.</p>
<p>The simple_form <code>label_method</code> parameter allows us to set a label for each radio button. If we didn’t set the <code>label_method</code>, the radio buttons would be labeled with an integer. We need to obtain the name attribute of each role and then apply the <code>titleize</code> method to display titlecase. The <code>label_method</code> parameter does not take a block but we can use a programming construct called an anonymous function (a Ruby language “lambda”) to manipulate the Role instance, obtaining the name attribute and making it titlecase, before passing it to the <code>label_method</code> parameter. This is a bit of advanced Ruby magic that is particularly useful here.</p>
<p>Confusingly, we set the <code>label</code> parameter to false. If we didn’t do this, the entire field would be automatically labelled “Roles.”</p>
<p>Finally, the form has a section named “modal-footer” that contains a submit button and another link to close the modal window.</p>
<p>Here’s the complete version of the file <strong>app/views/devise/registrations/edit.html.erb</strong>:</p>
<pre>
&lt;h2&gt;Account&lt;/h2&gt;
&lt;div id="card_error" class="alert alert-error" style="display:none" &gt;&lt;/div&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; { :method =&gt; :put, :class =&gt; 'form-vertical' }) do |f| %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :first_name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :last_name %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :autocomplete =&gt; "off", :hint =&gt; "leave it blank if you don't want to change it", :required =&gt; false %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; false %&gt;
  &lt;%= f.input :current_password, :hint =&gt; "we need your current password to confirm your changes", :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Update', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;

&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Need to use a different credit card?
  &lt;a href="https://&lt;%= RECURLY_SUBDOMAIN %&gt;.recurly.com/" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Cancel my account&lt;/h3&gt;

&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;

&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; update_plan_path, :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>There’s a lot of new code in the Devise user edit view. To accommodate the “Change Plan” feature we will need to improve the registrations controller, the users controller, and the User model. First we will modify the User model to accommodate the “Cancel my account” feature.</p>
<h3>Modify the User Model for Subscription Cancellations</h3>
<p>It’s easy to handle a subscription cancellation request. Devise does the work of deleting the user account and we just piggyback on the Devise registration controller action with a <code>before_destroy</code> callback so we can notify Recurly to cancel subscription billing.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :card_token, :customer_id
  attr_accessor :card_token
  before_create :check_recurly
  before_destroy :cancel_subscription

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end

  def check_recurly
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Recurly::Account.find(customer_id)
      subscription = customer.subscriptions.first unless customer.nil?
      if (!subscription.nil?) &amp;&amp; (subscription.state == 'active')
        subscription.cancel
      end
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}"
    false
  end

end
</pre>
<p>We’ve added a <code>cancel_subscription</code> method that is activated by the <code>before_destroy</code> callback. The method uses the Recurly <span class="caps">API</span> to obtain a Recurly customer object and then initiates a subscription cancellation call. We return false to cancel the <code>destroy</code> action if Recurly returns an error.</p>
<p>The <code>cancel_subscription</code> method only takes action if the user has a Recurly id. You may want to delete the example users created by the <code>db:seed</code> process. The example users don’t have a Recurly id and the <code>destroy</code> action would fail for them unless we make the <code>cancel_subscription</code> method conditional. We also make sure the Recurly customer exists and has an active subscription before attempting to cancel the subscription.</p>
<h3>Modify the User Model for Subscription Plan Changes</h3>
<p>As implemented, either the user or the administrator can upgrade or downgrade a user’s subscription plan and the change will be recorded in the application’s roles datatable. However, we need to inform Recurly when a subscription plan changes. Recurly will pro-rate the plan cost and refund or bill the price difference (or optionally, wait until the next billing cycle to change the billed rate).</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :card_token, :customer_id
  attr_accessor :card_token
  before_create :check_recurly
  before_destroy :cancel_subscription

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end

  def check_recurly
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    false
  end

  def update_plan(role)
    self.role_ids = []
    self.add_role(role.name)
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
    unless customer.nil?
      subscription = customer.subscriptions.first
      subscription.update_attributes! :timeframe =&gt; 'now', :plan_code =&gt; role.name
    end
  rescue Recurly::Resource::Invalid =&gt; e
    logger.error e.message
    errors.add :base, "Unable to update your subscription. #{e.message}"
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Recurly::Account.find(customer_id)
      subscription = customer.subscriptions.first unless customer.nil?
      if (!subscription.nil?) &amp;&amp; (subscription.state == 'active')
        subscription.cancel
      end
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}"
    false
  end

end

</pre>
<p>We add the <code>update_plan</code> method for resetting the role. Rolify supports multiple roles (though we only use a single role in this application) and we must remove an existing role before adding a new role. Then we obtain a customer object with a call to Recurly, make sure the user has a Recurly customer account, and call the Recurly <code>subscription.update_attributes!</code> method.</p>
<p>With these changes, the User model can update the Recurly customer account when a user or administrator changes a subscription plan.</p>
<h3>Modify the Registrations Controller for Subscription Plan Changes</h3>
<p>The registrations controller handles requests when the user submits the edit form.</p>
<p>We will add an <code>update_plan</code> action to the registrations controller to accommodate the “Change Plans” features.</p>
<p>It would be nice to keep the controller completely RESTful and not add any new actions, replacing the <code>update</code> method to handle submissions of two different forms (changing the plan and updating name/email/password). However, the <code>update</code> method supplied by Devise is quite complex, with logic that forces the user to enter the current password to authorize any changes. We don’t want to ask the user to enter a password to change the plan, so we’ll leave the <code>update</code> method untouched (for changing name/email/password) and add a new <code>update_plan</code> method.</p>
<p>Modify the file <strong>app/controllers/registrations_controller.rb</strong>:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    if @plan
      @signature = Recurly.js.sign :subscription =&gt; { :plan_code =&gt; @plan }
      super
    else
      redirect_to root_path, :notice =&gt; 'Please select a subscription plan below'
    end
  end

  def update_plan
    @user = current_user
    role = Role.find(params[:user][:role_ids]) unless params[:user][:role_ids].nil?
    if @user.update_plan(role)
      redirect_to edit_user_registration_path, :notice =&gt; 'Updated plan.'
    else
      flash.alert = 'Unable to update plan.'
      render :edit
    end
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
    resource.customer_id ||= SecureRandom.uuid
  end
end
</pre>
<p>Not every request will require a change of subscription plan. Sometimes the user will be submitting a form to change name, email address, or password. In that case, the inherited <code>update</code> method from the Devise registrations controller will be invoked.</p>
<p>The <code>update_plan</code> method applies changes to the <code>current_user</code> (note that changes by an administrator are accommodated elsewhere by the User controller). We identify the new role that is specified in the form and call the User <code>update_plan(role)</code> method. That method will make a request to Recurly to update the customer account. Recurly will automatically apply refunds or additional charges as necessary. The User <code>update_plan(role)</code> method returns <code>true</code> on a successful update or throws an error if an attempt to reach the Recurly server fails. On a successful update we redirect to the edit page with a status message. On a failure we render the edit page, showing any errors with the <code>display_base_errors</code> view helper.</p>
<h3>Add Routes for Account Changes</h3>
<p>We’ve added a new action to the registrations controller to accommodate the “Change Plans” feature. We need to add a route to invoke the new action.</p>
<p>Modify the <strong>config/routes.rb</strong> file to add the new route:</p>
<pre>
RailsRecurlySubscriptionSaas::Application.routes.draw do
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  devise_scope :user do
    put 'update_plan', :to =&gt; 'registrations#update_plan'
  end
  resources :users
end
</pre>
<p>The <code>devise_scope</code> method <a href="http://rdoc.info/github/plataformatec/devise/ActionDispatch/Routing/Mapper:devise_scope">(see <span class="caps">API</span>)</a> applies <a href="http://rubydoc.info/github/plataformatec/devise/master/Devise/Mapping">Devise.mappings</a> so the new routes are associated with other routes specified by <code>devise_for</code> <a href="http://rubydoc.info/github/plataformatec/devise/master/ActionDispatch/Routing/Mapper#devise_for-instance_method">(see <span class="caps">API</span>)</a>. Our Registrations controller subclasses the Devise Registrations controller and it will raise an “Unknown action” error if the scope is not set by <code>devise_scope</code>. Note that <code>devise_for</code> takes a <code>:users</code> argument (plural) and <code>devise_scope</code> takes a <code>:user</code> argument (singular).</p>
<p>We add the <code>update_plan</code> route to respond to an <span class="caps">HTTP</span> “put” request (a form submission). This generates the route that we use in our “Change Plans” form:</p>
<ul>
<li>update_plan_path</li>
</ul><p>Our “Change Plans” feature is now ready for the user.</p>
<p>We’ll add one more feature. We want to allow the administrator to change a subscription plan for any user.</p>
<h3>Modify the User Controller for Subscription Plan Changes</h3>
<p>The users controller handles requests when an administrator changes the user’s subscription plan.</p>
<p>We need to modify the <code>update</code> method in the users controller to make sure Recurly’s customer records are updated when an administrator makes a change.</p>
<p>Modify the file <strong>app/controllers/users_controller.rb</strong>:</p>
<pre>
class UsersController &lt; ApplicationController
  before_filter :authenticate_user!

  def index
    authorize! :index, @user, :message =&gt; 'Not authorized as an administrator.'
    @users = User.all
  end

  def show
    @user = User.find(params[:id])
  end
  
  def update
    authorize! :update, @user, :message =&gt; 'Not authorized as an administrator.'
    @user = User.find(params[:id])
    role = Role.find(params[:user][:role_ids]) unless params[:user][:role_ids].nil?
    params[:user] = params[:user].except(:role_ids)
    if @user.update_attributes(params[:user])
      @user.update_plan(role) unless role.nil?
      redirect_to users_path, :notice =&gt; "User updated."
    else
      redirect_to users_path, :alert =&gt; "Unable to update user."
    end
  end
    
  def destroy
    authorize! :destroy, @user, :message =&gt; 'Not authorized as an administrator.'
    user = User.find(params[:id])
    unless user == current_user
      user.destroy
      redirect_to users_path, :notice =&gt; "User deleted."
    else
      redirect_to users_path, :notice =&gt; "Can't delete yourself."
    end
  end
end
</pre>
<p>The <code>update</code> action is more complex than the actions we added to the registrations controller because we are updating all attributes with a single action. The <code>authorize!</code> uses CanCan to make sure only the administrator can invoke the update. We find the name of the requested role if a <code>params[:user][:role_ids]</code> parameter exists. We strip away the <code>params[:user][:role_ids]</code> parameter to avoid mass assignment errors. Then we call <code>update_attributes</code>. If the User object successfully saves the new attributes, we call the <code>User.update_plan</code> method to change the subscription plan in both the application role table and the remote Recurly customer account.</p>
<p>Now an administrator can change subscription plans and Recurly will update the customer account and apply refunds or additional charges as necessary.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "accommodate changes to account"
$ git checkout master
$ git merge --squash change-acct
$ git commit -m "accommodate changes to account"
$ git branch -D change-acct
</pre>
<h2>Recurly Push Notifications</h2>
<p>What happens when a credit card expires or a monthly transaction is declined? Recurly will automatically retry a recurring payment after it fails and send notification emails to the customer. After a number of attempts (set in your Recurly “Dunning Management” settings), Recurly will cancel the subscription. But how will your application know to deny access for a subscriber with an expired account? Recurly provides <a href="http://en.wikipedia.org/wiki/Webhook">webhooks</a> (push notifications) to communicate events to you (for details, see the <a href="http://docs.recurly.com/push-notifications">Recurly Push Notifications documentation</a> and <a href="http://docs.recurly.com/api/push-notifications">Recurly Push Notifications <span class="caps">API</span></a>).</p>
<p>A Recurly push notification is an <span class="caps">HTTP</span> request from Recurly’s servers to your site. It is not a visit to your website from a web browser; rather it is an <span class="caps">HTTP</span> <span class="caps">POST</span> request (like a form submission) to your application from the Recurly servers. The <span class="caps">HTTP</span> request contains <span class="caps">XML</span> data that provides data about the event, including a customer account code that can be used to retrive the data from the Recurly server. It is best to ignore the event data (because it could be falsified) and query the Recurly server to obtain the subscription status.</p>
<p>There are a few ways we could handle push notifications. We could use the existing Registrations or Users controller, adding a new non-RESTful action to process the push notifications. Instead we will create a new controller with a new action to process push notifications.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b webhooks
</pre>
<h3>Create a Recurly Controller</h3>
<p>You could use the <code>rails generate</code> command to create a controller but we don’t need views so it is easiest to just create a new file for the controller.</p>
<p>Create a file <strong>app/controllers/recurly_controller.rb</strong>:</p>
<pre>
class RecurlyController &lt; ApplicationController
  protect_from_forgery :except =&gt; :push

  def push
    notification = Hash.from_xml(request.body())
    render :text =&gt; "Request accepted."
    if notification.has_key?('expired_subscription_notification')
      account_code = notification['expired_subscription_notification']['account']['account_code']
      logger.info "Recurly push notification: expired_subscription_notification for account #{account_code}"
      customer = Recurly::Account.find(account_code)
      subscription = customer.subscriptions.first unless customer.nil?
      if (!subscription.nil?) &amp;&amp; (subscription.state == 'expired')
        user = User.find_by_customer_id(account_code)
        user.expire unless user.nil?
      end
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error "Recurly: #{e.message}"
  rescue ActiveRecord::RecordNotFound =&gt; e
    logger.error "Customer record not found: #{e.message}"
  end
  
end
</pre>
<p>There’s no need to make this a RESTful controller (with actions such as <code>index</code>, <code>update</code>, etc.) as we are just responding to one type of request. We can give any name to the action; we’ll call it <code>push</code>.</p>
<p>The action will respond to an <span class="caps">HTTP</span> <span class="caps">POST</span> request, equivalent to receiving a form submission. Ordinarily, all Rails controllers expect to find an <code>authenticity_token</code> parameter in a <span class="caps">POST</span> request that is automatically generated as a hidden field in any form by the Rails form helpers. The Rails controller <code>protect_from_forgery</code> method adds a <code>before_filter</code> called <code>verify_authenticity_token</code> to all actions. It will compare the <code>authenticity_token</code> parameter against an ID stored in the session variable. If they differ, the action will not be executed. This provides protection from Cross-Site Request Forgery (<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery"><span class="caps">CSRF</span></a>) attacks. Recurly can’t provide an authenticity token so we will disable <span class="caps">CSRF</span> protection for the <code>push</code> action with the statement <code>protect_from_forgery :except =&gt; :push</code>.</p>
<p>Recurly provides event data in the form of an <span class="caps">XML</span> document. We really don’t want to write code to parse the <span class="caps">XML</span> data (that’s a 1990s exercise); fortunately, Ruby’s Hash class give us a <code>from_xml</code> method that will create a hash from the <span class="caps">HTTP</span> request body. We let the Recurly server know that we’ve received the request by rendering a simple text message (all Recurly actually needs is an <span class="caps">HTTP</span> 200 status code). If we don’t give a response, Recurly will retry ten times before giving up.</p>
<p>Recurly will send push notifications for every customer event. We only care about an “expired_subscription_notification” event; we’ll ignore the rest. We check if the hash contains a “expired_subscription_notification” key and look for an account code. With the account code, we can make a request to Recurly for a customer object and look for a subscription. The <code>subscription.state</code> method should indicate the subscriptiuon is expired. If it is, we’ll find the user and call the <code>user.expire</code> method.</p>
<p>The <code>user.expire</code> method doesn’t yet exist. We’ll add it after we add a route for the new action.</p>
<h3>Add a Route for the Push Notifications</h3>
<p>We’ve added a new actions to the Recurly controller to accommodate push notifications. We need to add a route to invoke the new action.</p>
<p>Modify the <strong>config/routes.rb</strong> file to add a route:</p>
<pre>
RailsRecurlySubscriptionSaas::Application.routes.draw do
  post "recurly/push"
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  devise_scope :user do
    put 'update_plan', :to =&gt; 'registrations#update_plan'
  end
  resources :users
end
</pre>
<p>The route <code>post "recurly/push"</code> will invoke the Recurly controller’s <code>push</code> action to respond to requests to the <span class="caps">URL</span>:</p>
<ul>
<li>http://www.example.com/recurly/push</li>
</ul><p>You’ll need to set this <span class="caps">URL</span> in your Recurly “Push Notifications” settings.</p>
<h3>Add an Expire Method to the User Model</h3>
<p>Now that our application responds to push notifications from Recurly, we must consider how to process an expired  customer subscription.</p>
<p>There are several possible approaches to handling an expired subscription. One option is to keep the customer record and change the subscription plan to a role named “expired” or something similar. If we did that, we’d have to provide a form to allow an expired subscriber to log in, change a credit card, and update the subscription. It’s easier to simply delete the account and expect the user to create a new account to re-subscribe.</p>
<p>When a user visits the website and cancels a subscription, we delete the customer record. Similarly, we could simply delete the customer record when a subscription expires. Instead we can encourage the user to resubscribe by notifying the user with an email message when the subscription has ended due to a payment failure. We’ll add a custom <code>expire</code> method to our User class that will send an email message before deleting the user.</p>
<p>Modify the file <strong>app/models/user.rb</strong> to add an <code>expire</code> method:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :first_name, :last_name, :email, :password, :password_confirmation, :remember_me, :card_token, :customer_id
  attr_accessor :card_token
  before_create :check_recurly
  before_destroy :cancel_subscription

  def name
    name = "#{first_name.capitalize} #{last_name.capitalize}"
  end

  def check_recurly
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    false
  end

  def update_plan(role)
    self.role_ids = []
    self.add_role(role.name)
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
    unless customer.nil?
      subscription = customer.subscriptions.first
      subscription.update_attributes! :timeframe =&gt; 'now', :plan_code =&gt; role.name
    end
    true
  rescue Recurly::Resource::Invalid =&gt; e
    logger.error e.message
    errors.add :base, "Unable to update your subscription. #{e.message}"
    false
  end

  def update_recurly
    customer = Recurly::Account.find(customer_id) unless customer_id.nil?
    unless customer.nil?
      customer.email = email
      customer.first_name = first_name
      customer.last_name = last_name
      customer.save!
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to update your subscription. #{e.message}"
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Recurly::Account.find(customer_id)
      subscription = customer.subscriptions.first unless customer.nil?
      if (!subscription.nil?) &amp;&amp; (subscription.state == 'active')
        subscription.cancel
      end
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}"
    false
  end

  def expire
    UserMailer.expire_email(self).deliver
    destroy
  end
  
end
</pre>
<p>Our new <code>expire</code> method is simple. We call a method on an ActionMailer method to send an email. Then we destroy the user.</p>
<h3>Send an Expiration Email</h3>
<p>We’ll use an ActionMailer method to send an email when we receive a Recurly push notification indicating a subscription has been cancelled for payment failure.</p>
<p>Generate a mailer with accompanying views:</p>
<pre>
$ rails generate mailer UserMailer
</pre>
<p>Add an <code>expire_email</code> method to the mailer by editing the file <strong>app/mailers/user_mailer.rb</strong>:</p>
<pre>
class UserMailer &lt; ActionMailer::Base
  default :from =&gt; "notifications@example.com"
  
  def expire_email(user)
    mail(:to =&gt; user.email, :subject =&gt; "Subscription Cancelled")
  end
end
</pre>
<p>Replace the “notifications@example.com” string with your email address.</p>
<p>Create a mailer view by creating a file <strong>app/views/user_mailer/expire_email.html.erb</strong>. This will be the template used for the email, formatted in <span class="caps">HTML</span>:</p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Subscription Cancelled&lt;/h1&gt;
    &lt;p&gt;
      Your subscription has been cancelled.
    &lt;/p&gt;
    &lt;p&gt;
      We are sorry to see you go. We'd love to have you back. 
      Visit example.com anytime to create a new subscription.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It is a good idea to make a text-only version for this message. Create a file  <strong>app/views/user_mailer/expire_email.text.erb</strong>:</p>
<pre>
Subscription Cancelled

Your subscription has been cancelled.
 
We are sorry to see you go. We'd love to have you back. 
Visit example.com anytime to create a new subscription.
</pre>
<p>When you call the mailer method, ActionMailer will detect the two templates (text and <span class="caps">HTML</span>) and automatically generate a multipart/alternative email. If you use the Mandrill email service, you can skip this step if you configure Mandrill to automatically generate a plain-text version of all emails.</p>
<p>Now the User model is equipped to send an email message when a Recurly push notification notifies the application of a cancelled subscription.</p>
<h3>Set Your Push Notification <span class="caps">URL</span> in Your Recurly Account Settings</h3>
<p>After you’ve implemented handling of Recurly push notifications, you need to set your <span class="caps">URL</span> in your Recurly account settings.</p>
<p>Visit your Recurly dashboard and enter the <span class="caps">URL</span> in your “Push Notifications” settings:</p>
<ul>
<li>http://www.example.com/recurly/push</li>
</ul><p>There’s no easy way to test the push notifications directly from Recurly until after you deploy, since the Recurly servers won’t find your application at <a href="http://localhost:3000/recurly/push">http://localhost:3000/recurly/push</a>. But we can create a test harness you can use to test push notifications locally.</p>
<h3>Faking a Push Notification in Development</h3>
<p>The code we’ve provided in the tutorial should work as implemented (if it doesn’t, check the GitHub issues for this application). If you’re having problems, or you’d like to extend the application with responses to other push notofications, it’d be nice to have some code that would invoke the controller’s <code>push</code> action.</p>
<p>We can do that by adding a new <code>test</code> action to the Recurly controller.</p>
<pre>
class RecurlyController &lt; ApplicationController
  protect_from_forgery :except =&gt; :push

  def push
    notification = Hash.from_xml(request.body())
    render :text =&gt; "Request accepted."
    if notification.has_key?('expired_subscription_notification')
      account_code = notification['expired_subscription_notification']['account']['account_code']
      logger.info "Recurly push notification: expired_subscription_notification for account #{account_code}"
      customer = Recurly::Account.find(account_code)
      subscription = customer.subscriptions.first unless customer.nil?
      if (!subscription.nil?) &amp;&amp; (subscription.state == 'expired')
        user = User.find_by_customer_id(account_code)
        user.expire unless user.nil?
      end
    end
  rescue Recurly::Resource::NotFound =&gt; e
    logger.error "Recurly: #{e.message}"
  rescue ActiveRecord::RecordNotFound =&gt; e
    logger.error "Customer record not found: #{e.message}"
  end

  def test
    xml = &lt;&lt;XML
&lt;expired_subscription_notification&gt;
  &lt;account&gt;
    &lt;account_code&gt;1&lt;/account_code&gt;
    &lt;username nil="true"&gt;&lt;/username&gt;
    &lt;email&gt;verena@example.com&lt;/email&gt;
    &lt;first_name&gt;Verena&lt;/first_name&gt;
    &lt;last_name&gt;Example&lt;/last_name&gt;
    &lt;company_name nil="true"&gt;&lt;/company_name&gt;
  &lt;/account&gt;
  &lt;subscription&gt;
    &lt;plan&gt;
      &lt;plan_code&gt;1dpt&lt;/plan_code&gt;
      &lt;name&gt;Subscription One&lt;/name&gt;
    &lt;/plan&gt;
    &lt;uuid&gt;d1b6d359a01ded71caed78eaa0fedf8e&lt;/uuid&gt;
    &lt;state&gt;expired&lt;/state&gt;
    &lt;quantity type="integer"&gt;1&lt;/quantity&gt;
    &lt;total_amount_in_cents type="integer"&gt;200&lt;/total_amount_in_cents&gt;
    &lt;activated_at type="datetime"&gt;2010-09-23T22:05:03Z&lt;/activated_at&gt;
    &lt;canceled_at type="datetime"&gt;2010-09-23T22:05:43Z&lt;/canceled_at&gt;
    &lt;expires_at type="datetime"&gt;2010-09-24T22:05:03Z&lt;/expires_at&gt;
    &lt;current_period_started_at type="datetime"&gt;2010-09-23T22:05:03Z&lt;/current_period_started_at&gt;
    &lt;current_period_ends_at type="datetime"&gt;2010-09-24T22:05:03Z&lt;/current_period_ends_at&gt;
    &lt;trial_started_at nil="true" type="datetime"&gt;
    &lt;/trial_started_at&gt;&lt;trial_ends_at nil="true" type="datetime"&gt;&lt;/trial_ends_at&gt;
  &lt;/subscription&gt;
&lt;/expired_subscription_notification&gt;
XML
    test_request = HTTPI::Request.new(recurly_push_url)
    test_request.open_timeout = 1 # seconds
    test_request.read_timeout = 1
    test_request.headers = { "Content-Type" =&gt; "text/xml" }
    test_request.body = xml
    test_response = HTTPI.post(test_request)
    render :text =&gt; "Check server log for result of request to #{recurly_push_url}"
  rescue HTTPClient::ReceiveTimeoutError
    logger.info "Testing push notification listener: sent XML to #{recurly_push_url}"
    render :text =&gt; "Check server log for result of request to #{recurly_push_url}"
  end
end
</pre>
<p>The new action creates an <span class="caps">XML</span> document that matches a Recurly “expired_subscription_notification” push notification (see the <a href="http://docs.recurly.com/api/push-notifications">Recurly Push Notifications <span class="caps">API</span></a>). Then we construct an <span class="caps">HTTP</span> request, specifying the “Content-Type” as “text/xml” and using the <span class="caps">XML</span> document as the request body. We use the HTTPClient library to send the request to the <span class="caps">URL</span> formed by the recurly_push_url route.</p>
<p>This fully meets the definition of a hack. As soon as you add a route to the <strong>config/routes.rb</strong> file, you can fake a Recurly push notification.</p>
<h3>Add a Route to Test Push Notifications</h3>
<p>We’ve added an action to the Recurly controller to test push notifications. We need to add a route to invoke the new action.</p>
<p>Modify the <strong>config/routes.rb</strong> file to add a route:</p>
<pre>
RailsRecurlySubscriptionSaas::Application.routes.draw do
  get "recurly/test"
  post "recurly/push"
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  devise_scope :user do
    put 'update_plan', :to =&gt; 'registrations#update_plan'
  end
  resources :users
end
</pre>
<p>The route <code>get "recurly/test"</code> will invoke the Recurly controller’s <code>push</code> action when you enter this <span class="caps">URL</span> in the browser:</p>
<ul>
<li><a href="http://localhost:3000/recurly/test">http://localhost:3000/recurly/test</a></li>
</ul><p>Use it for simple testing of push notifications in development. You won’t see a response in the browser but you can dig into the server log to see the application’s response to the request.</p>
<h3>Testing a Recurly Push Notification in Production</h3>
<p>It’s not easy to test a Recurly push notification in production.</p>
<p>The most expedient test is to deploy the application on a production web server and trigger an actual event in “Test” mode by creating a customer and then canceling a subscription. If you are not getting the results you expect, you can include the debugging statements in the <strong>app/controllers/recurly_controller.rb</strong> file:</p>
<pre>
def push
  logger.info request.body()
  notification = Hash.from_xml(request.body())
.
.
.
end
</pre>
<p>The debug code should show you the results of any push notification request in your log file.</p>
<p>You can use the <a href="http://requestb.in/">RequestBin</a> service to see what Recurly is sending. RequestBin lets you create a <span class="caps">URL</span> that will collect requests made to it, then lets you inspect the request headers and body.</p>
<p>If you need to test actual push notifications from Recurly on your local development machine, you can install the <a href="http://progrium.com/localtunnel/">localtunnel gem</a> (<a href="https://github.com/progrium/localtunnel">localtunnel on GitHub</a>) which will expose your local web server to the Internet so you can receive push notifications from the Recurly servers.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add Recurly webhooks"
$ git checkout master
$ git merge --squash webhooks
$ git commit -m "add Recurly webhooks"
$ git branch -D webhooks
</pre>
<h2>Customize, Test, and Deploy</h2>
<h3>Additional Features</h3>
<p>You’ve created a fully functional membership site that’s ready to take credit card payments and serve access to restricted content.</p>
<p>It uses Recurly for payment processing, allows users to change credit cards or subscription plans, and uses Recurly webhooks to delete users who have expired or declined credit cards.</p>
<p>If you have suggestions for additional features, please create an <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/issues">issue</a> on GitHub.</p>
<h3>Cleanup</h3>
<p>Several unneeded files are generated in the process of creating a new Rails application.</p>
<p>Additionally, you may want to prevent search engines from indexing your website if you’ve deployed it publicly while still in development.</p>
<p>See instructions for <a href="http://railsapps.github.com/rails-cleanup.html">cleaning up unneeded files in Rails and banning spiders</a>.</p>
<h3>Test the App</h3>
<p>You can check that your app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>.</p>
<p>Sign in as the first user (the administrator) using:</p>
<ul>
<li>email: user@example.com</li>
	<li>password: please</li>
</ul><p>You’ll see a navigation link for Admin. Clicking the link will display a page with a list of users at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<p>To sign in as the second user, use</p>
<ul>
<li>email: user2@example.com</li>
	<li>password: please</li>
</ul><p>The second user will not see the Admin navigation link and will not be able to access the page at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<p>You should be able to create additional users. If you use “example.com” in an email address in development or testing, the application will not connect with Recurly. Use a different email address with a fake credit card number to test subscribing using Recurly. You’ll see the new users listed when you log in as an administrator. And you’ll see the new users listed as customers when you visit your Recurly dashboard.</p>
<p>Stop the server with Control-C.</p>
<h3>Testing</h3>
<p>If you’ve copied the RSpec unit tests and Cucumber integration tests from the  <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/">rails-recurly-subscription-saas</a> example application, you can run <code>rake -T</code> to check that rake tasks for RSpec and Cucumber are available.</p>
<p>Run <code>rake spec</code> to run all RSpec tests.</p>
<p>Run <code>rake cucumber</code> (or more simply, <code>cucumber</code>) to run all Cucumber scenarios.</p>
<h3>Deploy to Heroku</h3>
<p>For your convenience, here is a <a href="http://railsapps.github.com/rails-heroku-tutorial.html">Tutorial for Rails on Heroku</a>. Heroku provides low cost, easily configured Rails application hosting.</p>
<p>Be sure to set up <span class="caps">SSL</span> before you make your application available in production. See the <a href="https://devcenter.heroku.com/articles/ssl">Heroku documentation on <span class="caps">SSL</span></a>.</p>
<p>You’ll need to set the configuration values from the <strong>config/application.yml</strong> file as Heroku environment variables. See the article <a href="http://railsapps.github.com/rails-environment-variables.html">Rails Environment Variables</a> for more information.</p>
<p>With the figaro gem, just run:</p>
<pre>
rake figaro:heroku
</pre>
<p>Alternatively, you can set Heroku environment variables for your Recurly <span class="caps">API</span> and private key like this:</p>
<pre>
$ heroku config:add RECURLY_API_KEY=secret RECURLY_JS_PRIVATE_KEY=secret RECURLY_SUBDOMAIN=mydomain
</pre>
<p>Prior to deployment, it’s advisable to change your <strong>db/seeds.rb</strong> file. At a minimum, remove the “example.com” sample users. Optionally, you can change the administrator name, email and password though it is better to wait and change the values through the application “Edit account” interface later.</p>
<pre>
puts 'ROLES'
YAML.load(ENV['ROLES']).each do |role|
  Role.find_or_create_by_name({ :name =&gt; role }, :without_protection =&gt; true)
  puts 'role: ' &lt;&lt; role
end
puts 'DEFAULT USERS'
user = User.find_or_create_by_email :first_name =&gt; ENV['ADMIN_FIRST_NAME'].dup, :last_name =&gt; ENV['ADMIN_LAST_NAME'].dup, :email =&gt; ENV['ADMIN_EMAIL'].dup, :password =&gt; ENV['ADMIN_PASSWORD'].dup, :password_confirmation =&gt; ENV['ADMIN_PASSWORD'].dup
puts 'user: ' &lt;&lt; user.name
</pre>
<p>If you don’t remove the “example.com” sample users, <code>rake db:seed</code> will fail with errors if you attempt to run it on Heroku after deployment, since you are not supplying a credit card for Recurly for these users.</p>
<h2>Comments</h2>
<h3>Credits</h3>
<p>Daniel Kehoe implemented the application and wrote the tutorial.</p>
<h3>Did You Like the Tutorial?</h3>
<p>Was this useful to you? Follow <a href="http://twitter.com/rails_apps">rails_apps</a> on Twitter and tweet some praise. I’d love to know you were helped out by the tutorial.</p>
<p>Get some link juice! Add your website to the list of <a href="http://railsapps.github.com/rails-applications-from-examples.html">Rails Applications Built from the Examples</a>. I love to see what people have built with these examples.</p>
<p>Any issues? Please create an <a href="http://github.com/RailsApps/rails-recurly-subscription-saas/issues">issue</a> on GitHub. Reporting (and patching!) issues helps everyone.</p>
    </div><!-- class="content" -->
    
    <div class="comments">
      <div class="content wikistyle gollum">
        <h2>Comments</h2>
      </div>
      <p>Is this helpful? Your encouragement fuels the project. Please tweet or add a comment. Couldn't get something to work? For the example apps and tutorials, it's best to open an issue on GitHub so we can help you.</p> 
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'railsapps'; // required: replace example with your forum shortname
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div><!-- class="comments" -->

    <div class="footer row">
      <div class="span4">
      </div>
    
      <div class="span4">
       </div>

      <div class="span4">
      </div>
    </div>

  </div>
            
  </body>
</html>
