<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Rails Tutorial &#183; Membership Subscription or SaaS Site with Stripe &#183; RailsApps</title>
    <link href="https://plus.google.com/u/0/b/117374718581973393536/117374718581973393536/posts/" rel="publisher" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/bootstrap.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/site.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/syntax.css" type="text/css" charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.6.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/gollum.js" type="text/javascript"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-5109366-14']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a href="http://railsapps.github.com/" class="brand">RailsApps Project</a>
        <ul class="pull-right nav">
          <li><a href="http://blog.railsapps.org/" class="twitter">Blog</a></li>
          <li><a href="http://twitter.com/rails_apps" class="twitter">Twitter</a></li>
          <li><a href="https://plus.google.com/117374718581973393536" class="google">Google +</a></li>
          <li><a href="https://github.com/RailsApps" class="github">GitHub Repository</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container"> 

    <div class="content wikistyle gollum textile">
      <h1>Rails Tutorial for a Membership, Subscription, or SaaS Site with Stripe</h1>
<h4>by Daniel Kehoe</h4>
<p><em>Last updated 22 December 2012</em></p>
<h2>Introduction</h2>
<p>Ruby on Rails tutorial for a web application with recurring billing using Stripe. Use for a Rails membership site, subscription site, or SaaS site (software-as-a-service).</p>
<ul>
<li>
<a href="https://stripe.com/">Stripe</a> for recurring billing</li>
	<li>
<a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication</li>
	<li>
<a href="https://github.com/ryanb/cancan">CanCan</a> with <a href="https://github.com/EppO/rolify">Rolify</a> for authorization</li>
	<li>
<a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a> front-end framework for <span class="caps">CSS</span> styling</li>
</ul><h3>Screenshot</h3>
<p><img src="http://railsapps.github.com/images/rails-stripe-membership-saas.png" title="Rails Application for a Membership, Subscription, or SaaS Site" alt="Rails Application for a Membership, Subscription, or SaaS Site"></p>
<p>This example application exists so you don’t have to build it yourself. It aims to:</p>
<ul>
<li>eliminate effort spent building an application that meets a common need;</li>
	<li>offer code that is already implemented and tested by a large community;</li>
	<li>provide a well-thought-out app containing most of the features you’ll need.</li>
</ul><p>Membership sites restrict access to content such as articles, videos, or user forums. Software-as-a-service (SaaS) sites limit use of web-based software to paid subscribers. The revenue model is the same whether the site provides high-value content or software as a service: A visitor purchases a subscription and gains access to restricted areas of the site. Typically, the subscription is repurchased monthly through a service that provides recurring billing.</p>
<h3>Functionality</h3>
<p>If you’re planning to build a SaaS application, a membership site, or some other subscription-based web service, your application will need the following rudimentary functionality:</p>
<ul>
<li>content or web functionality to deliver value</li>
	<li>landing pages to convert visitors to paying customers</li>
	<li>user management to register or remove users</li>
	<li>access control to limit site-wide access to authenticated users</li>
	<li>authorization management to restrict access to content or services based on role or other characteristics</li>
	<li>account management to maintain records of subscription status</li>
	<li>a recurring billing system for periodic payment transactions</li>
</ul><h3>Features</h3>
<p>The example application provides a complete and fully functional membership site.</p>
<ul>
<li>tiered pricing for multiple subscription plans</li>
	<li>optional “free trial” subscription as well as free accounts using Stripe</li>
	<li>uses Stripe for no local credit card storage</li>
	<li>Stripe accepts credit card payments from customers in any country or currency</li>
	<li>
<span class="caps">PCI</span> compliance using the Stripe JavaScript library</li>
	<li>Stripe handles recurring billing, retries if payment fails, and cancels subscription if retries fail</li>
	<li>paid subscriptions are created only after a successful credit card transaction</li>
	<li>subscribers can upgrade or downgrade subscription plans</li>
	<li>subscribers can cancel subscription plans</li>
	<li>configurable subscription renewal period (defaults to one month)</li>
	<li>administrator can change subscription plan or delete user</li>
</ul><h3>What is Not Implemented</h3>
<p>There are additional features you may want for a SaaS application, such as:</p>
<ul>
<li>Basecamp-style subdomains (each user gets their own subdomain)</li>
	<li>
<a href="http://en.wikipedia.org/wiki/Multitenancy">multitenancy</a> database segmentation</li>
</ul><p>These features are not included in this application. See the <a href="https://github.com/RailsApps/rails3-subdomains">rails3-subdomains</a> example application for help with subdomains. For multitenancy, try Brad Robertson’s <a href="https://github.com/bradrobertson/apartment">Apartment</a> gem.</p>
<h3>About the Gems</h3>
<p>RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a “gem”). Gems add functionality to a Rails app.</p>
<p>We use these gems:</p>
<ul>
<li>
<a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication</li>
	<li>
<a href="https://github.com/ryanb/cancan">CanCan</a> with <a href="https://github.com/EppO/rolify">Rolify</a> for authorization</li>
	<li>
<a href="https://stripe.com/">Stripe</a> for recurring billing</li>
</ul><h4>Devise</h4>
<p>Devise provides authentication, a system to securely identify users, making sure the user is who he represents himself to be.</p>
<p>We use Devise because it offers a full set of features used in more complex applications, such as recovering a user’s forgotten password or allowing users to invite friends. Should you need help in troubleshooting or customizing the implementation, you’ll be able to get help from a large community of developers using Devise.</p>
<h4>CanCan with Rolify</h4>
<p>CanCan provides a system for authorization to determine if an authenticated user should have access to secured resources. CanCan is often used to restrict access to administrative pages. This application will use CanCan to restrict access to content based on the price a user has paid for a subscription.</p>
<p>CanCan provides a mechanism for limiting access at the level of controller and controller method and expects you to set permissions based on user attributes you define. CanCan doesn’t provide default user attributes such as user roles based on subscription price; you must implement this outside of CanCan. There are many ways to implement role-based authorization for use with CanCan. For this example, we use Florent Monbillard’s Rolify gem to create a Role model, add methods to a User model, and generate a migration for a roles table.</p>
<h4>Stripe</h4>
<p>Stripe is a third-party billing service that provides an <span class="caps">API</span> and gem for integration with Rails applications. There are several other third-party billing services; Stripe is the least expensive and most popular for low-volume startups. Stripe costs 2.9% + 30¢ per successful charge, with no monthly or setup fees (see <a href="https://stripe.com/help/pricing">Stripe pricing</a>). Unfortunately, Stripe is only available to developers who have bank accounts in the US or Canada, though you can receive payments from customers internationally.</p>
<p>Stripe is the best choice for low-volume businesses based in the US or Canada. You may want to also look at the <a href="https://recurly.com/">Recurly</a> billing service. The RailsApps project provides the <a href="http://railsapps.github.com/rails-recurly-subscription-saas/">rails-recurly-subscription-saas</a> application if you’d prefer to use Recurly. Unlike Stripe, Recurly requires you to obtain a merchant bank account from a third party which requires an additional step and a few days lead time. Recurly charges a monthly minimum fee of $69 per month which makes the per-transaction cost higher than Stripe for low-volume businesses. Above a threshold of about 600 monthly users (at an average transaction of $10), Recurly will be less expensive than Stripe (see the <a href="http://www.billingsavvy.com/">BillingSavvy</a> calculator). Unlike Stripe, Recurly offers dunning management (sending emails to users with expired credit cards) that can increase customer retention. Stripe is available to businesses with US and Canadian bank accounts only; Recurly is available to businesses in many more countries.</p>
<h4>Database</h4>
<p>The tutorial shows how to set up the application using a <a href="http://www.sqlite.org/">SQLite</a> database. Rails uses the SQLite database by default. Mac OS X come with SQLite pre-installed and there’s nothing to configure. On Windows, if you use a pre-assembled package to install Rails, it will likely have SQLite pre-installed. On Ubuntu Linux, you can easily install SQLite. If you prefer to use MySQL or PostgreSQL, it’s easy to change the application Gemfile and no changes are required for the application.</p>
<h2>Architecture and Implementation</h2>
<p>Here is a high-level abstraction of the application, as a list of systems:</p>
<ul>
<li>user management with Devise (to register or remove users)</li>
	<li>authentication with Devise (log in and log out)</li>
	<li>authorization management with CanCan and Rolify (access determined by the subscription plan)</li>
	<li>account management to maintain records of subscription status</li>
	<li>recurring billing with Stripe</li>
	<li>landing pages</li>
	<li>content or service pages</li>
</ul><h3>User Management, Authentication, and Authorization</h3>
<p>The tutorial for the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application shows how to set up user management and authentication using Devise, as well as authorization management using CanCan and Rolify. The first step in the tutorial will be to generate the rails3-bootstrap-devise-cancan application as a starter app.</p>
<p>Users are managed with the User model, which has attributes for name, email, and password, as well as some fields provided by Devise such as sign_in_count. The Devise gem provides its own controllers for managing sessions, registration, email confirmation and similar functions. You won’t see these controllers as they are hidden in the gem itself.</p>
<p>CanCan uses an Ability model to set access control rules. We’ll modify the Ability model to set access rules based on subscription plans. We’ll use the Role model required by Rolify to define roles based on subscription plans.</p>
<h3>Account Management and Recurring Billing</h3>
<p>An account management system keeps subscription records so the access control system can determine which users are current subscribers. We’ll combine services offered by Stripe with user management provided by Devise for our account management system.</p>
<p>Stripe will provide the recurring billing system to store the users’ credit card data and initiate payment transactions.</p>
<p>We’ll use the Stripe <span class="caps">API</span> to create a new customer and specify a subscription plan. When the customer’s subscription expires due to failed payment, we’ll use Stripe “webhooks” to update our application’s user records.</p>
<p>We’ll provide options for the user to change credit cards, upgrade or downgrade subscription plans, and cancel a subscription as an extension of the user management system provided by Devise.</p>
<p>Two approaches are possible in building a recurring billing system. You could implement a complete billing management system as part of the application. This would require building a mechanism to check for expiring subscriptions (typically a daily cron job) and initiate payment requests through Stripe when a user’s account comes due. With this approach, you would use Stripe only for processing credit card transactions. But there’s no reason to implement recurring billing yourself. Stripe provides a complete, well-tested, and hosted mechanism for recurring billing. We’ll use Stripe’s <span class="caps">API</span> to supply the recurring billing services we need.</p>
<p>A key requirement for the application is to keep the recurring billing and account management systems in sync. We face a problem if we establish a new subscription, hand off recurring billing to Stripe, and then months later find that the subscriber’s credit card has expired and can no longer be billed. We need a mechanism to update our subscription status when Stripe encounters a declined transaction. Stripe provides “webhooks” to set the status of a subscription. When Stripe encounters a declined transaction it will initiate an <span class="caps">HTTP</span> request to our application which we can decode to change a subscription status.</p>
<p>If we didn’t use the Stripe webhooks, we’d have to either query the Stripe <span class="caps">API</span> on each login or run a repeating cron job to check for subscription expiration. The application will be notified immediately by Stripe so there is no need for the overhead of checking on each login. The Stripe webhook mechanism is very robust: If for some reason it cannot make an <span class="caps">HTTP</span> request to our application, it will retry several times with exponential backoff.</p>
<p>A key requirement for any ecommerce site that takes credit cards is <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> to minimize risk of customer credit card exposure. Using Stripe, your server will never receive sensitive credit card details. Instead you’ll use a the Stripe JavaScript library on your subscription payment form which sends the credit card details directly to the Stripe servers. Your business can easily meet <span class="caps">PCI</span> compliance requirements of the “<span class="caps">PCI</span> <span class="caps">DSS</span> Self-Assessment Questionnaire A” if you solely accept payment information through the Stripe JavaScript library and serve your payment page over <span class="caps">SSL</span>.</p>
<h3>Landing Pages</h3>
<p>Landing pages serve to describe the value of the content or service and convince the visitor to purchase a subscription. For our example application, the home page of the application is our landing page.</p>
<h3>Content or Service</h3>
<p>We’ll create placeholder pages for content.</p>
<p>For your application, the content can be anything you like: photo galleries, videos, downloadable ebooks. For a SaaS site, subscribers would gain access to a web application.</p>
<h3>The Object Model</h3>
<p>Software engineering attempts to model real-world entities and behaviors. As developers, we try to choose descriptive names for objects and methods to reduce ambiguity and increase understanding. For this application, a User is our most important object. In other projects, we might call this object an “Account” or “Member.”</p>
<p>Users have several important attributes: email address, password, credit card number, subscription plan. A user also has less important attributes such as name or creation date. Any of these attributes could be separate objects that are associated with the user through an id or key. You could make “Subscription” or “Plan” an object associated with a user. To keep this application simple, we’ll define everything we need as attributes of the user, rather than separate objects.</p>
<p>We won’t include a credit card number as an attribute of a user because we don’t want the vulnerability of storing a credit card number in our database. Instead, we’ll send the credit card number directly to Stripe and obtain a Stripe customer id that serves as an indirect reference to the credit card number when we need to ask Stripe to begin billing a user. The Stripe customer id will be an attribute of the user that substitutes for a credit card number.</p>
<p>Our authorization system is based on the concept of roles. The user’s role constrains his or her access to the website’s content pages. Though “Subcription Plan” and “Role” appear to be distinct concepts, in this application they functionally overlap. We’ll use the Role model supplied by the Rolify gem as an object that corresponds to a “Subcription Plan.” Each user will have a role id that describes the subscription plan (or access level) that he or she has purchased.</p>
<h2>Accounts You May Need</h2>
<p>Before you start, you will need accounts for <em>recurring billing</em>, a <em>merchant account</em>, <em>hosting</em>, <em>email</em>, and a <em>source control repository</em>.</p>
<h3>Billing</h3>
<p>Many providers of billing services want your business:</p>
<ul>
<li>
<a href="https://stripe.com/">Stripe</a> (2011)</li>
	<li>
<a href="http://saasy.com/">SaaSy</a> (2011)</li>
	<li>
<a href="http://www.fusebill.com/">Fusebill</a> (2011)</li>
	<li>
<a href="http://recurly.com/">Recurly</a> (2010)</li>
	<li>
<a href="http://www.earlyimpact.com/subscriptionbridge/">SubscriptionBridge</a> (2010)</li>
	<li>
<a href="http://chargify.com/">Chargify</a> (2009)</li>
	<li>
<a href="https://cheddargetter.com/">CheddarGetter</a> (2009)</li>
	<li>
<a href="http://www.braintreepayments.com/">Braintree</a> (2007)</li>
	<li>
<a href="http://spreedly.com/">Spreedly</a> (2007)</li>
	<li>
<a href="http://www.zuora.com/">Zuora</a> (2007)</li>
	<li>
<a href="http://www.adyen.com/">Adyen</a> (2006)</li>
	<li>
<a href="http://www.vindicia.com/">Vindicia</a> (2003)</li>
	<li>
<a href="http://www.ariasystems.com/">Aria Systems</a> (2003)</li>
</ul><p>The list shows the year each service was founded. In general, since the market is highly competetive, the newer services are less expensive and offer better integration, interfaces, and features.</p>
<p>Several blog posts compare services and pricing:</p>
<ul>
<li>
<a href="http://blog.subscrea.com/recurring-billing/peeling-the-onion-called-recurring-billing-part-ii/">Peeling the onion called recurring billing</a> (July 2012)</li>
	<li>
<a href="http://expletiveinserted.com/2011/03/18/comparing-recurring-payment-solutions/">Comparing Recurring Payment Solutions</a> (March 2011)</li>
</ul><p>You can use a web-based calculator to compare pricing of some services:</p>
<ul>
<li><a href="http://www.billingsavvy.com/">BillingSavvy</a></li>
</ul><p>BillingSavvy shows Stripe is cheaper than Recurly for less than 600 subscribers. Over 600 subscribers, Recurly becomes cheaper. Stripe and Recurly are always cheaper than Chargify, CheddarGetter and Spreedly for $12/month subscriptions.</p>
<p>This tutorial shows to set up recurring billing using Stripe. Before you start, go to the <a href="https://stripe.com/">Stripe website</a> and set up an account. You don’t need a credit card merchant account or payment gateway. There’s no approval process to delay getting started.</p>
<h3>Merchant Account</h3>
<p>Your business will need a merchant account in order to accept credit card payments. Here’s an explanation from Phillip Parker of <a href="http://www.cardpaymentoptions.com/">CardPaymentOptions.com</a>: “A merchant account is a line of credit account that allows a business to accept card payments from its customers. Similar to how a checking account allows you to deposit another person’s check into your checking account, a merchant account allows you to accept a card payment from a customer. Unlike a checking account, a merchant account doesn’t hold money. Instead, a card payment passes through the merchant account and is deposited into a checking account after the funds have been cleared through the merchant account.”</p>
<p>Unlike other providers of billing services, Stripe provides a merchant account as part of the service.</p>
<h3>Hosting</h3>
<p>For easy deployment, use a “platform as a service” provider such as:</p>
<ul>
<li><a href="http://www.heroku.com/">Heroku</a></li>
	<li><a href="http://www.cloudfoundry.com/">CloudFoundry</a></li>
	<li><a href="http://www.engineyard.com/">EngineYard</a></li>
	<li><a href="https://openshift.redhat.com/app/">OpenShift</a></li>
</ul><p>Instructions are provided for deployment to Heroku.</p>
<p>It’s common for technically skilled people to want to set up their own servers. Please, do yourself a favor, and unless system administration is your most dearly loved recreation, let the platform providers do it for you.</p>
<h3><span class="caps">SSL</span></h3>
<p>Visitors to your website will be sending credit card information from their browser to Stripe’s servers when they sign up for a subscription. The Stripe JavaScript library will open an <span class="caps">SSL</span> connection to Stripe’s servers when the form is submitted.</p>
<p>You can host your membership site without <span class="caps">SSL</span> and your users’ credit card numbers will be protected on the way to Stripe’s servers. However, your security-conscious visitors will be uneasy if they see that the web <span class="caps">URL</span> for your regsitration page begins with <code>http://</code> and not <code>https://</code> (indicating an <span class="caps">SSL</span> connection). For their peace of mind (and the higher conversion rate that comes with trust), you should host your website with an <span class="caps">SSL</span> connection. Additionally, as a general practice, it is wise to host any webapp that requires login over an <span class="caps">SSL</span> connection.</p>
<p>If you’re deploying with Heroku, you can access any Heroku app over <span class="caps">SSL</span> at <code>https://myapp.herokuapp.com/</code>. For your custom domain, Heroku offers the <a href="https://devcenter.heroku.com/articles/ssl-endpoint"><span class="caps">SSL</span> Endpoint add-on</a> for a fee of $20/month. You’ll need to <a href="https://devcenter.heroku.com/articles/ssl-certificate">purchase a signed certificate from a certificate provider</a> for an annual fee (typically $20 a year). Setting up an <span class="caps">SSL</span> certificate for a custom domain on Heroku can be a hassle but there’s a convenient alternative that is a better value. You can purchase <a href="http://cloudflare.com/">CloudFlare</a> for $20/month and get <span class="caps">SSL</span> without purchasing or installing an <span class="caps">SSL</span> certificate. CloudFlare is a content delivery network (<span class="caps">CDN</span>) and website optimizer; the $20/month <a href="http://blog.cloudflare.com/easiest-ssl-ever-now-included-automatically-w">CloudFlare Pro plan includes <span class="caps">SSL</span></a>. If you use Cloudflare in combination with Heroku hosting, you can use the Heroku piggyback <span class="caps">SSL</span> to encrypt the traffic between Heroku and Cloudflare, and your website visitors will connect to Cloudfare with their web browsers, providing a complete <span class="caps">SSL</span> connection through Cloudfare to Heroku with your custom domain. Not only do you get <span class="caps">SSL</span> for no more than you’d pay at Heroku to use an <span class="caps">SSL</span> certificate, but you get the Cloudfare <span class="caps">CDN</span> services as part of the bargain.</p>
<p>If you’re deploying on Heroku, you can wait until you’ve deployed to sign up for a Cloudfare account.</p>
<p>If you’re deploying elsewhere, do your research early to find out how to set up <span class="caps">SSL</span> and apply for an <span class="caps">SSL</span> certificate if necessary.</p>
<h3>Email Service Providers</h3>
<p>You’ll need infrastructure for three types of email:</p>
<ul>
<li>company email</li>
	<li>email sent from the app (“transactional email”)</li>
	<li>broadcast email for newsletters or announcements</li>
</ul><p>No single vendor is optimal for all three types of email; you likely will use several vendors. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a> for suggestions for various types of email service providers.</p>
<h3>Domain Registration</h3>
<p>You’ve likely already selected and registered a domain name. If not, you’ll need a domain before you start sending email messages from the application. If you’re disgusted by GoDaddy, consider <a href="http://www.namecheap.com/">NameCheap</a> and other popular alternatives.</p>
<h3>GitHub</h3>
<p>Get a <a href="https://github.com/signup/free">free GitHub account</a> if you don’t already have one. You’ll use <a href="http://git-scm.com/">git</a> for version control and you should get a GitHub account for remote backup and collaboration. See <a href="http://railsapps.github.com/rails-git.html">GitHub and Rails</a> if you need more information about working with git and GitHub for code source control.</p>
<h2>Getting Started</h2>
<h3>Is It for You?</h3>
<p>This tutorial is for experienced developers as well as startup founders or hobbyist coders who are new to Rails.</p>
<p>Experienced developers will find the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">complete application on GitHub</a>; this tutorial provides the detail and background to understand the implementation in depth. For Rails beginners, this tutorial describes each step that you must follow to create the application. Every step is documented concisely, so you can create this application without any additional knowledge. However, the tutorial assumes you’ve already been introduced to Rails, so if you are a beginner, you may be overwhelmed unless you’ve been introduced to Rails elsewhere. See resources for getting started with <a href="http://railsapps.github.com/rails.html">Rails</a>.</p>
<h3>Where to Start</h3>
<p>This is one in a series of Rails example apps and tutorials from the <a href="http://railsapps.github.com/">RailsApps Project</a>. See a list of similar <a href="http://railsapps.github.com/rails-examples-tutorials.html">Rails examples, tutorials, and starter apps</a>.</p>
<p>This application is based on two simpler example apps:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><p>The first example shows how to set up Devise for user authentication. It also shows how to set up the app to use RSpec and Cucumber for testing.</p>
<p>The second example shows how to set up Devise and add CanCan and Rolify to manage access to administrative pages. It also shows how to set up Twitter Bootstrap as a front-end framework for <span class="caps">CSS</span> styling.</p>
<p>You can use this tutorial without studying these example applications; if you find you are lost, it may be helpful to look at the two simpler examples.</p>
<p>If you want to use the MongoDB datastore instead of ActiveRecord and a <span class="caps">SQL</span> database, look at the  <a href="https://github.com/RailsApps/rails3-mongoid-devise">rails3-mongoid-devise</a> example.</p>
<p>You might also be interested in the <a href="https://github.com/RailsApps/rails-prelaunch-signup">rails-prelaunch-signup</a> example if you are planning prelaunch promotion. Use it to announce your plans and collect email addresses from visitors for future notification of the site’s launch.</p>
<h3>About the Tutorial</h3>
<p>Most of the tutorials from the RailsApps project take about an hour to complete. This tutorial is more complex; it will take you about three hours to build the complete app. (Is our estimate accurate? Please <a href="#comments">leave a comment</a> when you are done.)</p>
<p>If you find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">GitHub issue</a>.</p>
<p>You’ll find a comments section at the end of the tutorial. I encourage you to offer feedback to improve this tutorial.</p>
<h3>Before You Start</h3>
<p>If you follow this tutorial closely, you’ll have a working application that closely matches the example app in this GitHub repository. The example app in the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> repository is your reference implementation. If you find problems with the app you build from this tutorial, download the example app (in Git speak, clone it) and use a file compare tool to identify differences that may be causing errors. On a Mac, <a href="http://stackoverflow.com/questions/187064/graphical-diff-for-mac-os-x">good file compare tools</a> are <a href="http://en.wikipedia.org/wiki/Apple_Developer_Tools#FileMerge">FileMerge</a>, <a href="http://sourcegear.com/diffmerge/">DiffMerge</a>, <a href="http://www.kaleidoscopeapp.com/">Kaleidoscope</a>, or Ian Baird’s <a href="http://www.changesapp.com/">Changes</a>.</p>
<p>If you find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">GitHub issue</a>. It’s best to clone and check the example application from the GitHub repository before you report an issue, just to make sure the error isn’t a result of your own mistake.</p>
<p>The online edition of this tutorial contains a comments section at the end of the tutorial. I encourage you to offer feedback to improve this tutorial.</p>
<h3>Assumptions</h3>
<p>Before beginning this tutorial, you need to install</p>
<ul>
<li>The Ruby language (version 1.9.3)</li>
	<li>Rails 3.2</li>
</ul><p>Check that appropriate versions of Ruby and Rails are installed in your development environment:<br><code>$ ruby -v</code><br><code>$ rails -v</code></p>
<p>Be sure to read <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a> to make sure your development environment is set up properly.</p>
<p>I recommend using <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager to manage your Rails versions and create a dedicated gemset for each application you build.</p>
<h2>Create the Application</h2>
<p>You have several options for getting the code. You can <em>copy from the tutorial</em>, <em>fork</em>, <em>clone</em>, or <em>generate</em>.</p>
<p>If you want to add this code to an existing application, you can follow the tutorial and cut and paste the code into your existing application, resolving any conflicts as needed.</p>
<h3>Copy from the Tutorial</h3>
<p>To create the application, you can cut and paste the code from the tutorial into your own files. It’s a bit tedious and error-prone but you’ll have a good opportunity to examine the code closely. Before you start, the tutorial will ask you to use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate a starter app to save some steps. Then you can follow the tutorial step-by-step to build the complete application.</p>
<h3>Other Options</h3>
<h4>Fork</h4>
<p>If you’d like to add features (or bug fixes) to improve the example application, you can fork the GitHub repo and <a href="http://help.github.com/send-pull-requests/">make pull requests</a>. Your code contributions are welcome!</p>
<h4>Clone</h4>
<p>If you want to copy and customize the app with changes that are only useful for your own project, you can download or clone the GitHub repo. You’ll need to search-and-replace the project name throughout the application. You probably should generate the app instead (see below). To clone:</p>
<pre>
$ git clone git://github.com/RailsApps/rails-stripe-membership-saas.git
</pre>
<p>You’ll need <a href="http://git-scm.com/">git</a> on your machine. See <a href="http://railsapps.github.com/rails-git.html">Rails and Git</a>.</p>
<h4>Generate</h4>
<p>If you wish to skip the tutorial and build the application immediately, use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate the complete example app. You’ll be able to give it your own project name when you generate the app. Generating the application gives you additional options.</p>
<p>To build the complete example application immediately, see the instructions in the <span class="caps">README</span> for the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> example application.</p>
<h3>Building from Scratch</h3>
<p>Before you write any code, you’ll start by generating a starter app using the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool.</p>
<p>If you’ve developed other applications in Rails, you’ll know that the <code>rails new</code> command creates a basic Rails application. Here we’ll use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool (“like the ‘rails new’ command on steroids”) to create a starter app. The starter app saves us some steps. Devise will be installed with Cancan for authorization. Twitter Bootstrap will be set up as a front end for <span class="caps">CSS</span> styling. If you want to learn how the starter app is put together, see the <a href="http://railsapps.github.com/tutorial-rails-bootstrap-devise-cancan.html">rails3-bootstrap-devise-cancan</a> tutorial.</p>
<p>For the starter app we need, use the command:</p>
<pre>
$ rails new rails-stripe-membership-saas -m https://raw.github.com/RailsApps/rails-composer/master/composer.rb -T
</pre>
<p>Use the <code>-T</code> flag to skip Test::Unit files since we’ll be using RSpec.</p>
<p>The <code>$</code> character indicates a shell prompt; don’t include it when you run the command.</p>
<p>This creates a new Rails app named <code>rails-stripe-membership-saas</code> on your computer. You can use a different name if you wish.</p>
<p>You’ll see a prompt:</p>
<pre>
question  Install an example application?
      1)  I want to build my own application
      2)  membership/subscription/saas
      3)  rails-prelaunch-signup
      4)  rails3-bootstrap-devise-cancan
      5)  rails3-devise-rspec-cucumber
      6)  rails3-mongoid-devise
      7)  rails3-mongoid-omniauth
      8)  rails3-subdomains
</pre>
<p>Choose <strong>rails3-bootstrap-devise-cancan</strong>. The Rails Composer tool may give you other options (other choices may have been added since this tutorial was written). <strong>Note:</strong> Don’t choose “membership/subscription/saas” (unless you want to skip the tutorial).</p>
<p>The application generator template will ask you for additional preferences:</p>
<pre>
 question  Web server for development?
       1)  WEBrick (default)
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Web server for production?
       1)  Same as development
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Template engine?
       1)  ERB
       2)  Haml
       3)  Slim
   extras  Set a robots.txt file to ban spiders? (y/n)
   extras  Create a project-specific rvm gemset and .rvmrc? (y/n)
   extras  Create a GitHub repository? (y/n)
</pre>
<h4>Web Servers</h4>
<p>Use the default WEBrick server for convenience. If you plan to deploy to Heroku, select “thin” as your production webserver.</p>
<h4>Template Engine</h4>
<p>The example application uses the default “<span class="caps">ERB</span>” Rails template engine. Optionally, you can use another template engine, such as Haml or Slim. See instructions for <a href="http://railsapps.github.com/rails-haml.html">Haml and Rails</a>.</p>
<h4>Other Choices</h4>
<p>Set a robots.txt file to ban spiders if you want to keep your new site out of Google search results.</p>
<p>It is a good idea to use <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager, and create a project-specific rvm gemset and .rvmrc file (not available on Windows). See <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a>.</p>
<p>If you choose to create a GitHub repository, the generator will prompt you for a GitHub username and password.</p>
<h4>Troubleshooting</h4>
<p>If you get an error “OpenSSL certificate verify failed” or “Gem::RemoteFetcher::FetchError: SSL_connect” see the article <a href="http://railsapps.github.com/openssl-certificate-verify-failed.html">OpenSSL errors and Rails</a>.</p>
<p>If you get an error like this:</p>
<pre>
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
    composer  Running 'after bundler' callbacks.
The template [...] could not be loaded.
Error: You have already activated ..., but your Gemfile requires ....
Using bundle exec may solve this.
</pre>
<p>It’s due to conflicting gem versions. See the article <a href="http://railsapps.github.com/rails-error-you-have-already-activated.html">Rails Error: “You have already activated (…)”</a>.</p>
<h3>Begin Development</h3>
<p>After you create the application, switch to its folder to continue work directly in the application:</p>
<p><code>$ cd rails-stripe-membership-saas</code></p>
<h3>Replace the READMEs</h3>
<p>Please edit the <span class="caps">README</span> files to add a description of the app and your contact info. Changing the <span class="caps">README</span> is important if your app will be publicly visible on GitHub. Otherwise, people will think I am the author of your app. If you like, add an acknowledgment and a link to the <a href="http://railsapps.github.com/">RailsApps project</a>.</p>
<h3>Set Up Source Control (Git)</h3>
<p>When you generate the starter app, the template sets up a source control repository and makes an initial commit of the code.</p>
<p>At your request, the template will also create a GitHub repository for your project.</p>
<p>See detailed instructions for <a href="http://railsapps.github.com/rails-git.html">Git and Rails</a>.</p>
<p>Git has already been initialized by the application template script. If you’ve selected the GitHub option, the template commits your code to your GitHub repository.</p>
<h3>Set Up Gems</h3>
<p>The Rails Composer program sets up your Gemfile and (if you are using rvm) creates a project-specific gemset.</p>
<p>Open your <strong>Gemfile</strong> and you should see the following. Gem version numbers may differ:</p>
<pre>
source 'https://rubygems.org'
gem 'rails', '3.2.9'
gem 'sqlite3'
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'
  gem 'uglifier', '&gt;= 1.0.3'
end
gem 'jquery-rails'
gem "rspec-rails", "&gt;= 2.11.0", :group =&gt; [:development, :test]
gem "email_spec", "&gt;= 1.2.1", :group =&gt; :test
gem "cucumber-rails", "&gt;= 1.3.0", :group =&gt; :test, :require =&gt; false
gem "database_cleaner", "&gt;= 0.9.1", :group =&gt; :test
gem "launchy", "&gt;= 2.1.2", :group =&gt; :test
gem "capybara", "&gt;= 1.1.2", :group =&gt; :test
gem "factory_girl_rails", "&gt;= 4.1.0", :group =&gt; [:development, :test]
gem "bootstrap-sass", "&gt;= 2.1.0.0"
gem "devise", "&gt;= 2.1.2"
gem "cancan", "&gt;= 1.6.8"
gem "rolify", "&gt;= 3.2.0"
gem "simple_form", "&gt;= 2.0.4"
gem "quiet_assets", "&gt;= 1.0.1", :group =&gt; :development
gem "better_errors", "&gt;= 0.0.8", :group =&gt; :development
gem "binding_of_caller", "&gt;= 0.6.8", :group =&gt; :development
</pre>
<p>Add the following gems which will be needed for the rails-stripe-membership-saas application:</p>
<pre>
gem "stripe"
gem "stripe_event"
</pre>
<p>Check for the <a href="http://rubygems.org/gems/rails">current version of Rails</a> and replace <code>gem 'rails', '3.2.9'</code> accordingly.</p>
<p><em>Note:</em> Rails Composer templates are created by the <a href="https://github.com/RailsApps/rails_apps_composer">Rails Apps Composer Gem</a>. For that reason, groups such as <code>:development</code> or <code>:test</code> are specified inline. You can reformat the Gemfile to organize groups in an eye-pleasing block style. The functionality is the same.</p>
<h3>Install the Required Gems</h3>
<p>When you add a new gem to the Gemfile, you should run the <code>bundle install</code> command to install the required gems on your computer. Run:</p>
<pre>
bundle install
</pre>
<p>You can check which gems are installed on your computer with:</p>
<pre>
$ gem list
</pre>
<p>Keep in mind that you have installed these gems locally. When you deploy the app to another server, the same gems (and versions) must be available.</p>
<h3>Test the App</h3>
<p>You can check that your app runs properly by entering the command</p>
<pre>
$ rails server
</pre>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>. You should see the home page created by the starter app.</p>
<p>Stop the server with Control-C.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add gems"
</pre>
<h2>Test-Driven Development</h2>
<p>This example application uses Cucumber for integration testing and RSpec for unit testing.</p>
<p>Testing is at the center of any robust software development process. Integration tests determine whether the application’s features work as expected, testing the application from the point of view of the user. Unit tests confirm that small, discrete portions of the application continue working as developers add features and refactor code. RSpec is a popular choice for unit testing. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up RSpec and provides example specs for use with Devise. Cucumber is a popular choice for integration testing and behavior driven development. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up Cucumber and provides example scenarios for use with Devise.</p>
<p>To learn more about using RSpec, refer to <a href="http://www.pragprog.com/titles/achbd/the-rspec-book">The RSpec Book</a>.</p>
<p>To learn more about using Cucumber, refer to <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a> or the free introduction to Cucumber, <a href="http://cuke4ninja.com/">The Secret Ninja Cucumber Scrolls</a>.</p>
<p>This tutorial assumes you’ve learned to write tests elsewhere (see a list of <a href="http://railsapps.github.com/rails.html">recommended resources for Rails</a>). I won’t spend time showing you how to write tests but you can use tests to make sure the application works as expected.</p>
<h3>Tests Installed by Rails Composer</h3>
<p>The Rails Composer tool creates a starter app that is set up for RSpec and Cucumber test frameworks.</p>
<p>The starter app includes RSpec and Cucumber test suites designed for the features of the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application.</p>
<h4>Running RSpec Tests</h4>
<p>The starter app script sets up RSpec for unit testing. You should be able to run <code>rake spec</code> to run all specs provided with the example app after the database is set up.</p>
<h4>Running Cucumber Tests</h4>
<p>The starter app script sets up Cucumber for specifications and acceptance testing.</p>
<p>You should be able to run <code>rake cucumber</code>, or more simply, <code>cucumber</code>, to run the Cucumber scenarios and steps provided with the example app after the database is set up. You can run a single Cucumber feature with a command such as:</p>
<pre>
$ cucumber features/visitors/request_invitation.feature
</pre>
<p>If you’ve used Cucumber, you may know that you need to add <code>--require features</code> to run a single Cucumber feature. Here it is not necessary to do so; the starter app script sets up the <strong>config/cucumber.yml</strong> file so it is not necessary to add <code>--require features</code>.</p>
<h3>Installing Tests from the Example Application</h3>
<p>The starter app only installs tests designed for the features of the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application. However, a full suite of tests for the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> example application are available in the GitHub repository.</p>
<p>You can copy the RSpec unit tests and Cucumber integration tests from the GitHub repository. Replace both the <strong>spec</strong> and <strong>features</strong> directories entirely. Copying all the files will include necessary configuration and helper files.</p>
<p>Run <code>rake -T</code> to check that rake tasks for RSpec and Cucumber are available. You won’t be able to run <code>rake spec</code> or <code>rake cucumber</code> until the database is set up.</p>
<h2>Configuration</h2>
<h3>Configuration File</h3>
<p>See the article <a href="http://railsapps.github.com/rails-environment-variables.html">Rails Environment Variables</a> for more information.</p>
<p>The application uses the <a href="https://github.com/laserlemon/figaro">figaro gem</a> to set environment variables. The starter app sets up the figaro gem and generates a <strong>config/application.yml</strong> file and lists it in your <strong>.gitignore</strong> file.</p>
<p>Credentials for your administrator account and email account are set in the <strong>config/application.yml</strong> file. The <strong>.gitignore</strong> file prevents the <strong>config/application.yml</strong> file from being saved in the git repository so your credentials are kept private.</p>
<p>Modify the file <strong>config/application.yml</strong>:</p>
<pre>
# Add account credentials and API keys here.
# See http://railsapps.github.com/rails-environment-variables.html
# This file should be listed in .gitignore to keep your settings secret!
# Each entry sets a local environment variable and overrides ENV variables in the Unix shell.
# For example, setting:
# GMAIL_USERNAME: Your_Gmail_Username
# makes 'Your_Gmail_Username' available as ENV["GMAIL_USERNAME"]
# Add application configuration variables here, as shown below.
#
GMAIL_USERNAME: Your_Username
GMAIL_PASSWORD: Your_Password
ADMIN_NAME: First User
ADMIN_EMAIL: user@example.com
ADMIN_PASSWORD: please
ROLES: [admin, silver, gold, platinum]
STRIPE_API_KEY: Your_Stripe_API_key
STRIPE_PUBLIC_KEY: Your_Stripe_Public_Key
</pre>
<p>Set the user name and password needed for the application to send email.</p>
<p>If you wish, set your name, email address, and password for an administrator’s account. If you prefer, you can use the default to sign in to the application and edit the account after deployment. It is always a good idea to change the administrator’s password after the application is deployed.</p>
<p>The roles you specify in the configuration file are the subscription plans that will be available to the application’s users. You will need an “admin” role. Keep the “silver”, “gold”, and “platinum” roles while you are testing the application. You can change these roles later, after you familiarize yourself with the application and begin to customize it for your own needs.</p>
<p>The Stripe gem requires an <span class="caps">API</span> key to operate. You also need to supply a public key when initiating a transaction. You can find both keys on your <a href="https://manage.stripe.com/#account/apikeys">Stripe account page</a>. Two sets of keys are available: one for testing, one for live transactions. Use the testing keys on your development machine. When you deploy, use the live keys.</p>
<p>All configuration values in the <strong>config/application.yml</strong> file are available anywhere in the application as environment variables. For example, <code>ENV["GMAIL_USERNAME"]</code> will return the string “Your_Username”.</p>
<p>If you prefer, you can delete the <strong>config/application.yml</strong> file and set each value as an environment variable in the Unix shell.</p>
<h3>Configure Email</h3>
<p>The starter app script sets up a default email configuration. You must configure the application for your email account. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a>.</p>
<p>The starter app has already configured ActionMailer but you must set your email account details.</p>
<p>Replace <code>example.com</code> in the <strong>config/environments/production.rb</strong> file:</p>
<pre>
config.action_mailer.default_url_options = { :host =&gt; 'example.com' }
# ActionMailer Config
# Setup for production - deliveries, no errors raised
config.action_mailer.delivery_method = :smtp
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = false
config.action_mailer.default :charset =&gt; "utf-8"
</pre>
<p>The example application will deliver email in production. Email messages are visible in the log file so there is no need to send email in development.</p>
<p>In production, you should use an email service provider such as <a href="http://mandrill.com/">Mandrill</a> to increase deliverability for email messages from your app.</p>
<p>Use Gmail for experimenting, if you want to keep things simple.</p>
<p>The file <strong>config/environments/production.rb</strong> is set to use:</p>
<pre>
config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: "example.com",
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
</pre>
<p>You can replace <code>ENV["GMAIL_USERNAME"]</code> and <code>ENV["GMAIL_PASSWORD"]</code> with your Gmail username and password. However, committing the file to a public GitHub repository will expose your secret password. Instead, use local environment variables from the <strong>config/application.yml</strong> file to keep email account passwords secret.</p>
<h3>Configure Devise for Email</h3>
<p>Complete your email configuration by modifying</p>
<p><strong>config/initializers/devise.rb</strong></p>
<p>and setting the <code>config.mailer_sender</code> option for the return email address for messages that Devise sends from the application.</p>
<h3>Stripe Initializer</h3>
<p>You’ve set the Stripe <span class="caps">API</span> key and public key in your <strong>config/application.yml</strong> file. The file is there for security so your credentials won’t be exposed publicly on a GitHub repo.</p>
<p>We’ll use an initializer file to set the <span class="caps">API</span> key for use by the Stripe gem. We’ll also set a constant for the public key which we can use in JavaScript code.</p>
<p>Create a file <strong>config/initializers/stripe.rb</strong>:</p>
<pre>
Stripe.api_key = ENV["STRIPE_API_KEY"]
STRIPE_PUBLIC_KEY = ENV["STRIPE_PUBLIC_KEY"]
</pre>
<p>The <code>Stripe.api_key</code> value and the <code>STRIPE_PUBLIC_KEY</code> constant are set using local environment variables from the <strong>config/application.yml</strong> file. The <code>Stripe.api_key</code> value should be kept secret so no other developer can use your Stripe account. The <code>STRIPE_PUBLIC_KEY</code> constant does not need to be kept secret but we set it in the <strong>config/application.yml</strong> file for convenience, so all your configuration settings are in one location.</p>
<p>Remember you’ll need to restart your server before testing because you’ve made a change to configuration files.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "configure"
</pre>
<h2>Layout and Stylesheets</h2>
<p>This tutorial shows code using <span class="caps">ERB</span>, the default Rails templating language. If you prefer, you can generate the starter app with Haml instead of <span class="caps">ERB</span>. Then convert the <span class="caps">ERB</span> in the tutorial to Haml. See instructions for <a href="http://railsapps.github.com/rails-haml.html">Haml and Rails</a>.</p>
<p>Rails will use the layout defined in the file <strong>app/views/layouts/application.html.erb</strong> as a default for rendering any page. See the article <a href="http://railsapps.github.com/rails-default-application-layout.html">Rails Default Application Layout</a> for an explanation of each of the elements in the application layout.</p>
<p>The starter app:</p>
<ul>
<li>installs Twitter Bootstrap</li>
	<li>updates the application layout</li>
	<li>adds navigation links</li>
	<li>styles Rails flash messages</li>
	<li>installs and configures <a href="https://github.com/plataformatec/simple_form">SimpleForm</a>
</li>
</ul><p>See the article <a href="http://railsapps.github.com/twitter-bootstrap-rails.html">Twitter Bootstrap and Rails</a> and review the tutorial for the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application for details.</p>
<p>The file <strong>app/views/layouts/_navigation.html.erb</strong> contains navigation links.</p>
<p>The file <strong>app/views/layouts/_messages.html.erb</strong> contains flash messages.</p>
<h3>Base Errors Helper for SimpleForm</h3>
<p>In this application, some failed transactions set model errors that are not matched to a specific form field. These are called “base errors.” For example, the User model sets an error like this: <code>errors.add :base, "Credit card declined"</code>. SimpleForm does not provide a helper to display base errors; to accommodate base errors, we use a custom view helper.</p>
<p>The starter application installs this view helper in <strong>app/helpers/application_helper.rb</strong>:</p>
<pre>
module ApplicationHelper

  def display_base_errors resource
    return '' if (resource.errors.empty?) or (resource.errors[:base].empty?)
    messages = resource.errors[:base].map { |msg| content_tag(:p, msg) }.join
    html = &lt;&lt;-HTML
    &lt;div class="alert alert-error alert-block"&gt;
      &lt;button type="button" class="close" data-dismiss="alert"&gt;&amp;#215;&lt;/button&gt;
      #{messages}
    &lt;/div&gt;
    HTML
    html.html_safe
  end

end
</pre>
<p>The view helper will be used in the files <strong>app/views/devise/registrations/new.html.erb</strong> and <strong>app/views/devise/registrations/edit.html.erb</strong>:</p>
<pre>
&lt;%= simple_form_for ... %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
.
.
.
&lt;% end %&gt;
</pre>
<p>Without the <code>display_base_errors</code> view helper, the application’s users will not see a “Credit card declined” message if a transaction is declined.</p>
<h2>Authentication</h2>
<p>This application uses <a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication. Devise provides a system to securely identify users, making sure the user is really who he represents himself to be. Devise provides everything needed to implement user registration with log in and log out.</p>
<p>The starter app script sets up Devise:</p>
<ul>
<li>adds the Devise gem to the Gemfile</li>
	<li>runs <code>$ rails generate devise:install</code>
</li>
	<li>uses Devise to generate a User model and database migration</li>
	<li>prevents logging of passwords</li>
	<li>adds a sign-in form that uses SimpleForm and Twitter Bootstrap</li>
</ul><p>For details about how Devise is used in the starter application, see the tutorials:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>Authorization</h2>
<p>This application uses <a href="https://github.com/ryanb/cancan">CanCan</a> for authorization, to restrict access to pages that should only be viewed by an authorized user. CanCan offers an architecture that centralizes all authorization rules (permissions or “abilities”) in a single location, the CanCan <code>Ability</code> class. CanCan provides a mechanism for limiting access at the level of controller and controller method and expects you to set permissions based on user attributes you define. This application uses Florent Monbillard’s <a href="https://github.com/EppO/rolify">Rolify</a> gem to create a Role model and add methods to a User model that are used to set CanCan permissions.</p>
<p>The starter app script sets up CanCan and Rolify:</p>
<ul>
<li>adds the CanCan and Rolify gems to the Gemfile</li>
	<li>creates the CanCan <code>Ability</code> class</li>
	<li>configures CanCan exception handling</li>
	<li>sets up User roles with Rolify</li>
</ul><p>For details about how authorization is implemented in the starter application, see the tutorial:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>User Management</h2>
<p>By default, Devise uses an email address to identify users. The starter application adds a “name” attribute as well.</p>
<p>Devise provides all the functionality for a user to log in and view and edit the user’s profile. The user’s profile only includes an email address, a name, and a password. You’ll likely customize the User model and user pages for your own application.</p>
<p>The starter application:</p>
<ul>
<li>adds a name attribute to the User model</li>
	<li>limits mass-assignment operations with the <code>attr_accessible</code> method</li>
	<li>provides custom views for registering and editing users</li>
</ul><p>For details about how user management is set up in the starter application, see the tutorials:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h3>Add Fields for Stripe</h3>
<p>We will need two extra fields in the database to accommodate Stripe:</p>
<ul>
<li>
<code>customer_id</code> will store the Stripe customer ID</li>
	<li>
<code>last_4_digits</code> will store the last four digits of the user’s credit card number</li>
</ul><p>The <code>last_4_digits</code> field isn’t needed for integration with Stripe but we can use it to show the user which credit card was used for the subscription.</p>
<p>We’ll change our User model and database schema accordingly.</p>
<h3>Migration for the User Model</h3>
<p>Create a database migration with this command:</p>
<pre>
$ rails generate migration AddStripeToUsers customer_id:string last_4_digits:string
</pre>
<p>After you’ve created the migration, update the database:</p>
<pre>
$ rake db:migrate
</pre>
<p>Now we’ll modify the User model.</p>
<h3>Modify the User Model</h3>
<p>There’s no need to add the attributes <code>customer_id</code> or <code>last_4_digits</code> to the <code>attr_accessible</code> parameters because we won’t be setting those vales from a form. We will remove the <code>attr_accessible :role_ids, :as =&gt; :admin</code> statement.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me

end
</pre>
<p>We remove the <code>attr_accessible :role_ids, :as =&gt; :admin</code> statement. This statement gives the administrator the power to override the mass assignment protection for the role attribute. The statement is no longer necessary because we will add a method that allows both the user and an administrator to reset the role.</p>
<p>With this change to our User model, we are ready to seed the database.</p>
<h3>Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "update user model"
</pre>
<h2>Initial Data</h2>
<h3>Set Up a Database Seed File</h3>
<p>You’ll want to set up default users so you can test the application. We’ll add three users with different subscription plans.</p>
<p>The <strong>db/seeds.rb</strong> file initializes the database with default values. To keep some data private, and consolidate configuration settings in a single location, we use the <strong>config/application.yml</strong> file to set environment variables and then use the environment variables in the <strong>db/seeds.rb</strong> file.</p>
<p>Replace the file <strong>db/seeds.rb</strong> with:</p>
<pre>
puts 'ROLES'
YAML.load(ENV['ROLES']).each do |role|
  Role.find_or_create_by_name({ :name =&gt; role }, :without_protection =&gt; true)
  puts 'role: ' &lt;&lt; role
end
puts 'DEFAULT USERS'
user = User.find_or_create_by_email :name =&gt; ENV['ADMIN_NAME'].dup, :email =&gt; ENV['ADMIN_EMAIL'].dup, :password =&gt; ENV['ADMIN_PASSWORD'].dup, :password_confirmation =&gt; ENV['ADMIN_PASSWORD'].dup
puts 'user: ' &lt;&lt; user.name
user.add_role :admin
user2 = User.find_or_create_by_email :name =&gt; 'Silver User', :email =&gt; 'user2@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user2.add_role :silver
user3 = User.find_or_create_by_email :name =&gt; 'Gold User', :email =&gt; 'user3@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user3.add_role :gold
user4 = User.find_or_create_by_email :name =&gt; 'Platinum User', :email =&gt; 'user4@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user4.add_role :platinum
puts "users: #{user2.name}, #{user3.name}, #{user4.name}"
</pre>
<p>The <strong>db/seeds.rb</strong> file reads a list of roles from the <strong>config/application.yml</strong> file and adds the roles to the database. In fact, any new role can be added to the roles datatable with a statement such <code>user.add_role :superhero</code>. Setting the roles in the <strong>db/seeds.rb</strong> file simply makes sure each role is listed and available should a user wish to change roles.</p>
<p>We’ve added a user with an administrator role using vales from the <strong>config/application.yml</strong> file. You can log in with this account for access as an administrator.</p>
<p>You can change the administrator name, email, and password in this file but it is better to make the changes in the <strong>config/application.yml</strong> file to keep the credentials private. If you decide to include your private password in the <strong>db/seeds.rb</strong> file, be sure to add the filename to your <strong>.gitignore</strong> file so that your password doesn’t become available in your public GitHub repository.</p>
<p>Note that it’s not necessary to personalize the <strong>db/seeds.rb</strong> file before you deploy your app. You can deploy the app with an example user and then use the application’s “Edit Account” feature to change name, email address, and password after you log in. Use this feature to log in as an administrator and change the user name and password to your own.</p>
<p>We’ve added three users and assigned “silver,” “gold,” and “platinum” roles corresponding to a tiered subscription plan.</p>
<h3>Using “example.com” Email Addresses</h3>
<p>We want the application to handle the administrator’s account and any “example.com” email addresses as a special case. Users with an “example.com” domain will not be added to Stripe as subscribers; they will only be added to the application database. This makes it possible to run <code>rake db:seed</code> to add the administrator and set up sample users for development and testing.</p>
<p>Later we’ll add two statements in an <code>update_stripe</code> method in the <strong>app/models/user.rb</strong> file implement the special case so that the Stripe server is not contacted:</p>
<pre>
def update_stripe
  return if email.include?(ENV['ADMIN_EMAIL'])
  return if email.include?('@example.com') and not Rails.env.production?
  .
  .
  .
end
</pre>
<p>As you can see from the code, the “example.com” email addresses will not be special cased in production. That means <code>rake db:seed</code> will fail with errors if you attempt to run it after deployment. You should remove the sample users (but not the administrator) from the <strong>db/seeds.rb</strong> file before deploying to production. See the section “Customize, Test, and Deploy” for advice about deploying to Heroku.</p>
<h3>Seed the Database</h3>
<p>The starter app script has already set up the database and added the default user by running:</p>
<pre>
$ rake db:migrate
$ rake db:seed
</pre>
<p>We’ll need to reset the database because we’ve added new users:</p>
<pre>
$ rake db:reset
</pre>
<p>You can run <code>$ rake db:reset</code> whenever you need to recreate the database.</p>
<p>You’ll also need to set up the database for testing:</p>
<pre>
$ rake db:test:prepare
</pre>
<p>If you’re not using <a href="https://rvm.io/">rvm</a>, you should preface each rake command with <code>bundle exec</code>. You don’t need to use <code>bundle exec</code> if you are using rvm version 1.11.0 or newer.</p>
<h3>Commit to Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "initial data"
</pre>
<h3>Test the Starter App</h3>
<p>At this point, the app is almost identical to the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> starter app.</p>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>. You should see the default users listed on the home page. When you click on a user’s name, you should be required to log in before seeing the user’s detail page.</p>
<p>If you sign in as the first user, you will have administrative privileges. You’ll see an “Admin” link in the navigation bar. Clicking the “Admin” link will display the administrative dashboard. Each user will be listed with buttons to “Change role” or “Delete user.”</p>
<p>Stop the server with Control-C.</p>
<h4>When to Restart</h4>
<p>If you install new gems, you’ll have to restart the server to see any changes. The same is true for changes to configuration files in the config folder. This can be confusing to new Rails developers because you can change files in the app folders without restarting the server. As a rule, remember to restart the server when you add gems, change routes, or change anything in the config folder; leave the server running whn you change models, controllers, views or anything else in app folder.</p>
<h2>Home Page</h2>
<h3>Replace the Home Page</h3>
<p>If you’ve tested the example app, you’ve seen that any user who logs in will see a list of all the users on the home page. That’s fine for an example app but it’s not what we want for a subscription site.</p>
<h3>Home Page with Subscription Plans</h3>
<p>We’ll put our subscription offer and pricing plan on the home page. For this tutorial, it’s simplest to show the offer and prices right on the home page. For a real application, you might describe your offer on the home page and show pricing on a separate page.</p>
<p>Replace the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_silver_path, :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_gold_path, :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_platinum_path, :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We apply <span class="caps">CSS</span> classes from Twitter Bootstrap to style the page. We’ll create a few additional <span class="caps">CSS</span> classes in the next step.</p>
<p>The page contains a “hero unit” for your key marketing message plus three boxes describing subscription plans.</p>
<p>Each box contains a link to a content page. The content pages don’t yet exist; we’ll need to create a Content controller, routes, and views to implement the content pages. Later, we’ll change the links to open a subsciption purchase page instead of a content page.</p>
<h3>
<span class="caps">CSS</span> for Subscription Plans</h3>
<p>We’ll provide some rudimentary <span class="caps">CSS</span> rules to style the home page. We’re using Twitter Bootstrap so we’ll get an attractive design with only a few <span class="caps">CSS</span> rules.</p>
<p>First, modify the <strong>app/assets/stylesheets/application.css.scss</strong> file to remove the following <span class="caps">CSS</span> rules. These rules were useful for the starter app but will not be used in our application:</p>
<pre>
.content {
  background-color: #eee;
  padding: 20px;
  margin: 0 -20px; /* negative indent the amount of the padding to maintain the grid system */
  -webkit-border-radius: 0 0 6px 6px;
  -moz-border-radius: 0 0 6px 6px;
  border-radius: 0 0 6px 6px;
  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  -moz-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  box-shadow: 0 1px 2px rgba(0,0,0,.15);
}
</pre>
<p>Next we’ll add <span class="caps">CSS</span> assets to style the home page.</p>
<p>Create a file <strong>app/assets/stylesheets/pricing.css.scss</strong>:</p>
<pre>
.plans{
  text-align: center;
}
.featured{
  -webkit-transform:scale(1.15);
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.67);
}
.plan{
  background-color: #111575;
}
.plan.featured-plan{
  background-color: #CCAB00;
}
.plan h2{
  line-height: 100px;
  color: #fff;
}
</pre>
<p>This stylesheet gets added automatically to the asset pipeline because any files in the same folder as the <strong>app/assets/stylesheets/application.css.scss</strong> file are added by the <code>*= require_tree .</code> statement.</p>
<p>This <span class="caps">CSS</span> will provide the design elements that are commonly seen on a pricing page: boxes for each plan with an enlarged box for a “featured plan.”</p>
<p>The design is adequate for our tutorial but you may want to improve it to be more effective. If you’re not a designer, you may want to look at the Twitter Bootstrap themes available in the <a href="https://wrapbootstrap.com/">WrapBootstrap</a> marketplace. The theme for <a href="https://wrapbootstrap.com/theme/css3-pricing-tables-WB00H9006">CSS3 Pricing Tables</a> is particularly interesting. It is similar to our home page but adds animated effects. The theme only costs $6 and you can easily integrate it into our application by copying the contents of the designer’s <strong>css/custom.css</strong> file into our <strong>app/assets/stylesheets/pricing.css.scss</strong> file and replacing styles in our <strong>app/views/home/index.html.erb</strong> file.</p>
<h3>Modify the Home Controller</h3>
<p>Modify the file <strong>app/controllers/home_controller.rb</strong> to remove the <code>index</code> method:</p>
<pre>
class HomeController &lt; ApplicationController
end
</pre>
<h3>Commit to Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "home page update"
</pre>
<h2>Administrative Page</h2>
<p>This application provides the <strong>Users#index</strong> page as an administrative dashboard. The CanCan authorization system restricts access to this page to only users in the “admin” role.</p>
<p>The starter application sets up the administrative page:</p>
<ul>
<li>lists users and shows the date each registered</li>
	<li>displays email addresses and roles</li>
	<li>provides buttons to change roles and delete users</li>
</ul><p>For details about how the administrative page is set up by the starter application, see the tutorial:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><h2>Content Pages</h2>
<p>This application can be used for a Software-as-a-Service (SaaS) website or it can be used to limit access to pages containing content such as articles, photos, or video. For purposes of demonstration, we’ll set up the site so a membership is required to view some placeholder content.</p>
<p>Let’s add pages for our placeholder content.</p>
<p>First let’s consider a git workflow for adding a new feature.</p>
<h3>Git Workflow</h3>
<p>When you are using git for version control, you can commit every time you save a file, even for the tiniest typo fixes. If only you will ever see your git commits, no one will care. But if you are working on a team, either commercially or as part of an open source project, you will drive your fellow programmers crazy if they try to follow your work and see such “granular” commits. Instead, get in the habit of creating a git branch each time you begin work to implement a feature. When your new feature is complete, merge the branch and “squash” the commits so your comrades see just one commit for the entire feature.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b content-pages
</pre>
<p>The command creates a new branch named “content-pages” and switches to it, analogous to copying all your files to a new directory and moving to work in the new directory (though that is not really what happens with git).</p>
<h3>Create the Content Controller and Views</h3>
<p>Use the <code>rails generate</code> command to create a controller and associated views:</p>
<pre>
$ rails generate controller content silver gold platinum --skip-stylesheets --skip-javascripts
</pre>
<p>We’ve named the controller the “ContentController.” The default route will put our content pages in an apparent “content” directory with the <span class="caps">URL</span> path <a href="http://localhost:3000/content/">http://localhost:3000/content/</a>. You could give the controller another name if you want a different <span class="caps">URL</span> path but it’s easier to keep the same controller name and change the path in the <strong>config/routes.rb</strong> file (described below).</p>
<p>We’ve asked for three views, corresponding to the three subscription plans we’ll offer. We’ll use <code>--skip-stylesheets --skip-javascripts</code> to avoid cluttering our application with stylesheet and JavaScript files we don’t need.</p>
<p>The Rails generator will create these files for you:</p>
<pre>
app/controllers/content_controller.rb
app/helpers/content_helper.rb
app/views/content/gold.html.erb
app/views/content/platinum.html.erb
app/views/content/silver.html.erb
spec/controllers/content_controller_spec.rb
</pre>
<p>It also modifies the <strong>config/routes.rb</strong> file to add three routes:</p>
<pre>
get "content/silver"
get "content/gold"
get "content/platinum"
</pre>
<p>If you want a different <span class="caps">URL</span> path, you could specify a different path like this: <code>get "articles/silver" =&gt; "content#silver", :as =&gt; :content_silver</code>. Visitors will see a <span class="caps">URL</span> path <a href="http://localhost:3000/articles/silver">http://localhost:3000/articles/silver</a> but you won’t need to make any other changes to the application. We won’t do this; we’ll just use the supplied path.</p>
<p>If you look at <strong>app/controllers/content_controller</strong> controller, you’ll see it is very simple:</p>
<pre>
class ContentController &lt; ApplicationController

  def silver
  end

  def gold
  end

  def platinum
  end
end
</pre>
<p>It may be odd to see a controller that doesn’t contain the familar <code>index</code>, <code>show</code>, etc. methods of a RESTful controller. This is a case where a RESTful controller is not needed or appropriate. By default, the controller will render a view corresponding to each action.</p>
<h3>Check the Content Views</h3>
<p>Open each of the view files to see the placeholder content.</p>
<p><strong>app/views/content/silver.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#silver&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/silver.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/gold.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#gold&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/gold.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/platinum.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#platinum&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/platinum.html.erb&lt;/p&gt;
</pre>
<p>If you’re building a real application, you’ll want to provide content that is more useful than our placeholders. For a membership site that delivers content such as ebooks or videos, you could use a structure such as this, where we’ll restrict access to pages in a <strong>content</strong> directory based on the user’s subscription plan. For a site that delivers software as a service, the structure of your application will necessarily be more complex.</p>
<h3>Test the Content Pages</h3>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your subscription offer.</p>
<p>Visit <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a> to see one of the content pages.</p>
<p>Next we’ll set up access control to limit access to the content pages.</p>
<h3>Git Workflow</h3>
<p>If you haven’t commited any changes yet, commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add content pages"
</pre>
<p>Since the new feature is complete, merge the working branch to “master” and squash the commits so you have just one commit for the entire feature:</p>
<pre>
$ git checkout master
$ git merge --squash content-pages
$ git commit -m "add content pages"
</pre>
<p>You can delete the working branch when you’re done:</p>
<pre>
$ git branch -D content-pages
</pre>
<h2>Limit Access to Content</h2>
<p>We’ve got a home page with links to content pages for Silver, Gold, and Platinum subscribers. And we have created three users: Silver User, Gold User, and Platinum User. Now we’ll set limits on access to the content.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b authorization
</pre>
<h3>Set CanCan Ability</h3>
<p>Modify the <strong>app/models/ability.rb</strong> class to set access limits:</p>
<pre>
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new # guest user (not logged in)
    if user.has_role? :admin
      can :manage, :all
    else
      can :view, :silver if user.has_role? :silver
      can :view, :gold if user.has_role? :gold
      can :view, :platinum if user.has_role? :platinum
    end
  end
end
</pre>
<p>CanCan takes advantage of the Ruby language’s facility to create a <span class="caps">DSL</span> (Domain Specific Language). If you ignore the cryptic punctuation, it’s possible to read the <span class="caps">DSL</span> as if it was English. The statement <code>can :view, :silver if user.has_role? :silver</code> does what it says: If the user has a role of “silver” he or she can view “silver” content. Actually, a good portion of this is arbitrary. CanCan allows us to pass arbitrary parameters to the authorization method and I’ve simply chosen “view” and “silver” to be descriptive. All that matters is to use the same symbols in the Ability class as in the <code>authorize!</code> call in the controller. In the next step, you’ll see how we add the <code>authorize!</code> call to the controller.</p>
<h3>Set Access Limits in the Content Controller</h3>
<p>We’ll modify the <strong>app/controllers/content_controller</strong> file to set access limits:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!

  def silver
    authorize! :view, :silver, :message =&gt; 'Access limited to Silver Plan subscribers.'
  end

  def gold
    authorize! :view, :gold, :message =&gt; 'Access limited to Gold Plan subscribers.'
  end

  def platinum
    authorize! :view, :platinum, :message =&gt; 'Access limited to Platinum Plan subscribers.'
  end
end
</pre>
<p>We add <code>before_filter :authenticate_user!</code> (provided by Devise) to force a visitor to log in before any action.</p>
<p>We use the CanCan <code>authorize!</code> method to check the user’s role (corresponding to their subscription plan) on the actions that render the content pages. We pass two symbols to both <code>authorize!</code> (in the controller) and <code>can</code> (in the Ability class). The symbols can represent anything. By convention, the first symbol is the “action” one is trying to perform and the second symbol is the subject or target the action is being performed on. Our action is to “view” content but we could also say “see”, “access”, or “unlock.” We’ve defined one target as “silver” but it could be “silver_content”, “tier1”, or “plan-A” as long as we are consistent between the controller and Ability class. The CanCan documentation describes <a href="https://github.com/ryanb/cancan/wiki/Non-RESTful-Controllers">CanCan with Non-RESTful Controllers</a>.</p>
<h3>Alternative Implementation</h3>
<p>Keep in mind that we use CanCan only for convenience. You might not agree that CanCan provides benefit, especially when you consider that the CanCan <span class="caps">DSL</span> obscures the authorization mechanism. Cancan offers the advantage of collecting all authorization rules in the Ability class so the rules are easy to find and change. And it provides a familiar idiom for authorization so it is easy for other Rails developers (those who use CanCan) to understand your code.</p>
<p>If CanCan seems mysterious, it might help to see an alternative implementation without CanCan.</p>
<p>Here’s the <strong>app/controllers/content_controller</strong> file without CanCan:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!

  def silver
    if (current_user.has_role? :silver) || (current_user.has_role? :admin)
      render :silver
    else
      redirect_to :back, :notice =&gt; 'Access limited to Silver Plan subscribers.'
    end
  end

  def gold
   if (current_user.has_role? :gold) || (current_user.has_role? :admin)
      render :gold
    else
      redirect_to :back, :notice =&gt; 'Access limited to Gold Plan subscribers.'
    end
  end

  def platinum
    if (current_user.has_role? :platinum) || (current_user.has_role? :admin)
      render :platinum
    else
      redirect_to :back, :notice =&gt; 'Access limited to Platinum Plan subscribers.'
    end
  end
end
</pre>
<p>By using the <code>:authenticate_user!</code> before_filter, Devise makes available the <code>current_user</code> instance of the User model. We still use the <code>has_role?</code> method provided by Rolify. If the current_user has an appropriate role, we render the appropriate page. If not, we redirect to the previous page and display a notice. The code is much easier to understand without CanCan but it is lengthy and repetitive.</p>
<p><em>Note:</em> Please don’t blindly paste the alternative implementation into the <strong>app/controllers/content_controller</strong> file if you want to follow the tutorial. We’ll continue to use CanCan.</p>
<h3>Test Authorization</h3>
<p>You can check that the authorization limits work by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Log in as the first user (the administrator) with “user@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan grants you access as an administrator to any page. Log out.</p>
<p>Log in as the second user (assigned a “silver plan”) with “user2@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan only grants access to the “silver” content page.</p>
<p>Next we’ll set up a page where a visitor can register to use the site after choosing a subscription plan.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add authorization"
$ git checkout master
$ git merge --squash authorization
$ git commit -m "add authorization"
$ git branch -D authorization
</pre>
<h2>Registration Page</h2>
<p>Now that we have a home page with links to our placeholder content pages, plus authorization limits to restrict access based on subscription plan, let’s create a page where a visitor can register for the site and sign up for a subscription.</p>
<p>For the initial version of our registration page, we’ll let the visitor sign up for any subscription for free. Later, we’ll integrate Stripe billing services for purchase of a subscription plan.</p>
<p>The Devise authentication gem provides user management, including signing up users on a registration page. Our starter app already has a User model and uses a Devise controller and views to sign up visitors, asking for a name and email address and creating a user account. We could add a new “subscription purchase” page. Instead, since we already have a sign-up form provided by Devise, it’ll be easier to adapt the existing Devise registration page.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b registration
</pre>
<h3>Modify the Home Page</h3>
<p>We’ll change the links on the home page to direct the visitors to the Devise registration page.</p>
<p>Update the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'silver'), :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'gold'), :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'platinum'), :class =&gt; 'btn btn-primary' %&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We’ve replaced the <span class="caps">URL</span> helper for each of the links:</p>
<ul>
<li>
<code>content_silver_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'silver')</code>
</li>
	<li>
<code>content_gold_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'gold')</code>
</li>
	<li>
<code>content_platinum_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'platinum')</code>
</li>
</ul><p>Notice that we append a parameter to each link to indicate the subscription plan selected by the visitor. We are initiating an <span class="caps">HTTP</span> <span class="caps">GET</span> request so you’ll see a <span class="caps">URL</span> like this: <code>http://lvh.me:3000/users/sign_up?plan=silver</code>.</p>
<h3>Modify the Navigation Links</h3>
<p>Currently visitors see a “Sign up” link on the home page if they are not logged in. We’ll remove the “Sign up” link in the navigation bar because we want them to sign up by selecting a subscription plan.</p>
<p>Modify the file <strong>app/views/layouts/_navigation.html.erb</strong>:</p>
<pre>
&lt;%= link_to "Rails Stripe Membership Saas", root_path, :class =&gt; 'brand' %&gt;
&lt;ul class="nav"&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Logout', destroy_user_session_path, :method=&gt;'delete' %&gt;
    &lt;/li&gt;
  &lt;% else %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Login', new_user_session_path %&gt;
    &lt;/li&gt;
  &lt;% end %&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Edit account', edit_user_registration_path %&gt;
    &lt;/li&gt;
    &lt;% if current_user.has_role? :admin %&gt;
      &lt;li&gt;
      &lt;%= link_to 'Admin', users_path %&gt;
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</pre>
<p>We’ve removed the “Sign up” link.</p>
<h3>Override the Devise Registrations Controller</h3>
<p>Create a file <strong>app/controllers/registrations_controller.rb</strong> to override the Devise registrations controller:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    if @plan
      super
    else
      redirect_to root_path, :notice =&gt; 'Please select a subscription plan below'
    end
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
  end
end
</pre>
<p>Devise provides a Registrations controller inside the Devise gem. It contains standard RESTful controller actions, including <code>new</code> and <code>create</code> (see <a href="https://github.com/plataformatec/devise/blob/master/app/controllers/devise/registrations_controller.rb">Devise::RegistrationsController</a> on GitHub).</p>
<p>We override the controller <code>new</code> action to set the <em>plan</em> variable. This allows us to display the name of the selected subscription plan on the registration page. When we modify the registration form, we’ll include the <em>plan</em> variable in a hidden input field. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons.</p>
<p>If the <em>plan</em> parameter is present, we call the <code>super</code> method to inherit the original controller <code>new</code> action. If the visitor has not selected a plan, we redirect back to the home page and display a message “Please select a subscription plan below.”</p>
<p>Before calling <code>new</code> or <code>create</code>, the Devise Registrations controller initializes a new User with a private method named <code>build_resource</code>. The default <code>build_resource</code> method won’t assign an authorization role to our user. We override the <code>build_resource</code> method, first using the <code>super</code> method to call the parent <code>build_resource</code> method. Then we check if the <em>plan</em> parameter is available. On a <code>new</code> action, it will be available as a parameter passed from the home page. On a <code>create</code> action, it will be passed as a parameter from a hidden input field on the registration form.</p>
<p>If you’re wondering why you don’t see the User model as a <em>@user</em> variable, Devise has aliased it as the <em>resource</em> instance variable (<em>resource</em> allows Devise to accommodate models with names other than User, such as Account or Person).</p>
<p>Rolify has added the <code>add_role</code> method to the User model, so we call <code>add_role</code> to assign the plan as an authorization role.</p>
<p>Instead of overriding the controller <code>new</code> action, we could use a <code>before_filter</code> to set the <em>plan</em> variable before the <code>new</code> method is called. We could do this:</p>
<pre>
  before_filter :set_plan, :only =&gt; :new

  def set_plan
    @plan = params[:plan]
  end
</pre>
<p>Either implementation is effective; we’ve chosen to  override the <code>new</code> method rather than using a <code>before_filter</code>.</p>
<h3>Override the Devise Routes</h3>
<p>Modify <strong>config/routes.rb</strong> to use the new controller. Replace <code>devise_for :users</code> with:</p>
<pre>
devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
</pre>
<p>You’ve modified the routes file, so you must restart the server for any changes to take effect.</p>
<h3>Modify the Devise Registration Page</h3>
<p>We’ll use the Devise registration page as our subscription sign-up form.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong> to add details about the subscription plan:</p>
<pre>
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form form-vertical' }) do |f| %&gt;
  &lt;h3&gt;&lt;%= params[:plan].titleize if params[:plan] %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'plan', params[:plan] %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>We display the name of the selected subscription plan. The <code>titleize</code> method transforms the <em>plan</em> string from lowercase to titlecase.</p>
<p>We add a hidden input field with <code>hidden_field_tag</code> to include a parameter identifying the selected subscription plan. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons and set as a variable by our Registrations controller.</p>
<p>We remove the <code>&lt;%= render "devise/shared/links" %&gt;</code> navigation links because we already have a login link in the page navigation bar.</p>
<p>When we submit the form, Rails does its form processing magic, including validation of the model attributes, and saves the new User record to the database.</p>
<h3>Test Registration</h3>
<p>You can check that registration works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in and submit the form. You’ll see a message “Welcome! You have signed up successfully.” Note that we’re not using the Devise Confirmable module so the application doesn’t send a confirmation email. You’ll be logged in as the new user as soon as you submit the form.</p>
<p>If you’ve selected the Silver Plan for the new user, try visiting <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a>. You should be able to view the page. You should see an error message if you attempt to visit  <a href="http://localhost:3000/content/gold">http://localhost:3000/content/gold.html</a>.</p>
<p>Now we have a registration page that assigns a subscription plan when a visitor signs up for the site. In the next step, we’ll make sure the user gets redirected to an appropriate page after sign up or log in.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add registration"
$ git checkout master
$ git merge --squash registration
$ git commit -m "add registration"
$ git branch -D registration
</pre>
<h2>Redirect After Sign Up or Log In</h2>
<p>As currently implemented, when a user signs up or logs in, they see the home page with a confirmation message. Instead, we want a user to be redirected to a page that is an appropriate hub for their role or subscription tier.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b redirect
</pre>
<h3>Modify the Application Controller</h3>
<p>Modify the file <strong>app/controllers/application_controller.rb</strong>:</p>
<pre>
class ApplicationController &lt; ActionController::Base
  protect_from_forgery

  rescue_from CanCan::AccessDenied do |exception|
    redirect_to root_path, :alert =&gt; exception.message
  end

  def after_sign_in_path_for(resource)
    case current_user.roles.first.name
      when 'admin'
        users_path
      when 'silver'
        content_silver_path
      when 'gold'
        content_gold_path
      when 'platinum'
        content_platinum_path
      else
        root_path
    end
  end

end
</pre>
<p>The <code>after_sign_in_path_for(resource)</code> method will redirect a user to an appropriate page after sign in or sign up. The <code>case</code> statement checks the user’s role and redirects to the appropriate content page, or if an administrator, to the administrative dashboard.</p>
<p>When we use Rolify, each user can have multiple roles. We only assign a single role in this application, so we ask for the first role associated with the user. When a role object is displayed as a string, it will be a number, so we ask for the name attribute of the role.</p>
<p>Devise also offers an <code>after_sign_up_path_for(resource)</code> method that allows a different redirect after a user registers. You could implement the <code>after_sign_up_path_for(resource)</code> method if you wanted the new user to see a special page after sign up (for example, a thank you or introduction).</p>
<h3>Test Redirect</h3>
<p>You can check that the redirect works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Subscribe to any subscription plan. You should be redirected to the appropriate page and see a message “Welcome! You have signed up successfully.” Log out and log in. You should be redirected to the appropriate page.</p>
<p>In the next step, we’ll integrate Stripe payment for subscription plans.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "redirect after log in"
$ git checkout master
$ git merge --squash redirect
$ git commit -m "redirect after log in"
$ git branch -D redirect
</pre>
<h2>Stripe Integration</h2>
<p>We’ve got a fully functional web application that serves up placeholder content to registered users and restricts access based on the subscription plan the user has selected. Now we’ll integrate Stripe billing so we can charge users for subscriptions.</p>
<p>Remember we’re using our Devise registration page for subscription sign up. We’ll make this our payment page. We’ll ask the visitor to enter credit card data on this page.</p>
<p>Here’s the most obvious way to implement billing:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>data is received by your application on your server</li>
	<li>an application controller <code>create</code> action initiates a request to the payment processor</li>
	<li>the <code>create</code> method receives an acknowledgment of a completed or declined transaction</li>
	<li>the <code>create</code> method saves the user data (and creates an account) or shows an error message</li>
</ul><p>There’s a big drawback to this approach: Credit card data is sent to your server. Your server becomes a target for thieves and you must secure the server and maintain <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> (the credit card industry security standard).</p>
<p>Instead, Stripe offers an architecture that cuts risk and makes it much easier to meet <span class="caps">PCI</span> compliance requirements. Stripe provides a JavaScript file that we add to our payment page. We set a public key in the JavaScript code to identify our Stripe account. We trigger the JavaScript code when the user submits the payment form. The JavaScript code obtains the credit card data from our form, transmits the data to Stripe’s servers, and returns a unique token that serves as a substitute for the credit card data. Stripe takes responsibility for the security of the credit card data and it never touches our server. We can safely use the Stripe token as a substitute for credit card data when we make a request to Stripe to bill the user.</p>
<p>Here is our preferred program flow:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>a JavaScript function sends the card data to Stripe’s servers</li>
	<li>a JavaScript callback receives a Stripe token or an error message</li>
	<li>the JavaScript function submits the form to our server, substituting the token for credit card data</li>
	<li>a User model <code>before_save</code> method sends a request (with the token) to Stripe to create a customer account</li>
	<li>the User model <code>before_save</code> method receives an acknowledgment of a completed or declined transaction</li>
	<li>a Registrations controller <code>create</code> action saves the user data or shows an error message</li>
</ul><p>This hybrid approach makes implementation more complex but the result is robust and secure.</p>
<p>Here are useful resources for understanding the implementation:</p>
<ul>
<li>RailsCast <a href="http://railscasts.com/episodes/288-billing-with-stripe">Billing with Stripe</a>
</li>
	<li><a href="https://stripe.com/docs">Stripe documentation</a></li>
	<li>Stripe’s <a href="https://github.com/stripe/monospace-rails">monospace-rails</a> sample Rails application</li>
	<li><a href="http://net.tutsplus.com/tutorials/other/so-you-want-to-accept-credit-cards-online/">Nettuts: Stripe Tutorial</a></li>
</ul><p>We’ve followed Ryan Bates’s implementation from his RailsCast on Stripe in several key areas. Thank you, Ryan!</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b billing
</pre>
<h3>Add Virtual Attributes to the User Model</h3>
<p>When a new user signs up for a subscription, we’ll use JavaScript on the registration page to submit credit card data to Stripe and obtain a Stripe token that substitutes for credit card data. The Stripe token will be included as a hidden field when the user submits the registration form.</p>
<p>Before we can include a hidden field in the form, we must modify the User model to accept this field. It doesn’t need to be added to the User database schema as it will only be used when the form is processed by the Registrations controller. We’ll add it as a virtual attribute. For more on virtual attributes, see the RailsCast <a href="http://railscasts.com/episodes/16-virtual-attributes-revised">Virtual Attributes</a>.</p>
<p>We’ll also add a <code>coupon</code> field as a virtual attribute.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :stripe_token, :coupon
  attr_accessor :stripe_token, :coupon

end
</pre>
<p>We add the virtual attribute with <code>attr_accessor</code> which will automatically create getter and setter methods and store the <code>stripe_token</code> and <code>coupon</code> values as instance variables. Also we add the <code>stripe_token</code> and <code>coupon</code> fields to the <code>attr_accessible</code> list so they can be set through mass assignment from a form submission.</p>
<p>With the new virtual attributes in place, we will begin work on the forms that submit the credit card data.</p>
<h3>Use a Metatag to Set the Stripe Public Key</h3>
<p>Stripe provides a unique public key that identifies your website and authenticates a request to the Stripe servers.</p>
<p>You’ve set the Stripe public key in your <strong>config/application.yml</strong> file. We put it there for convenience, so your Stripe configuration settings are in one location and easier to copy to Heroku for deployment. Unlike the Stripe <span class="caps">API</span> key, the public key doesn’t need to stay secret.</p>
<p>We set a constant <code>STRIPE_PUBLIC_KEY</code> in the file <strong>config/initializers/stripe.rb</strong>. For ease in testing, we use a constant rather than using the environment variable directly.</p>
<p>Now we must make the public key available to the JavaScript code we’ll use to submit credit card data to the Stripe server.</p>
<p>We have several options. We could hardcode the Stripe public key in the JavaScript code we’ll write. But it is easier to use the constant we’ve already set, so we’re using the same value in development, testing, and production. We could include the constant as a Ruby variable in the JavaScript code by giving the JavaScript file an <strong>.erb</strong> extension. But we’d like to avoid mixing Ruby variables into JavaScript. So instead we’ll use an advanced technique to set the Stripe public key constant as a metatag that can be accessed using conventional JavaScript.</p>
<p>We only want the metatag to appear on pages that contain forms that submit credit card data to Stripe. We’ll use a combination of a <code>content_for?</code> view helper with <code>yield</code> to inject the metatag into the application layout from the <strong>app/views/devise/registrations/new.html.erb</strong> and <strong>app/views/devise/registrations/edit.html.erb</strong> files. Our application layout already includes <code>&lt;%= yield(:head) %&gt;</code> so we can easily add additional tags to the page <span class="caps">HEAD</span> element.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= tag :meta, :name =&gt; "stripe-key", :content =&gt; STRIPE_PUBLIC_KEY %&gt;
&lt;% end %&gt;
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form form-vertical' }) do |f| %&gt;
  &lt;h3&gt;&lt;%= params[:plan].titleize if params[:plan] %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'plan', params[:plan] %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>The <code>&lt;% content_for :head do %&gt;</code> block injects the <code>STRIPE_PUBLIC_KEY</code> in the application layout as a metatag named “stripe-key.”</p>
<p>Do the same for the file <strong>app/views/devise/registrations/edit.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= tag :meta, :name =&gt; "stripe-key", :content =&gt; STRIPE_PUBLIC_KEY %&gt;
&lt;% end %&gt;
&lt;h2&gt;Edit &lt;%= resource_name.to_s.humanize %&gt;&lt;/h2&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; { :method =&gt; :put, :class =&gt; 'form-vertical' }) do |f| %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :autocomplete =&gt; "off", :hint =&gt; "leave it blank if you don't want to change it", :required =&gt; false %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; false %&gt;
  &lt;%= f.input :current_password, :hint =&gt; "we need your current password to confirm your changes", :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Update', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
&lt;h3&gt;Cancel my account&lt;/h3&gt;
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete %&gt;.&lt;/p&gt;
&lt;%= link_to "Back", :back %&gt;
</pre>
<p>Any JavaScript used on these two pages will have access to the Stripe public key through a jQuery selector. It’s more complicated than hardcoding the Stripe public key or using a Ruby variable in the JavaScript but the layers of indirection make the implementation more robust.</p>
<p>With the Stripe public key set as a metatag, we will add fields for credit card data to the form.</p>
<h3>Add Credit Card Data to the Registration Form</h3>
<p>We’ll need fields for a credit card number, security code, and expiration date.</p>
<p>We’ll also add a placeholder <code>div</code> for any error messages returned by the Stripe server.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= tag :meta, :name =&gt; "stripe-key", :content =&gt; STRIPE_PUBLIC_KEY %&gt;
&lt;% end %&gt;
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;div id="stripe_error" class="alert alert-error" style="display:none" &gt;
&lt;/div&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form form-vertical' }) do |f| %&gt;
  &lt;h3&gt;&lt;%= params[:plan].titleize if params[:plan] %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'plan', params[:plan] %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;% if @user.stripe_token %&gt;
    &lt;p&gt;Credit card acceptance is pending.&lt;/p&gt;
  &lt;% else %&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
      &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
      &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_month, "Card Expiration" %&gt;
      &lt;%= select_month nil, {add_month_numbers: true}, {name: nil, id: "card_month"}%&gt;
      &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= f.input :coupon, :label =&gt; 'Promotional Coupon (if any)' %&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  &lt;%= f.hidden_field :stripe_token %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>Take a look at <code>div id="stripe_error"</code>. We give it the “alert alert-error” style from Twitter Bootstrap. It remains hidden with a <code>style="display:none"</code> unless we use JavaScript to show it when we receive an error message from the Stripe server. We’ll add the necessary JavaScript soon.</p>
<p>If you examine the <span class="caps">HTML</span> source, you will see:</p>
<pre>
&lt;form accept-charset="UTF-8" action="/users" class="card_form form-vertical" id="new_user" method="post"&gt;
</pre>
<p>The Rails form builder creates a form with the id <code>new_user</code>. The id is generated automatically from the controller and action names “user” and “new”. We assign the class <code>card_form</code> to the form. Our JavaScript code will interact with the form. We could select the form with the “new_user” id but instead we’ll use the “card_form” class in our jQuery selector. This gives us flexibility to use the same JavaScript code to interact with either a “new registration” or “edit registration” form.</p>
<p>We’ve added fields for credit card data but we’ve made inclusion of the fields conditional on the absence of the <code>@user.stripe_token</code> attribute. This accommodates a situation where correct credit card data is provided but the form fails to pass a validation test (such as a blank email address). If Stripe accepts the credit card data and provides a <code>stripe_token</code> but there’s no email address, we’ll save the Stripe token in the hidden field and prompt the user to correct the email address.</p>
<p>Notice the differences between the credit card data fields and the previous data fields.</p>
<p>The name, email, and password fields correspond to attributes of the User model. We use the Rails form builder object (the <em>f</em> variable) to bind the form to the User model. Methods such as <code>f.text_field</code> create form controls using the form builder object which automatically populate the attributes of the User model.</p>
<p>The credit card data fields do not correspond to attributes of the User model so we can’t use the form builder object. We use the more primitive <code>label_tag</code> and <code>text_field_tag</code> instead. Notice we specify the <code>name:</code> of the element as nil. For the expiration <code>select_month</code> and <code>select_year</code> we also set an element ID to replace the ID that the Rails form helper generates. Thus the fields will be available to our JavaScript code but will not be submitted to the server.</p>
<p>We add a hidden field to the form named <code>stripe_token</code>. We’ll soon add JavaScript to submit credit card data from the form and obtain a Stripe token from the Stripe server. The JavaScript code will add the Stripe token to the hidden field before submitting the form to our server.</p>
<p>Now we’ll add the JavaScript to process the form.</p>
<h3>Adding JavaScript from the Stripe Server</h3>
<p>There are several approaches to accessing external JavaScript libraries and setting up scripts to only run on a specific page. For a comprehensive introduction to using external JavaScript libraries and page-specific JavaScript, see our article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Adding JavaScript to Rails</a>.</p>
<p>Developers often copy external JavaScript libraries to the <strong>vendor/assets/javascripts</strong> folder and let the Rails asset pipeline combine all the JavaScript, making it available throughout the application. That’s not how we want to handle the Stripe JavaScript library. We don’t want to store it in our application where a trespasser could modify it to intercept credit card data. It is best to load it from Stripe’s server. And we want to execute it only on the registration page.</p>
<p>We’ll use two techniques described in the article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Adding JavaScript to Rails</a>. We’ll add a script named <em>jquery.readyselector.js</em> (from <a href="https://github.com/Verba/jquery-readyselector">John Firebaugh</a>) that allows us to execute JavaScript conditionally on a page. A second script, <em>jquery.externalscript.js</em>, extends jQuery to add a function that allows us to download (or load from the cache) a JavaScript file from a remote server.</p>
<h3>Script for Conditional Execution of Page-Specific JavaScript</h3>
<p>First, make sure that the application layout file is set to provide parameters needed for the <em>jquery.readyselector.js</em> script. The default RailsApps application layout file <strong>app/views/layouts/application.html.erb</strong> should already contain a <code>&lt;body&gt;</code> tag that looks like this:</p>
<pre>
&lt;body class="&lt;%= controller_name %&gt; &lt;%= action_name %&gt;"&gt;
</pre>
<p>If it doesn’t, make sure to add it now.</p>
<p>We’ll add a script that will help us execute JavaScript conditionally on a page.</p>
<p>Create a file <strong>app/assets/javascripts/jquery.readyselector.js</strong>:</p>
<pre>
(function ($) {
  var ready = $.fn.ready;
  $.fn.ready = function (fn) {
    if (this.context === undefined) {
      // The $().ready(fn) case.
      ready(fn);
    } else if (this.selector) {
      ready($.proxy(function(){
        $(this.selector, this.context).each(fn);
      }, this));
    } else {
      ready($.proxy(function(){
        $(this).each(fn);
      }, this));
    }
  }
})(jQuery);
</pre>
<p>If you prefer CoffeeScript, you can convert JavaScript to CoffeeScript <a href="http://js2coffee.org/">here</a> or <a href="http://js2cs.nodejitsu.com/">here</a>.</p>
<p>If you haven’t changed the default manifest file, the <em>jquery.readyselector.js</em> script will be automatically loaded by the <code>//= require_tree .</code> directive in the <strong>app/assets/javascripts/application.js</strong> manifest file. If you’ve removed the <code>//= require_tree .</code> directive, specify the script in the <strong>app/assets/javascripts/application.js</strong> manifest file:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require jquery.readyselector
</pre>
<h3>Script for Dynamic Loading of Remote JavaScript Files</h3>
<p>Here’s how we can download (or load from the cache) a JavaScript file from a remote server.</p>
<p>Other approaches to downloading a JavaScript file from a remote server require adding additional <code>&lt;script&gt;</code> tags to the page. For the optimal performance, it is better to use the following technique. See our article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Adding JavaScript to Rails</a> for details.</p>
<p>Create a file <strong>app/assets/javascripts/jquery.externalscript.js</strong>:</p>
<pre>
jQuery.externalScript = function(url, options) {
  options = $.extend(options || {}, {
    dataType: "script",
    cache: true,
    url: url
  });
  return jQuery.ajax(options);
};
</pre>
<p>If you haven’t changed the default manifest file, the <em>jquery.externalscript.js</em> script will be automatically loaded by the <code>//= require_tree .</code> directive. If you’ve removed the <code>//= require_tree .</code> directive, specify the script in the manifest:</p>
<pre>
//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require jquery.readyselector
//= require jquery.externalscript
</pre>
<p>Next we’ll combine functions from these two scripts to load the Stripe JavaScript library.</p>
<h3>Create a Registrations JavaScript File</h3>
<p>We’ll create a new file for our page-specific JavaScript and give the file the same name as the controller. For now, we’ll only create some test code.</p>
<p>Create a file <strong>app/assets/javascripts/registrations.js</strong>:</p>
<pre>
$('.home.index').ready(function() {
  console.log("Page-specific JavaScript on the home.index page.");
});

$('.registrations.new').ready(function() {
  console.log("Page-specific JavaScript on the registrations.new page.");
});

$('.registrations').ready(function() {
  $.externalScript('https://js.stripe.com/v1/').done(function(script, textStatus) {
    console.log('Script loading: ' + textStatus );
    if (typeof Stripe != 'undefined') {
      console.log('Okay. Stripe file loaded.');
    }
    else
    {
      console.log('Problem. Stripe file not loaded.');
    }
  });
});
</pre>
<p>This code will test if the Stripe JavaScript library has been successfully downloaded.</p>
<p>Later we will add the code that collects the credit card data from the subscription form, submits it to the Stripe server, and obtains the Stripe token.</p>
<p>Let’s test the code to make sure the Stripe JavaScript library is loading from the remote server.</p>
<p>Start the server and visit the home page. Check the JavaScript console to observe the debugging messages.</p>
<p>Here’s how to use the JavaScript console. Every web browser provides access to the JavaScript console for debugging. In Chrome, choose the menu item <em>View/Developer/JavaScript Console</em>. Reload the page and you will see console messages. We’ve added console messages to trace the program flow as each function is executed. Use this technique for debugging if you have problems.</p>
<p>When you visit the home page, you should see a debugging message in the JavaScript console:</p>
<pre>
Page-specific JavaScript on the home.index page.
</pre>
<p>Click a “Subscribe” button. You should see the registration page. You’ll see more debugging messages in the JavaScript console:</p>
<pre>
Page-specific JavaScript on the registrations.new page.
Script loading: success
Okay. Stripe file loaded.
</pre>
<p>If you see these messages, you’re ready to continue.</p>
<h3>Add JavaScript for Form Processing</h3>
<p>We need code that runs in the browser to submit the credit card data to Stripe and obtain a Stripe token before the form is sent to our server.</p>
<p>Replace the contents of <strong>app/assets/javascripts/registrations.js</strong> with this:</p>
<pre>
$('.registrations').ready(function() {
  $.externalScript('https://js.stripe.com/v1/').done(function(script, textStatus) {
    if (typeof Stripe != 'undefined') {
      console.log('Stripe JavaScript file loaded.');
    }
    else
    {
      console.log('Problem: Stripe JavaScript file not loaded.');
    }
    Stripe.setPublishableKey($('meta[name="stripe-key"]').attr('content'));
    console.log('set Stripe public key: ' + $('meta[name="stripe-key"]').attr('content'));
    var subscription = {
      setupForm: function() {
        console.log('function: setupForm')
        return $('.card_form').submit(function() {
          console.log('setupForm: form submitted')
          $('input[type=submit]').prop('disabled', true);
          subscription.processCard();
          return false;
        });
      },
      processCard: function() {
        console.log('function: processCard');
        var card;
        card = {
          name: $('#user_name').val(),
          number: $('#card_number').val(),
          cvc: $('#card_code').val(),
          expMonth: $('#card_month').val(),
          expYear: $('#card_year').val()
        };
        return Stripe.createToken(card, subscription.handleStripeResponse);
      },
      handleStripeResponse: function(status, response) {
        console.log('function: handleStripeResponse');
        if (status === 200) {
          return alert('Stripe response: ' + response.id);
        } else {
          return alert('Stripe response: ' + response.error.message);
        }
      }
    };
    return subscription.setupForm();
  });
});
</pre>
<p>This is not the final version of the JavaScript code; it contains debugging messages so you can verify the code is working.</p>
<p>We add the functionality we need to process a form and submit the credit card data to the Stripe server. We’ll look closely at the code in the next section. For now, let’s test the new code.</p>
<p>Start the server and visit the page. Check the JavaScript console to observe the debugging messages. Fill out the form, using a fake credit card number.</p>
<p>Stripe provides a set of fake credit card numbers which will force various responses. See the <a href="https://stripe.com/docs/testing">Stripe Testing</a> documentation. Here are some useful numbers:</p>
<ul>
<li>a fake Visa card: <em>4242424242424242</em>
</li>
	<li>incorrect number: use a number that fails the checksum, e.g. <em>4242424242424241</em>
</li>
	<li>invalid expiry month: use an invalid month, e.g. <em>13</em>
</li>
	<li>invalid expiry year: use a year in the past, e.g. <em>1970</em>
</li>
	<li>invalid cvc: use a two digit number, e.g. <em>99</em>
</li>
</ul><p>Submit the form. You should see an alert displaying the response from the Stripe server.</p>
<p>It’s fun (for a few minutes) to enter various numbers and observe the response from the Stripe server.</p>
<p>Here’s what you should see in the JavaScript console:</p>
<pre>
Stripe JavaScript file loaded.
set Stripe public key: ...
function: setupForm
setupForm: form submitted
function: processCard
function: handleStripeResponse
</pre>
<p>Yea! You’re communicating with the Stripe server.</p>
<p>Now that you’ve confirmed you can send credit card data to the Stripe server, remove the debugging code from the script. While we’re at it, we’ll add the code to handle the response from the Stripe server.</p>
<p>Replace the contents of <strong>app/assets/javascripts/registrations.js</strong> with this:</p>
<pre>
$('.registrations').ready(function() {
  $.externalScript('https://js.stripe.com/v1/').done(function(script, textStatus) {
      Stripe.setPublishableKey($('meta[name="stripe-key"]').attr('content'));
      var subscription = {
        setupForm: function() {
          return $('.card_form').submit(function() {
            $('input[type=submit]').prop('disabled', true);
            if ($('#card_number').length) {
              subscription.processCard();
              return false;
            } else {
              return true;
            }
          });
        },
        processCard: function() {
          var card;
          card = {
            name: $('#user_name').val(),
            number: $('#card_number').val(),
            cvc: $('#card_code').val(),
            expMonth: $('#card_month').val(),
            expYear: $('#card_year').val()
          };
          return Stripe.createToken(card, subscription.handleStripeResponse);
        },
        handleStripeResponse: function(status, response) {
          if (status === 200) {
            $('#user_stripe_token').val(response.id)
            $('.card_form')[0].submit()
          } else {
            $('#stripe_error').text(response.error.message).show();
            return $('input[type=submit]').prop('disabled', false);
          }
        }
      };
      return subscription.setupForm();
  });
});
</pre>
<p>Here’s an explanation of the JavaScript.</p>
<p>We restrict execution of the code to a page that has a class “registrations.” In this case, the code will run on the Registrations#New page. It will also run on the Registrations#Edit page which we will set up later.</p>
<p>We use the <code>externalScript</code> function to obtain the Stripe JavaScript library from the Stripe server (or a local cache).</p>
<p>We obtain the Stripe public key. You’ll recall it is initially set as an environment variable in the <strong>config/application.yml</strong> file, set as a constant in the <strong>config/initializers/stripe.rb</strong> file, and injected as a metatag in the application layout by the <strong>app/views/devise/registrations/new.html.erb</strong> view. It is finally obtained from the metatag with a jQuery selector.</p>
<p>We create a <code>subscription</code> object with several functions: <code>setupForm</code>, <code>processCard</code>, and <code>handleStripeResponse</code>.</p>
<p>We call the <code>setupForm</code> function which listens for the form submission event. When the visitor submits the form, the submit button is disabled (so the user can’t press it repeatedly) and the <code>processCard</code> function is called. Returning <code>false</code> makes sure the form is not submitted to our server at this stage. Notice that we don’t call the <code>processCard</code> function if the credit card number is blank; instead we return “true” which submits the form. This will be true if the credit card data was previously accepted (and a Stripe token is included in the hidden field) but there was an error such as a missing email address.</p>
<p>The <code>processCard</code> function parses the form and obtains the credit card data. Then it calls a function from the Stripe library named <code>createToken</code> which submits the card data to the Stripe server. When the Stripe server returns a response, we call the <code>handleStripeResponse</code> function.</p>
<p>The <code>handleStripeResponse</code> function checks the <span class="caps">HTTP</span> status code. If it is okay (status code 200), the function sets the <code>stripe_token</code> hidden field in the form (it has the <span class="caps">HTML</span> element ID “user_stripe_token”) and calls <code>submit</code> on the element with the “card_form” class (which is the form). If the <span class="caps">HTTP</span> status code is not okay, the function sets the error message from the Stripe server in the <code>stripe_error</code> div and re-enables the submit button.</p>
<p>In effect, we modify the form’s submit button so that the credit card data is first sent to the Stripe server, the Stripe token is obtained and set in a hidden field, and then the form is submitted to our application for processing by our Registrations controller.</p>
<p>You can start the server and create a subscription. Use the fake credit card number <em>4242424242424242</em>. You’ll see an error message on the page if the credit card data is incomplete. If the credit card data is accepted, a new User account will be created and you’ll be redirected to an appropriate content page where you’ll see a message “Welcome! You have signed up successfully.”</p>
<p>But wait. We’ve created a new User account but we haven’t charged the user for the subscription. To do so, we’ll modify the User model to create a new Stripe customer and initiate a credit card transaction when a new user is created.</p>
<h3>Prepare Your Stripe Account</h3>
<p>Before we can modify the User model to create a new Stripe customer, we have to prepare our Stripe account to recognize the parameters we’ll be saving. We have to set up our subscription plans in Stripe.</p>
<p>This step is necessary if you’re going to use Stripe to automatically handle recurring billing. We’ll tell Stripe that we have three plans named “Silver”, “Gold”, and “Platinum” that will be billed monthly at rates of $9, $19, and $29. Once a customer is created and assigned a plan, Stripe will do all the work of initiating monthly billing and retrying the transaction when a credit card is declined or expires.</p>
<p>Go to the Stripe <a href="https://manage.stripe.com/#plans">plan management page</a> to create a subscription plan. Stripe offers <a href="https://stripe.com/docs/subscriptions">documentation about creating a plan</a> and <a href="https://stripe.com/docs/api#plans">additional detail about plans</a>.</p>
<p>Look for the toggle switch “Live/Test” and set it to “Test.” Click the button to “Create your first plan.”</p>
<p>Create three different plans with the following values:</p>
<table>
<tr>
<th>ID </th>
		<th>Name </th>
		<th>Amount </th>
		<th>Interval </th>
	</tr>
<tr>
<td> silver </td>
		<td> Silver </td>
		<td> 9.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> gold </td>
		<td> Gold </td>
		<td> 19.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> platinum </td>
		<td> Platinum </td>
		<td> 29.00 </td>
		<td> monthly </td>
	</tr>
</table><p>“ID” is a unique string of your choice that is used to identify the plan when subscribing a customer. In our application, each plan should have an ID that corresponds to the roles we’ve created to manage access. “Name” is displayed on invoices and in the Stripe web interface. “Amount” is the subscription price in US dollars. “Interval” is the billing frequency. Optionally, you can specify a trial period (in days). If you include a trial period, the customer won’t be billed for the first time until the trial period ends. If the customer cancels before the trial period is over, she’ll never be billed at all.</p>
<p>Now that Stripe knows about our subscription plans, we’ll modify the User model to create a new Stripe customer.</p>
<h3>Modify the User Model</h3>
<p>We want to make a request to Stripe to create a customer whenever a new user is created. There are several ways we could do this:</p>
<ul>
<li>modify the Registrations controller <code>create</code> action to initiate a request to Stripe</li>
	<li>add a new method such as <code>save_new_customer</code> to the User model and swap it for the <code>save</code> method used in the Registrations controller <code>create</code> action</li>
	<li>add a <code>save_new_customer</code> method to the User model and call it with <code>before_create</code> in the User model</li>
	<li>add an <code>update_stripe</code> method to the User model and call it with <code>before_save</code> in the User model</li>
</ul><p>The first option, modifying the Registrations controller, results in the much-abhorred “fat controller” anti-pattern. We’ll avoid that. The second option moves the Stripe request to the model but there is no need to modify the Registrations controller to use an alternative to the <code>save</code> method. The third option requires no changes to the Registrations controller but only contacts Stripe when a new user is created. The fourth option is optimal. We’ll add an <code>update_stripe</code> method that is called whenever the user instance is saved. This approach allows us to either create a new Stripe customer on <code>create</code> or update the Stripe customer record on <code>update</code>.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :stripe_token, :coupon
  attr_accessor :stripe_token, :coupon
  before_save :update_stripe

  def update_stripe
    return if email.include?(ENV['ADMIN_EMAIL'])
    return if email.include?('@example.com') and not Rails.env.production?
    if customer_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      if coupon.blank?
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name
        )
      else
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name,
          :coupon =&gt; coupon
        )
      end
    else
      customer = Stripe::Customer.retrieve(customer_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.customer_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "#{e.message}."
    self.stripe_token = nil
    false
  end

end
</pre>
<p>We add <code>before_save :update_stripe</code> to call the <code>update_stripe</code> method when the user is saved or updated.</p>
<p>The <code>before_save</code> callback is carried out after validation so there will be no attempt to create a Stripe customer if an email address is missing or if there are other validation errors.</p>
<p>The <code>update_stripe</code> method makes our request to the Stripe service. We skip the process if the email address contains our administrator’s email address or includes “example.com”. This allows us to run <code>rake db:seed</code> or <code>rake db:reset</code> to set up our administrative user and default sample accounts for this tutorial.</p>
<p>The <code>update_stripe</code> method checks if the user instance already has a <code>customer_id</code>. If it does not, and a <code>stripe_token</code> is present, we can create a new Stripe customer. To create a new Stripe customer, we make a request using the Stripe <span class="caps">API</span> call <code>Stripe::Customer.create</code>.</p>
<p>We will create a new subscription when we create a new customer. We provide the customer’s email address and name. We supply the <code>stripe_token</code> which tells Stripe how to charge the customer. We provide a <code>plan</code> which tells Stripe how much to charge. We’re using Rolify roles to designate subscription plans so we retrieve the role name and use it to designate the subscription plan.</p>
<p>If we have a coupon, we include a <code>coupon</code> identifier so Stripe will apply a discount.</p>
<p>We don’t transmit any credit card data. Stripe already has the credit card data keyed to the stripe token; we transmit the token instead of providing credit card data.</p>
<p>If <code>customer_id</code> is already available as an attribute of the user instance, we know that we’re updating a record rather than creating a new customer. We use the Stripe <span class="caps">API</span> call <code>Stripe::Customer.retrieve(customer_id)</code> to obtain a customer object and then reset the email address and name. If a <code>stripe_token</code> is present, we tell Stripe to use a new credit card. We’ll implement this function when we modify the application’s “Edit Account” feature.</p>
<p>After create or update, we obtain the last four digits of the user’s credit card number. We finish by setting the <code>customer_id</code> to match the Stripe customer ID and we set the stripe token to nil.</p>
<p>The <code>update_stripe</code> method sets user attributes <code>customer_id</code> and <code>last_4_digits</code> which are saved with the attributes passed from the form when the Registration controller completes the <code>user.save</code> call.</p>
<p>We handle errors with a <code>rescue</code> condition. Errors in credit card data will be caught by the JavaScript functions before the form is submitted to the server. If another type of error prevents the Stripe customer from being created, the <code>rescue</code> condition will set an error message and return false which will prevent the user account from being saved.</p>
<h3>Test Stripe Integration</h3>
<p>We have all the code needed for visitors to sign up for new subscriptions. Let’s test the application.</p>
<p>Reset the database:</p>
<pre>
$ rake db:reset
</pre>
<p>Start the web server:</p>
<pre>
$ rails server
</pre>
<p>Visit <a href="http://localhost:3000/">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in the form using the fake credit card number <em>4242424242424242</em>. Submit the form.</p>
<p>You’ll be redirected to an appropriate page and see a message “Welcome! You have signed up successfully.” You’ll be logged in as a new user. If you’ve selected the Silver Plan for the new user, you should be on the page  <a href="http://localhost:3000/content/silver.html">http://localhost:3000/content/silver.html</a>. You should see an error message if you attempt to visit <a href="http://localhost:3000/content/gold.html">http://localhost:3000/content/gold.html</a>.</p>
<p>Visit your Stripe dashboard at <a href="https://manage.stripe.com/#test/customers">https://manage.stripe.com/#test/customers</a> and see the new customer you’ve created. If you check the customer details, you should see that the fake credit card was billed and the subscription status is “active.”</p>
<p>Pat yourself on the back! You’ve reached a milestone. You now can take credit card payments for subscriptions.</p>
<p>There’s more to do, however:</p>
<ul>
<li>modify “edit account” so users can change credit cards, change plans, and unsubscribe</li>
	<li>implement Stripe “webhooks” so expired subscribers will be denied access to the site</li>
</ul><p>Let’s update our Git repository before we continue.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add stripe"
$ git checkout master
$ git merge --squash billing
$ git commit -m "add stripe"
$ git branch -D billing
</pre>
<h2>Account Changes</h2>
<p>We’ve completed integration with Stripe so we can sign up new subscribers. Stripe will automatically bill their credit cards every month. But what happens when a subscriber wants to use a different credit card for payments? We could require them to cancel their subscription and create a new one. It would be better if they could edit their account to change their credit card.</p>
<p>We’ll also make it easy for a subscriber to upgrade or downgrade a subscription plan and cancel a subscription.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b change-acct
</pre>
<h3>Change the “Edit account” Page</h3>
<p>Our “Edit account” page is very similar to the registration page. In its rudimentary form, it contains a simple form to change the user’s name, email address, or password. We will add two additional forms that are hidden on the page and are revealed as modal windows when a “Change plan” or “Change card” button is clicked.</p>
<p>We’ve got a lot of code to add, so we’ll do it in stages.</p>
<p>We’ll modify the file <strong>app/views/devise/registrations/edit.html.erb</strong>.</p>
<p>There’s no need to replace the existing form. It is useful for changing the user’s name, email address, or password.</p>
<p>Add this code before the <code>&lt;h3&gt;Cancel my account&lt;/h3&gt;</code> statement:</p>
<pre>
&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Using card ending with &lt;%= @user.last_4_digits %&gt;
  &lt;a data-toggle="modal" href="#card-data" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;
</pre>
<p>We display the name of the current subscription plan, which is derived from the roles object associated with the user. Rolify lets us set multiple roles (a feature we will not use in this application). We pick the first role (the only role), obtain its name, and “titleize” it to display it in titlecase. We add a link that is styled as a Twitter button. The link will open a Twitter Bootstrap modal window labeled “plan-options”, which we will add soon.</p>
<p>We do something similar for the credit card. We show the last four digits of the card that was used to purchase the subscription. Then we add a link that will open a Twitter Bootstrap modal window labeled “card-data”. The link will be styled as a miniature button.</p>
<p>For stylistic consistency, replace the next statement with the following:</p>
<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete %&gt;.&lt;/p&gt;
</pre>

<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;
</pre>
<p>We’ve added a Twitter Bootstrap class that styles the link as a miniature button.</p>
<p>You can also remove the line:</p>
<pre>
&lt;%= link_to "Back", :back %&gt;
</pre>
<p>Now we’ll add the first of two modal windows containing a form. It doesn’t matter where the forms are placed in the file as they will be hidden when the page is initially displayed and will appear as an overlay when revealed by a click on the appropriate link. I suggest you append the code at the end of the file.</p>
<p>The first form is identifed as “plan-options”:</p>
<pre>
&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; update_plan_path, :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>We include this form in a div designated with the Twitter Bootstrap “modal” class. It will be displayed as an overlay when the user clicks the “Change plan” button.</p>
<p>We’re using helper methods provided by the <a href="http://simple-form.plataformatec.com.br/">simple_form gem</a>. It looks as if we <a href="http://guides.rubyonrails.org/form_helpers.html#binding-a-form-to-an-object">bind the form to an object</a> named “resource”; in fact, we bind the form to the User object. Devise abstracts the User object and names it “resource” which makes it possible to use objects with other names (such as Account or Member) in similar implementations. “Binding the form to the object” means the values for the form fields will be set with the attributes stored in the database.</p>
<p>The form has a section named “modal-header” that contains a link to close the modal window. We follow Twitter Bootstrap’s example and use <span class="caps">HTML</span> entity #215 (an “x” character) for the link.</p>
<p>The next section is named “modal-body” and it contains some of the most complex code we’ll use in this application.</p>
<p>We want to display a set of radio buttons that display a collection of all the subscription plans and, when selected, set a role id. A user’s subscription plan is encoded as a role id. Role ids are nested attributes of a User object and can be set as <code>user.role_ids</code>. So <code>:role_ids</code> is the first parameter we pass to the input field helper.</p>
<p>The input field helper wants a collection as the second parameter. We supply <code>Role.all</code> but we have to massage the list to remove the “admin” role. The Hash <code>delete_if</code> method is useful here. The block we supply to the<br><code>delete_if</code> method removes any role named “admin”.</p>
<p>We tell the input field helper we want to display the selection field as radio buttons. The <code>:item_wrapper_class =&gt; 'inline'</code> will display the radio buttons and labels horizontally.</p>
<p>The simple_form <code>label_method</code> parameter allows us to set a label for each radio button. If we didn’t set the <code>label_method</code>, the radio buttons would be labeled with an integer. We need to obtain the name attribute of each role and then apply the <code>titleize</code> method to display titlecase. The <code>label_method</code> parameter does not take a block but we can use a programming construct called an anonymous function (a Ruby language “lambda”) to manipulate the Role instance, obtaining the name attribute and making it titlecase, before passing it to the <code>label_method</code> parameter. This is a bit of advanced Ruby magic that is particularly useful here.</p>
<p>Confusingly, we set the <code>label</code> parameter to false. If we didn’t do this, the entire field would be automatically labelled “Roles.”</p>
<p>Finally, the form has a section named “modal-footer” that contains a submit button and another link to close the modal window.</p>
<p>Now we’ll add another modal window containing a form for changing the credit card.</p>
<pre>
&lt;div id="card-data" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; update_card_path, :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal card_form' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Credit Card&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
        &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
        &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_month, "Card Expiration" %&gt;
        &lt;%= select_month nil, {add_month_numbers: true}, {name: nil, id: "card_month"}%&gt;
        &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
      &lt;/div&gt;
      &lt;%= f.hidden_field :name %&gt;
      &lt;%= f.hidden_field :email %&gt;
      &lt;%= f.hidden_field :stripe_token %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Credit Card", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>This form is very similar to the form on the registration page that is used when a new account is created.</p>
<p>Our JavaScript code will intercept the submission of this form, access the Stripe server to set a new credit card, and obtain a Stripe token before submitting the form to our server.</p>
<p>Here’s the complete version of the file <strong>app/views/devise/registrations/edit.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= tag :meta, :name =&gt; "stripe-key", :content =&gt; STRIPE_PUBLIC_KEY %&gt;
&lt;% end %&gt;
&lt;h2&gt;Account&lt;/h2&gt;
&lt;div id="stripe_error" class="alert alert-error" style="display:none" &gt;&lt;/div&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; { :method =&gt; :put, :class =&gt; 'form-vertical' }) do |f| %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= display_base_errors resource %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt;
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :autocomplete =&gt; "off", :hint =&gt; "leave it blank if you don't want to change it", :required =&gt; false %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; false %&gt;
  &lt;%= f.input :current_password, :hint =&gt; "we need your current password to confirm your changes", :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Update', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;

&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Using card ending with &lt;%= @user.last_4_digits %&gt;
  &lt;a data-toggle="modal" href="#card-data" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Cancel my account&lt;/h3&gt;

&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;

&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; update_plan_path, :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;

&lt;div id="card-data" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; update_card_path, :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal card_form' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Credit Card&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
        &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
        &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_month, "Card Expiration" %&gt;
        &lt;%= select_month nil, {add_month_numbers: true}, {name: nil, id: "card_month"}%&gt;
        &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
      &lt;/div&gt;
      &lt;%= f.hidden_field :name %&gt;
      &lt;%= f.hidden_field :email %&gt;
      &lt;%= f.hidden_field :stripe_token %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Credit Card", :class =&gt; "btn btn-primary" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>There’s a lot of new code in the Devise user edit view. To accommodate the “Change Plans” feature we will need to improve the registrations controller, the users controller, and the User model. First we will modify the User model to accommodate the “Cancel my account” feature.</p>
<h3>Modify the User Model for Subscription Cancellations</h3>
<p>It’s easy to handle a subscription cancellation request. Devise does the work of deleting the user account and we just piggyback on the Devise registration controller action with a <code>before_destroy</code> callback so we can notify Stripe to cancel subscription billing.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :stripe_token, :coupon
  attr_accessor :stripe_token, :coupon
  before_save :update_stripe
  before_destroy :cancel_subscription

  def update_stripe
    return if email.include?(ENV['ADMIN_EMAIL'])
    return if email.include?('@example.com') and not Rails.env.production?
    if customer_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      if coupon.blank?
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name
        )
      else
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name,
          :coupon =&gt; coupon
        )
      end
    else
      customer = Stripe::Customer.retrieve(customer_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.customer_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "#{e.message}."
    self.stripe_token = nil
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Stripe::Customer.retrieve(customer_id)
      unless customer.nil? or customer.respond_to?('deleted')
        if customer.subscription.status == 'active'
          customer.cancel_subscription
        end
      end
    end
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}."
    false
  end

end
</pre>
<p>We’ve added a <code>cancel_subscription</code> method that is activated by the <code>before_destroy</code> callback. The <code>cancel_subscription</code> method only takes action if the user has a customer id. Example users created by the <code>db:seed</code> process don’t have a customer id and the <code>destroy</code> action would fail for them which is why we make the <code>cancel_subscription</code> method conditional.</p>
<p>The method uses the Stripe <span class="caps">API</span> to obtain a Stripe customer object and then initiates a subscription cancellation call. We make sure the Stripe customer exists and has an active subscription before attempting to cancel the subscription. We return false to cancel the <code>destroy</code> action if Stripe returns an error.</p>
<h3>Modify the User Model for Subscription Plan Changes</h3>
<p>As implemented, either the user or the administrator can upgrade or downgrade a user’s subscription plan and the change will be recorded in the application’s roles datatable. However, we need to inform Stripe when a subscription plan changes. Stripe will pro-rate the plan cost and refund or bill the price difference (or optionally, wait until the next billing cycle to change the billed rate).</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :stripe_token, :coupon
  attr_accessor :stripe_token, :coupon
  before_save :update_stripe
  before_destroy :cancel_subscription

  def update_plan(role)
    self.role_ids = []
    self.add_role(role.name)
    unless customer_id.nil?
      customer = Stripe::Customer.retrieve(customer_id)
      customer.update_subscription(:plan =&gt; role.name)
    end
    true
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "Unable to update your subscription. #{e.message}."
    false
  end

  def update_stripe
    return if email.include?(ENV['ADMIN_EMAIL'])
    return if email.include?('@example.com') and not Rails.env.production?
    if customer_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      if coupon.blank?
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name
        )
      else
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name,
          :coupon =&gt; coupon
        )
      end
    else
      customer = Stripe::Customer.retrieve(customer_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.customer_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "#{e.message}."
    self.stripe_token = nil
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Stripe::Customer.retrieve(customer_id)
      unless customer.nil? or customer.respond_to?('deleted')
        if customer.subscription.status == 'active'
          customer.cancel_subscription
        end
      end
    end
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}."
    false
  end

end
</pre>
<p>We add the <code>update_plan</code> method for resetting the role. Rolify supports multiple roles (though we only use a single role in this application) and we must remove an existing role before adding a new role. Then we make sure the user has a Stripe customer account, obtain a customer object with a call to Stripe, and call the Stripe <code>update_subscription</code> method.</p>
<p>With these changes, the User model can update the Stripe customer account when a user or administrator changes a subscription plan.</p>
<h3>Modify the Registrations Controller for Account Changes</h3>
<p>The registrations controller handles requests when the user submits the edit form.</p>
<p>We will add <code>update_plan</code> and <code>update_card</code> actions to the registrations controller to accommodate the “Change Plans” and “Change Card” features.</p>
<p>It would be nice to keep the controller completely RESTful and not add any new actions, replacing the <code>update</code> method to handle submissions of three different forms (changing the plan, changing the card, and updating name/email/password). However, the <code>update</code> method supplied by Devise is quite complex, with logic that forces the user to enter the current password to authorize any changes. We don’t want to ask the user to enter a password to change the card or plan, so we’ll leave the <code>update</code> method untouched (for changing name/email/password) and add two new methods.</p>
<p>Modify the file <strong>app/controllers/registrations_controller.rb</strong>:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    if @plan
      super
    else
      redirect_to root_path, :notice =&gt; 'Please select a subscription plan below.'
    end
  end

  def update_plan
    @user = current_user
    role = Role.find(params[:user][:role_ids]) unless params[:user][:role_ids].nil?
    if @user.update_plan(role)
      redirect_to edit_user_registration_path, :notice =&gt; 'Updated plan.'
    else
      flash.alert = 'Unable to update plan.'
      render :edit
    end
  end

  def update_card
    @user = current_user
    @user.stripe_token = params[:user][:stripe_token]
    if @user.save
      redirect_to edit_user_registration_path, :notice =&gt; 'Updated card.'
    else
      flash.alert = 'Unable to update card.'
      render :edit
    end
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
  end
end

</pre>
<p>Not every request will require a change of card or subscription plan. Sometimes the user will be submitting a form to change name, email address, or password. In that case, the inherited <code>update</code> method from the Devise registrations controller will be invoked.</p>
<p>The <code>update_plan</code> method applies changes to the <code>current_user</code> (note that changes by an administrator are accommodated elsewhere by the User controller). We identify the new role that is specified in the form and call the User <code>update_plan(role)</code> method. That method will make a request to Stripe to update the customer account. Stripe will automatically apply refunds or additional charges as necessary. The User <code>update_plan(role)</code> method returns <code>true</code> on a successful update or throws an error if an attempt to reach the Stripe server fails. On a successful update we redirect to the edit page with a status message. On a failure we render the edit page, showing any errors with the <code>display_base_errors</code> view helper.</p>
<p>The <code>update_card</code> method relies on the JavaScript code in <strong>app/assets/javascripts/registrations.js</strong> to intercept the card data and submit it to the Stripe server to obtain the Stripe token. The process is very similar to creating a new subscription. Once we have obtained the Stripe token, we call <code>@user.save</code>. Just like when a subscription is created, the User model <code>update_stripe</code> method calls the Stripe <span class="caps">API</span> and makes a request that associates the new card with the customer record for future billing. On a successful update we redirect to the edit page with a status message. On a failure we render the edit page, showing any errors with the <code>display_base_errors</code> view helper (this is where a “Credit card declined” message will appear).</p>
<h3>Add Routes for Account Changes</h3>
<p>We’ve added two new actions to the registrations controller to accommodate the “Change Plans” and “Change Card” features. We need to add routes to invoke the new actions.</p>
<p>Modify the <strong>config/routes.rb</strong> file to add two routes:</p>
<pre>
RailsStripeMembershipSaas::Application.routes.draw do
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  devise_scope :user do
    put 'update_plan', :to =&gt; 'registrations#update_plan'
    put 'update_card', :to =&gt; 'registrations#update_card'
  end
  resources :users
end
</pre>
<p>The <a href="http://rdoc.info/github/plataformatec/devise/ActionDispatch/Routing/Mapper:devise_scope"><code>devise_scope</code> method</a> applies <a href="http://rubydoc.info/github/plataformatec/devise/master/Devise/Mapping">Devise.mappings</a> so the new routes are associated with other routes specified by <a href="http://rubydoc.info/github/plataformatec/devise/master/ActionDispatch/Routing/Mapper#devise_for-instance_method"><code>devise_for</code></a>. Our Registrations controller subclasses the Devise Registrations controller and it will raise an “Unknown action” error if the scope is not set by <code>devise_scope</code>. Note that <code>devise_for</code> takes a <code>:users</code> argument (plural) and <code>devise_scope</code> takes a <code>:user</code> argument (singular).</p>
<p>We add the <code>update_plan</code> and <code>update_card</code> routes to respond to an <span class="caps">HTTP</span> “put” request (a form submission). This generates the routes that we use in our “Change Plans” and “Change Card” forms:</p>
<ul>
<li>update_plan_path</li>
	<li>update_card_path</li>
</ul><p>Our “Change Plans” and “Change Card” features are now ready for the user.</p>
<p>We’ll add one more feature. We want to allow the administrator to change a subscription plan for any user.</p>
<h3>Modify the User Controller for Subscription Plan Changes</h3>
<p>The users controller handles requests when an administrator changes the user’s subscription plan.</p>
<p>We need to modify the <code>update</code> method in the users controller to make sure Stripe’s customer records are updated when an administrator makes a change.</p>
<p>Modify the file <strong>app/controllers/users_controller.rb</strong>:</p>
<pre>
class UsersController &lt; ApplicationController
  before_filter :authenticate_user!

  def index
    authorize! :index, @user, :message =&gt; 'Not authorized as an administrator.'
    @users = User.all
  end

  def show
    @user = User.find(params[:id])
  end

  def update
    authorize! :update, @user, :message =&gt; 'Not authorized as an administrator.'
    @user = User.find(params[:id])
    role = Role.find(params[:user][:role_ids]) unless params[:user][:role_ids].nil?
    params[:user] = params[:user].except(:role_ids)
    if @user.update_attributes(params[:user])
      @user.update_plan(role) unless role.nil?
      redirect_to users_path, :notice =&gt; "User updated."
    else
      redirect_to users_path, :alert =&gt; "Unable to update user."
    end
  end

  def destroy
    authorize! :destroy, @user, :message =&gt; 'Not authorized as an administrator.'
    user = User.find(params[:id])
    unless user == current_user
      user.destroy
      redirect_to users_path, :notice =&gt; "User deleted."
    else
      redirect_to users_path, :notice =&gt; "Can't delete yourself."
    end
  end
end
</pre>
<p>The <code>update</code> action is more complex than the actions we added to the registrations controller because we are updating all attributes with a single action. The <code>authorize!</code> uses CanCan to make sure only the administrator can invoke the update. We find the name of the requested role if a <code>params[:user][:role_ids]</code> parameter exists. We strip away the <code>params[:user][:role_ids]</code> parameter to avoid mass assignment errors. Then we call <code>update_attributes</code>. If the User object successfully saves the new attributes, we call the <code>User.update_plan</code> method to change the subscription plan in both the application role table and the remote Stripe customer account.</p>
<p>Now an administrator can change subscription plans and Stripe will update the customer account and apply refunds or additional charges as necessary.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "accommodate changes to account"
$ git checkout master
$ git merge --squash change-acct
$ git commit -m "accommodate changes to account"
$ git branch -D change-acct
</pre>
<h2>Stripe Push Notifications</h2>
<p>What happens when a credit card expires or a monthly transaction is declined? Stripe will automatically retry a recurring payment after it fails. After a number of attempts (set in your Stripe account settings), Stripe will cancel the subscription. But how will your application know to deny access for a subscriber with an expired account? Stripe provides <a href="http://en.wikipedia.org/wiki/Webhook">webhooks</a> (push notifications) to communicate events to you (for details, see the <a href="https://stripe.com/docs/webhooks">Stripe webhooks documentation</a>).</p>
<p>A Stripe webhook is an <span class="caps">HTTP</span> request from Stripe’s servers to your site. It is not a visit to your website from a web browser; rather it is an <span class="caps">HTTP</span> <span class="caps">POST</span> request (like a form submission) to your application from the Stripe servers. The <span class="caps">HTTP</span> request contains <span class="caps">JSON</span> data that provides data about the event, plus an event id that can be used to retrive the data from the Stripe server. It is best to ignore the event data (because it could be falsified) and immediately use the event id to obtain the event data from Stripe.</p>
<p>There are a few ways we could handle webhook requests. We could create a new controller with an index action to process webhook requests. We could use the existing Registrations or Users controller, adding a new non-RESTful action to process the webhook requests. Both these approaches have merit. Instead, we’ll take a different approach. We’ll use Danny Whalen’s <a href="https://github.com/integrallis/stripe_event">stripe_event</a> gem. With this gem, we don’t need to add a new controller or action.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b webhooks
</pre>
<h3>Stripe Event gem</h3>
<p>We already added the <a href="https://github.com/integrallis/stripe_event">stripe_event</a> gem when we set up our Gemfile. If not, add the gem to the Gemfile:</p>
<pre>
gem "stripe_event"
</pre>
<p>and run the <code>bundle install</code> command to install the required gem on your computer.</p>
<h3>Mount the Engine</h3>
<p>The stripe_event gem is a <a href="http://edgeguides.rubyonrails.org/engines.html">Rails engine</a>, which is a miniature Rails application that can be added to an application. As a miniature Rails application, it has its own controller and routes hidden in the gem. The engine’s functionality becomes available when you mount it in your routes file.</p>
<p>Modify <strong>config/routes.rb</strong> to mount the engine:</p>
<pre>
RailsStripeMembershipSaas::Application.routes.draw do
  mount StripeEvent::Engine =&gt; '/stripe'
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  devise_scope :user do
    put 'update_plan', :to =&gt; 'registrations#update_plan'
    put 'update_card', :to =&gt; 'registrations#update_card'
  end
  resources :users
end
</pre>
<p>We’ve chosen to mount the engine so it responds to requests to <a href="http://localhost:3000/stripe">http://localhost:3000/stripe</a>. You can specify a different path. You’ll supply this address when you set the webhooks <span class="caps">URL</span> in your Stripe account settings.</p>
<p>Note that the application name is used in the routes file. If you’ve changed the name of the application from “rails-stripe-membership-saas” you’ll need to change the first line of the routes file.</p>
<h3>Modify the Stripe Initializer</h3>
<p>We need to specify what happens when the stripe_event engine receives a webhook request. Conveniently, we can specify this in the Stripe initializer file.</p>
<p>Modify the <strong>config/initializers/stripe.rb</strong> file:</p>
<pre>
Stripe.api_key = ENV["STRIPE_API_KEY"]
STRIPE_PUBLIC_KEY = ENV["STRIPE_PUBLIC_KEY"]

StripeEvent.setup do
  subscribe 'customer.subscription.deleted' do |event|
    user = User.find_by_customer_id(event.data.object.customer)
    user.expire
  end
end
</pre>
<p>By default, Stripe will make three attempts to rebill after a failed payment. On each failure, Stripe will send a webhook request with an <code>invoice.payment_failed</code> event. On the third failure, Stripe will send a <code>customer.subscription.deleted</code> event.</p>
<p>With this code, we’re telling the stripe_event engine to respond when the application receives a webhook with a <code>customer.subscription.deleted</code> event. We use the Stripe event data to find the appropriate User instance. Then we call the <code>User.expire</code> method. We’ll add the <code>expire</code> method to the User class in the next step.</p>
<p>The <a href="https://github.com/integrallis/stripe_event">stripe_event gem readme</a> handles other possibilities, including multiple event types. Refer to the <a href="https://stripe.com/docs/api?lang=ruby#event_types">Stripe <span class="caps">API</span> documentation</a> for a list of all event types. You can configure your application to respond to other events, such as sending a thank you email in response to an “invoice.payment_succeeded” event.</p>
<p>Remember you’ll need to restart your server before testing because you’ve made a change to configuration files.</p>
<h3>Add an Expire Method to the User Model</h3>
<p>Now that our application responds to webhook requests from Stripe, we must consider how to process an expired  customer subscription.</p>
<p>There are several possible approaches to handling an expired subscription. One option is to keep the customer record and change the subscription plan to a role named “expired” or something similar. If we did that, we’d have to provide a form to allow an expired subscriber to log in, change a credit card, and update the subscription. It’s easier to simply delete the account and expect the user to create a new account to re-subscribe.</p>
<p>When a user visits the website and cancels a subscription, we delete the customer record. Similarly, we could simply delete the customer record when a subscription expires. Instead we can encourage the user to resubscribe by notifying the user with an email message when the subscription has ended due to a payment failure. We’ll add a custom <code>expire</code> method to our User class that will send an email message before deleting the user.</p>
<p>Modify the file <strong>app/models/user.rb</strong> to add an <code>expire</code> method:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :stripe_token, :coupon
  attr_accessor :stripe_token, :coupon
  before_save :update_stripe
  before_destroy :cancel_subscription

  def update_plan(role)
    self.role_ids = []
    self.add_role(role.name)
    unless customer_id.nil?
      customer = Stripe::Customer.retrieve(customer_id)
      customer.update_subscription(:plan =&gt; role.name)
    end
    true
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "Unable to update your subscription. #{e.message}."
    false
  end

  def update_stripe
    return if email.include?(ENV['ADMIN_EMAIL'])
    return if email.include?('@example.com') and not Rails.env.production?
    if customer_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      if coupon.blank?
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name
        )
      else
        customer = Stripe::Customer.create(
          :email =&gt; email,
          :description =&gt; name,
          :card =&gt; stripe_token,
          :plan =&gt; roles.first.name,
          :coupon =&gt; coupon
        )
      end
    else
      customer = Stripe::Customer.retrieve(customer_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.customer_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "#{e.message}."
    self.stripe_token = nil
    false
  end

  def cancel_subscription
    unless customer_id.nil?
      customer = Stripe::Customer.retrieve(customer_id)
      unless customer.nil? or customer.respond_to?('deleted')
        if customer.subscription.status == 'active'
          customer.cancel_subscription
        end
      end
    end
  rescue Stripe::StripeError =&gt; e
    logger.error "Stripe Error: " + e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}."
    false
  end

  def expire
    UserMailer.expire_email(self).deliver
    destroy
  end

end
</pre>
<p>Our new <code>expire</code> method is simple. We call a method on an ActionMailer method to send an email. Then we destroy the user.</p>
<h3>Send an Expiration Email</h3>
<p>We’ll use an ActionMailer method to send an email when we receive a Stripe webhook request indicating a subscription has been cancelled for payment failure.</p>
<p>Generate a mailer with accompanying views:</p>
<pre>
$ rails generate mailer UserMailer
</pre>
<p>Add an <code>expire_email</code> method to the mailer by editing the file <strong>app/mailers/user_mailer.rb</strong>:</p>
<pre>
class UserMailer &lt; ActionMailer::Base
  default :from =&gt; "notifications@example.com"

  def expire_email(user)
    mail(:to =&gt; user.email, :subject =&gt; "Subscription Cancelled")
  end
end
</pre>
<p>Replace the “notifications@example.com” string with your email address.</p>
<p>Create a mailer view by creating a file <strong>app/views/user_mailer/expire_email.html.erb</strong>. This will be the template used for the email, formatted in <span class="caps">HTML</span>:</p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Subscription Cancelled&lt;/h1&gt;
    &lt;p&gt;
      Your subscription has been cancelled.
    &lt;/p&gt;
    &lt;p&gt;
      We are sorry to see you go. We'd love to have you back.
      Visit example.com anytime to create a new subscription.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It is a good idea to make a text-only version for this message. Create a file  <strong>app/views/user_mailer/expire_email.text.erb</strong>:</p>
<pre>
Subscription Cancelled

Your subscription has been cancelled.

We are sorry to see you go. We'd love to have you back.
Visit example.com anytime to create a new subscription.
</pre>
<p>When you call the mailer method, ActionMailer will detect the two templates (text and <span class="caps">HTML</span>) and automatically generate a multipart/alternative email. If you use the Mandrill email service, you can skip this step if you configure Mandrill to automatically generate a plain-text version of all emails.</p>
<p>Now the User model is equipped to send an email message when a Stripe webhook notifies the application of a cancelled subscription.</p>
<h3>Set Your Webhook Address in Your Stripe Account Settings</h3>
<p>After you’ve implemented handling of Stripe webhooks, you need to set your webhook address in your Stripe account settings.</p>
<p>Visit your Stripe dashboard at <a href="https://manage.stripe.com/#account/webhooks">https://manage.stripe.com/#account/webhooks</a> and add a <span class="caps">URL</span> such as <a href="https://example.com/stripe">https://example.com/stripe</a>.</p>
<h3>Testing a Stripe Webhook Event</h3>
<p>It’s not easy to test a Stripe webhook event.</p>
<p>You can watch your development log file when you visit <a href="http://localhost:3000/stripe">http://localhost:3000/stripe</a>. You should see:</p>
<pre>
Started GET "/stripe" for 127.0.0.1 at ...
Processing by StripeEvent::WebhookController#event as HTML
Completed 401 Unauthorized in 0ms (ActiveRecord: 0.0ms)
</pre>
<p>The “401 Unauthorized” response indicates that the stripe_event gem received a request but was unable to retrieve a Stripe event from the Stripe servers.</p>
<p>You can deploy the application so it is running on a production web server and then use the “Test Webhook” button on your Stripe dashboard. Stripe will send fake event to the <span class="caps">URL</span> you’ve specified in your account settings. However, your log file will again show a “401 Unauthorized” response because the “Test Webhook” button sends a fake event (“id”=&gt;"evt_00000000000000") that can’t be retrieved from Stripe.</p>
<p>The most expedient test is to deploy the application on a production web server and trigger an actual event on your Stripe dashboard in “Test” mode by creating a customer and then canceling a subscription. If you are not getting the results you expect, you can include the following debug code in the <strong>config/initializers/stripe.rb</strong> file:</p>
<pre>
subscribe do |event|
  Rails.logger.info event
end
</pre>
<p>The debug code should show you the results of any request to the stripe_event gem in your log file.</p>
<p>You can use the <a href="http://requestb.in/">RequestBin</a> service to see what Stripe is sending. RequestBin lets you create a <span class="caps">URL</span> that will collect requests made to it, then lets you inspect the request headers and body.</p>
<p>If you need to test requests to the stripe_event gem on your local development machine, you can install the <a href="http://progrium.com/localtunnel/">localtunnel gem</a> (<a href="https://github.com/progrium/localtunnel">localtunnel on GitHub</a>) which will expose your local web server to the Internet so you can receive webhook requests from the Stripe servers.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add Stripe webhooks"
$ git checkout master
$ git merge --squash webhooks
$ git commit -m "add Stripe webhooks"
$ git branch -D webhooks
</pre>
<h2>Customize, Test, and Deploy</h2>
<h3>Additional Features</h3>
<p>You’ve created a fully functional membership site that’s ready to take credit card payments and serve access to restricted content.</p>
<p>It uses Stripe for payment processing, allows users to change credit cards or subscription plans, and uses Stripe webhooks to delete users who have expired or declined credit cards.</p>
<p>You might consider a few enhancements. For example, you might want the application to respond to a Stripe webhook event when a credit card payment is successful by sending a “paid” invoice. Or you might respond to Stripe webhook events when credit card payments are unsuccessful by sending a friendly note encouraging the user to check for an expired credit card before the subscription is cancelled.</p>
<p>If you have suggestions for additional features, please create an <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">issue</a> on GitHub.</p>
<h3>Cleanup</h3>
<p>Several unneeded files are generated in the process of creating a new Rails application.</p>
<p>Additionally, you may want to prevent search engines from indexing your website if you’ve deployed it publicly while still in development.</p>
<p>See instructions for <a href="http://railsapps.github.com/rails-cleanup.html">cleaning up unneeded files in Rails and banning spiders</a>.</p>
<h3>Test the App</h3>
<p>You can check that your app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>.</p>
<p>Sign in as the first user (the administrator) using:</p>
<ul>
<li>email: user@example.com</li>
	<li>password: please</li>
</ul><p>You’ll see a navigation link for Admin. Clicking the link will display a page with a list of users at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<p>To sign in as the second user, use</p>
<ul>
<li>email: user2@example.com</li>
	<li>password: please</li>
</ul><p>The second user will not see the Admin navigation link and will not be able to access the page at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<p>You should be able to create additional users. If you use “example.com” in an email address in development or testing, the application will not connect with Stripe. Use a different email address with a fake credit card number to test subscribing using Stripe. You’ll see the new users listed when you log in as an administrator. And you’ll see the new users listed as customers when you visit your Stripe dashboard.</p>
<p>Stop the server with Control-C.</p>
<h3>Testing</h3>
<p>If you’ve copied the RSpec unit tests and Cucumber integration tests from the  <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> example application, you can run <code>rake -T</code> to check that rake tasks for RSpec and Cucumber are available.</p>
<p>Run <code>rake spec</code> to run all RSpec tests.</p>
<p>Run <code>rake cucumber</code> (or more simply, <code>cucumber</code>) to run all Cucumber scenarios.</p>
<h3>Deploy to Heroku</h3>
<p>For your convenience, here is a <a href="http://railsapps.github.com/rails-heroku-tutorial.html">Tutorial for Rails on Heroku</a>. Heroku provides low cost, easily configured Rails application hosting.</p>
<p>Be sure to set up <span class="caps">SSL</span> before you make your application available in production. See the <a href="https://devcenter.heroku.com/articles/ssl">Heroku documentation on <span class="caps">SSL</span></a>.</p>
<p>You’ll need to set the configuration values from the <strong>config/application.yml</strong> file as Heroku environment variables. See the article <a href="http://railsapps.github.com/rails-environment-variables.html">Rails Environment Variables</a> for more information.</p>
<p>With the figaro gem, just run:</p>
<pre>
rake figaro:heroku
</pre>
<p>Alternatively, you can set Heroku environment variables for your Stripe <span class="caps">API</span> and public key like this:</p>
<pre>
$ heroku config:add STRIPE_API_KEY=secret STRIPE_PUBLIC_KEY=secret
</pre>
<p>Prior to deployment, it’s advisable to change your <strong>db/seeds.rb</strong> file. At a minimum, remove the “example.com” sample users. Optionally, you can change the administrator name, email and password though it is better to wait and change the values through the application “Edit account” interface later.</p>
<pre>
puts 'ROLES'
YAML.load(ENV['ROLES']).each do |role|
  Role.find_or_create_by_name({ :name =&gt; role }, :without_protection =&gt; true)
  puts 'role: ' &lt;&lt; role
end
puts 'DEFAULT USERS'
user = User.find_or_create_by_email :name =&gt; ENV['ADMIN_NAME'].dup, :email =&gt; ENV['ADMIN_EMAIL'].dup, :password =&gt; ENV['ADMIN_PASSWORD'].dup, :password_confirmation =&gt; ENV['ADMIN_PASSWORD'].dup
puts 'user: ' &lt;&lt; user.name
user.add_role :admin
</pre>
<p>If you don’t remove the “example.com” sample users, <code>rake db:seed</code> will fail with errors if you attempt to run it on Heroku after deployment, since you are not supplying a credit card for Stripe for these users.</p>
<h2>Comments</h2>
<h3>Credits</h3>
<p>Daniel Kehoe implemented the application and wrote the tutorial.</p>
<h3>Did You Like the Tutorial?</h3>
<p>Was this useful to you? Follow <a href="http://twitter.com/rails_apps">rails_apps</a> on Twitter and tweet some praise. I’d love to know you were helped out by the tutorial.</p>
<p>Get some link juice! Add your website to the list of <a href="http://railsapps.github.com/rails-applications-from-examples.html">Rails Applications Built from the Examples</a>. I love to see what people have built with these examples.</p>
<p>Any issues? Please create an <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">issue</a> on GitHub. Reporting (and patching!) issues helps everyone.</p>
    </div><!-- class="content" -->
    
    <div class="comments">
      <div class="content wikistyle gollum">
        <h2>Comments</h2>
      </div>
      <p>Is this helpful? Your encouragement fuels the project. Please tweet or add a comment. Couldn't get something to work? For the example apps and tutorials, it's best to open an issue on GitHub so we can help you.</p> 
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'railsapps'; // required: replace example with your forum shortname
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div><!-- class="comments" -->

    <div class="footer row">
      <div class="span4">
      </div>
    
      <div class="span4">
       </div>

      <div class="span4">
      </div>
    </div>

  </div>
            
  </body>
</html>
