<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Rails Tutorial &#183; Membership Subscription or SaaS Site with Stripe &#183; RailsApps</title>
    <link href="https://plus.google.com/u/0/b/117374718581973393536/117374718581973393536/posts/" rel="publisher" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/bootstrap.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/site.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="http://railsapps.github.com/css/syntax.css" type="text/css" charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.6.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="http://railsapps.github.com/javascript/gollum.js" type="text/javascript"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-5109366-14']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a href="http://railsapps.github.com/" class="brand">RailsApps Project</a>
        <ul class="pull-right nav">
          <li><a href="http://blog.railsapps.org/" class="twitter">Blog</a></li>
          <li><a href="http://twitter.com/rails_apps" class="twitter">Twitter</a></li>
          <li><a href="https://plus.google.com/117374718581973393536" class="google">Google +</a></li>
          <li><a href="https://github.com/RailsApps" class="github">GitHub Repository</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container"> 

    <div class="content wikistyle gollum textile">
      <h1>Rails Tutorial for a Membership, Subscription, or SaaS Site</h1>
<h4>by Daniel Kehoe</h4>
<p><em>Last updated 14 October 2012</em></p>
<p>Ruby on Rails tutorial for a web application with Rails recurring billing using Stripe. Use for a Rails membership site, subscription site, or SaaS site (software-as-a-service). Complete Rails 3.2 example application available on GitHub at  <a href="http://github.com/RailsApps/rails-stripe-membership-saas">rails-stripe-membership-saas</a> from the <a href="http://railsapps.github.com/">RailsApps Project</a>.</p>
<p><img src="http://railsapps.github.com/images/rails-stripe-membership-saas.png" title="Rails Application for a Membership, Subscription, or SaaS Site" alt="Rails Application for a Membership, Subscription, or SaaS Site"></p>
<h2>
<a href="http://www.twitter.com/rails_apps"><img src="http://twitter-badges.s3.amazonaws.com/t_logo-a.png" title="Follow on Twitter" alt="Follow on Twitter"></a> Follow on Twitter</h2>
<p>Follow the project on Twitter: <a href="http://twitter.com/rails_apps">@rails_apps</a>. Tweet some praise if you like what you’ve found.</p>
<h2>Introduction</h2>
<p>Membership sites restrict access to content such as articles, videos, or user forums. Software-as-a-service (SaaS) sites limit use of web-based software to paid subscribers. The revenue model is the same whether the site provides high-value content or software as a service: A visitor purchases a subscription and gains access to restricted areas of the site. Typically, the subscription is repurchased monthly through a service that provides recurring billing.</p>
<p>This example application exists so you don’t have to build it yourself. It aims to:</p>
<ul>
<li>eliminate effort spent building an application that meets a common need;</li>
	<li>offer code that is already implemented and tested by a large community;</li>
	<li>provide a well-thought-out app containing most of the features you’ll need.</li>
</ul><p>This tutorial is for experienced developers as well as startup founders or hobbyist coders who are new to Rails.</p>
<p>Experienced developers will find the <a href="http://github.com/RailsApps/rails-stripe-membership-saas">complete application on GitHub</a>; this tutorial provides the detail and background to understand the implementation in depth. For Rails beginners, this tutorial describes each step that you must follow to create the application. Every step is documented concisely, so you can create this application without any additional knowledge. However, the tutorial assumes you’ve already been introduced to Rails, so if you are a beginner, you may be overwhelmed unless you’ve been introduced to Rails elsewhere. See resources for getting started with <a href="http://railsapps.github.com/rails.html">Rails</a>.</p>
<h3>Functionality</h3>
<p>If you’re planning to build a SaaS applications, a membership site, or some other subscription-based web service, your application will need the following rudimentary functionality:</p>
<ul>
<li>content or web functionality to deliver value</li>
	<li>landing pages to convert visitors to paying customers</li>
	<li>user management to register or remove users</li>
	<li>access control to limit site-wide access to authenticated users</li>
	<li>authorization management to restrict access to content or services based on role or other characteristics</li>
	<li>account management to maintain records of subscription status</li>
	<li>a recurring billing system for periodic payment transactions</li>
</ul><h3>Features</h3>
<p>The example application provides a complete and fully functional membership site.</p>
<ul>
<li>tiered pricing for multiple subscription plans</li>
	<li>optional “free trial” subscription as well as free accounts using Stripe</li>
	<li>uses Stripe for no local credit card storage</li>
	<li>Stripe accepts credit card payments from customers in any country or currency</li>
	<li>
<span class="caps">PCI</span> compliance using the Stripe JavaScript library</li>
	<li>Stripe handles recurring billing, retries if payment fails, and cancels subscription if retries fail</li>
	<li>paid subscriptions are created only after a successful credit card transaction</li>
	<li>subscribers can upgrade or downgrade subscription plans</li>
	<li>subscribers can cancel subscription plans</li>
	<li>configurable subscription renewal period (defaults to one month)</li>
	<li>administrator can change subscription plan or delete user</li>
</ul><h3>What is Not Implemented</h3>
<p>There are additional features you may want for a SaaS application, such as:</p>
<ul>
<li>Basecamp-style subdomains (each user gets their own subdomain)</li>
	<li>
<a href="http://en.wikipedia.org/wiki/Multitenancy">multitenancy</a> database segmentation</li>
</ul><p>These features are not included in this application. See the <a href="https://github.com/RailsApps/rails3-subdomains">rails3-subdomains</a> example application for help with subdomains. For multitenancy, try Brad Robertson’s <a href="https://github.com/bradrobertson/apartment">Apartment</a> gem.</p>
<h3>About the Gems</h3>
<p>RubyGems is a package manager for the Ruby programming language that provides a standard format for distributing Ruby programs and libraries (in a self-contained format called a “gem”). Gems add functionality to a Rails app.</p>
<p>We use these gems:</p>
<ul>
<li>
<a href="http://github.com/plataformatec/devise">Devise</a> for user management and authentication</li>
	<li>
<a href="https://github.com/ryanb/cancan">CanCan</a> with <a href="https://github.com/EppO/rolify">Rolify</a> for authorization</li>
	<li>
<a href="https://stripe.com/">Stripe</a> for recurring billing</li>
</ul><h4>Devise</h4>
<p>Devise provides authentication, a system to securely identify users, making sure the user is who he represents himself to be.</p>
<p>We use Devise because it offers a full set of features used in more complex applications, such as recovering a user’s forgotten password or allowing users to invite friends. Should you need help in troubleshooting or customizing the implementation, you’ll be able to get help from a large community of developers using Devise.</p>
<h4>CanCan with Rolify</h4>
<p>CanCan provides a system for authorization to determine if an authenticated user should have access to secured resources. CanCan is often used to restrict access to administrative pages. This application will use CanCan to restrict access to content based on the price a user has paid for a subscription.</p>
<p>CanCan provides a mechanism for limiting access at the level of controller and controller method and expects you to set permissions based on user attributes you define. CanCan doesn’t provide default user attributes such as user roles based on subscription price; you must implement this outside of CanCan. There are many ways to implement role-based authorization for use with CanCan. For this example, we use Florent Monbillard’s Rolify gem to create a Role model, add methods to a User model, and generate a migration for a roles table.</p>
<h4>Stripe</h4>
<p>Stripe is a third-party billing service that provides an <span class="caps">API</span> and gem for integration with Rails applications. There are several other third-party billing services; Stripe is the least expensive and most popular for low-volume startups. Stripe costs 2.9% + 30¢ per successful charge, with no monthly or setup fees (see <a href="https://stripe.com/help/pricing">Stripe pricing</a>). Unfortunately, Stripe is only available to developers who have bank accounts in the US or Canada, though you can receive payments from customers internationally (<a href="#comment">leave a comment</a> if you want to suggest a billing service for non-US developers for a future tutorial).</p>
<h3>RailsApps Examples and Tutorials</h3>
<p>This is one in a series of Rails example apps and tutorials from the <a href="http://railsapps.github.com/">RailsApps Project</a>.</p>
<p>This application is based on two simpler example apps:</p>
<ul>
<li><a href="https://github.com/RailsApps/rails3-devise-rspec-cucumber">rails3-devise-rspec-cucumber</a></li>
	<li><a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a></li>
</ul><p>The first example shows how to set up Devise for user authentication. It also shows how to set up the app to use RSpec and Cucumber for testing.</p>
<p>The second example shows how to set up Devise and add CanCan and Rolify to manage access to administrative pages. It also shows how to set up Twitter Bootstrap as a front-end framework for <span class="caps">CSS</span> styling.</p>
<p>You can use this tutorial without studying these example applications; if you find you are lost, it may be helpful to look at the two simpler examples.</p>
<p>If you want to use the MongoDB datastore instead of ActiveRecord and a <span class="caps">SQL</span> database, look at the  <a href="https://github.com/RailsApps/rails3-mongoid-devise">rails3-mongoid-devise</a> example.</p>
<p>You might also be interested in the <a href="https://github.com/RailsApps/rails-prelaunch-signup">rails-prelaunch-signup</a> example if you are planning prelaunch promotion. Use it to announce your plans and collect email addresses from visitors for future notification of the site’s launch.</p>
<h2>About the Tutorial</h2>
<p>Most of the tutorials from the RailsApps project take about an hour to complete. This tutorial is more complex; it will take you about three hours to build the complete app. (Is our estimate accurate? Please <a href="#comment">leave a comment</a> when you are done.)</p>
<p>If you find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">GitHub issue</a>.</p>
<p>You’ll find a comments section at the end of the tutorial. I encourage you to offer feedback to improve this tutorial.</p>
<h2>Before You Start</h2>
<p>If you follow this tutorial closely, you’ll have a working application that closely matches the example app in the GitHub repository. The example app is your reference implementation. If you find problems with the app you build from this tutorial, download the example app (in Git speak, clone it) and use a file compare tool to identify differences that may be causing errors. On a Mac, <a href="http://stackoverflow.com/questions/187064/graphical-diff-for-mac-os-x">good file compare tools</a> are <a href="http://en.wikipedia.org/wiki/Apple_Developer_Tools#FileMerge">FileMerge</a>, <a href="http://sourcegear.com/diffmerge/">DiffMerge</a>, <a href="http://www.kaleidoscopeapp.com/">Kaleidoscope</a>, or Ian Baird’s <a href="http://www.changesapp.com/">Changes</a>.</p>
<p>If you clone and install the example app and find problems or wish to suggest improvements, please create a <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">GitHub issue</a>.</p>
<p>To improve this tutorial, please leave comments below.</p>
<h2>Accounts You May Need</h2>
<p>Before you start, you will need accounts for <em>recurring billing</em>, <em>hosting</em>, <em>email</em>, and a <em>source control repository</em>.</p>
<h3>Billing</h3>
<p>Many providers of billing services want your business:</p>
<ul>
<li>
<a href="https://stripe.com/">Stripe</a> (2011)</li>
	<li>
<a href="http://saasy.com/">SaaSy</a> (2011)</li>
	<li>
<a href="http://recurly.com/">Recurly</a> (2010)</li>
	<li>
<a href="http://www.earlyimpact.com/subscriptionbridge/">SubscriptionBridge</a> (2010)</li>
	<li>
<a href="http://chargify.com/">Chargify</a> (2009)</li>
	<li>
<a href="https://cheddargetter.com/">CheddarGetter</a> (2009)</li>
	<li>
<a href="http://www.braintreepayments.com/">Braintree</a> (2007)</li>
	<li>
<a href="http://spreedly.com/">Spreedly</a> (2007)</li>
	<li>
<a href="http://www.zuora.com/">Zuora</a> (2007)</li>
	<li>
<a href="http://www.adyen.com/">Adyen</a> (2006)</li>
	<li>
<a href="http://www.vindicia.com/">Vindicia</a> (2003)</li>
	<li>
<a href="http://www.ariasystems.com/">Aria Systems</a> (2003)</li>
</ul><p>The list shows the year each service was founded. In general, since the market is highly competetive, the newer services are less expensive and offer better integration, interfaces, and features.</p>
<p>Several blog posts compare services and pricing:</p>
<ul>
<li>
<a href="http://blog.subscrea.com/recurring-billing/peeling-the-onion-called-recurring-billing-part-ii/">Peeling the onion called recurring billing</a> (July 2012)</li>
	<li>
<a href="http://expletiveinserted.com/2011/03/18/comparing-recurring-payment-solutions/">Comparing Recurring Payment Solutions</a> (March 2011)</li>
</ul><p>You can use a web-based calculator to compare pricing of some services:</p>
<ul>
<li><a href="http://www.billingsavvy.com/">BillingSavvy</a></li>
</ul><p>BillingSavvy shows Stripe is cheaper than Recurly for less than 600 subscribers. Over 600 subscribers, Recurly becomes cheaper. Stripe and Recurly are always cheaper than Chargify, CheddarGetter and Spreedly for $12/month subscriptions.</p>
<p>This tutorial shows to set up recurring billing using Stripe. Before you start, go to the <a href="https://stripe.com/">Stripe website</a> and set up an account. You don’t need a credit card merchant account or payment gateway. There’s no approval process to delay getting started.</p>
<h3>Hosting</h3>
<p>For easy deployment, use a “platform as a service” provider such as:</p>
<ul>
<li><a href="http://www.heroku.com/">Heroku</a></li>
	<li><a href="http://www.cloudfoundry.com/">CloudFoundry</a></li>
	<li><a href="http://www.engineyard.com/">EngineYard</a></li>
	<li><a href="https://openshift.redhat.com/app/">OpenShift</a></li>
</ul><p>Instructions are provided for deployment to Heroku.</p>
<p>It’s common for technically skilled people to want to set up their own servers. Please, do yourself a favor, and unless system administration is your most dearly loved recreation, let the platform providers do it for you.</p>
<h3>Email Service Providers</h3>
<p>You’ll need infrastructure for three types of email:</p>
<ul>
<li>company email</li>
	<li>email sent from the app (“transactional email”)</li>
	<li>broadcast email for newsletters or announcements</li>
</ul><p>No single vendor is optimal for all three types of email; you likely will use several vendors. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a> for suggestions for various types of email service providers.</p>
<h3>Domain Registration</h3>
<p>You’ve likely already selected and registered a domain name. If not, you’ll need a domain before you start sending email messages from the application. If you’re disgusted by GoDaddy, consider <a href="http://www.namecheap.com/">NameCheap</a> and other popular alternatives.</p>
<h3>GitHub</h3>
<p>Get a <a href="https://github.com/signup/free">free GitHub account</a> if you don’t already have one. You’ll need a GitHub account if you plan to deploy to Heroku. If you’re not going to use Heroku, you’ll still need to use git to manage your source code.  See <a href="http://railsapps.github.com/rails-git.html">GitHub and Rails</a> if you need more information about working with git for code source control.</p>
<h2>Architecture and Implementation</h2>
<p>Here is a high-level abstraction of the application, as a list of systems:</p>
<ul>
<li>user management with Devise (to register or remove users)</li>
	<li>authentication with Devise (log in and log out)</li>
	<li>authorization management with CanCan and Rolify (access determined by the subscription plan)</li>
	<li>account management to maintain records of subscription status</li>
	<li>recurring billing with Stripe</li>
	<li>landing pages</li>
	<li>content or service pages</li>
</ul><h3>User Management, Authentication, and Authorization</h3>
<p>The tutorial for the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> example application shows how to set up user management and authentication using Devise, as well as authorization management using CanCan and Rolify. The first step in the tutorial will be to generate the rails3-bootstrap-devise-cancan application as a starter app.</p>
<p>Users are managed with the User model, which has attributes for name, email, and password, as well as some fields provided by Devise such as sign_in_count. The Devise gem provides its own controllers for managing sessions, registration, email confirmation and similar functions. You won’t see these controllers as they are hidden in the gem itself.</p>
<p>CanCan uses an Ability model to set access control rules. We’ll modify the Ability model to set access rules based on subscription plans. We’ll use the Role model required by Rolify to define roles based on subscription plans.</p>
<h3>Account Management and Recurring Billing</h3>
<p>An account management system keeps subscription records so the access control system can determine which users are current subscribers. We’ll combine services offered by Stripe with user management provided by Devise for our account management system.</p>
<p>Stripe will provide the recurring billing system to store the users’ credit card data and initiate payment transactions.</p>
<p>We’ll use the Stripe <span class="caps">API</span> to create a new customer and specify a subscription plan. When the customer’s subscription expires due to failed payment, we’ll use Stripe “webhooks” to update our application’s user records.</p>
<p>We’ll provide options for the user to change credit cards, upgrade or downgrade subscription plans, and cancel a subscription as an extension of the user management system provided by Devise.</p>
<p>Two approaches are possible in building a recurring billing system. You could implement a complete billing management system as part of the application. This would require building a mechanism to check for expiring subscriptions (typically a daily cron job) and initiate payment requests through Stripe when a user’s account comes due. With this approach, you would use Stripe only for processing credit card transactions. But there’s no reason to implement recurring billing yourself. Stripe provides a complete, well-tested, and hosted mechanism for recurring billing. We’ll use Stripe’s <span class="caps">API</span> to supply the recurring billing services we need.</p>
<p>A key requirement for the application is to keep the recurring billing and account management systems in sync. We face a problem if we establish a new subscription, hand off recurring billing to Stripe, and then months later find that the subscriber’s credit card has expired and can no longer be billed. We need a mechanism to update our subscription status when Stripe encounters a declined transaction. Stripe provides “webhooks” to set the status of a subscription. When Stripe encounters a declined transaction it will initiate an <span class="caps">HTTP</span> request to our application which we can decode to change a subscription status.</p>
<p>If we didn’t use the Stripe webhooks, we’d have to either query the Stripe <span class="caps">API</span> on each login or run a repeating cron job to check for subscription expiration. The application will be notified immediately by Stripe so there is no need for the overhead of checking on each login. The Stripe webhook mechanism is very robust: If for some reason it cannot make an <span class="caps">HTTP</span> request to our application, it will retry several times with exponential backoff.</p>
<p>A key requirement for any ecommerce site that takes credit cards is <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> to minimize risk of customer credit card exposure. Using Stripe, your server will never receive sensitive credit card details. Instead you’ll use a the Stripe JavaScript library on your subscription payment form which sends the credit card details directly to the Stripe servers. Your site will meet <span class="caps">PCI</span> compliance requirememts if you solely accept payment information through the Stripe JavaScript library and serve your payment page over <span class="caps">SSL</span>.</p>
<h3>Landing Pages</h3>
<p>Landing pages serve to describe the value of the content or service and convince the visitor to purchase a subscription. For our example application, the home page of the application is our landing page.</p>
<h3>Content or Service</h3>
<p>We’ll create placeholder pages for content.</p>
<p>For your application, the content can be anything you like: photo galleries, videos, downloadable ebooks. For a SaaS site, subscribers would gain access to a web application.</p>
<h3>The Object Model</h3>
<p>Software engineering attempts to model real-world entities and behaviors. As developers, we try to choose descriptive names for objects and methods to reduce ambiguity and increase understanding. For this application, a User is our most important object. In other projects, we might call this object an “Account” or “Member.”</p>
<p>Users have several important attributes: email address, password, credit card number, subscription plan. A user also has less important attributes such as name or creation date. Any of these attributes could be separate objects that are associated with the user through an id or key. You could make “Subscription” or “Plan” an object associated with a user. To keep this application simple, we’ll define everything we need as attributes of the user, rather than separate objects.</p>
<p>We won’t include a credit card number as an attribute of a user because we don’t want the vulnerability of storing a credit card number in our database. Instead, we’ll send the credit card number directly to Stripe and obtain a Stripe customer id that serves as an indirect reference to the credit card number when we need to ask Stripe to begin billing a user. The Stripe customer id will be an attribute of the user that substitutes for a credit card number.</p>
<p>Our authorization system is based on the concept of roles. The user’s role constrains his or her access to the website’s content pages. Though “Subcription Plan” and “Role” appear to be distinct concepts, in this application they functionally overlap. We’ll use the Role model supplied by the Rolify gem as an object that corresponds to a “Subcription Plan.” Each user will have a role id that describes the subscription plan (or access level) that he or she has purchased.</p>
<h2>Testing and the Software Development Process</h2>
<p>This example application uses RSpec for unit testing and Cucumber for integration testing.</p>
<p>Testing is at the center of any robust software development process. Integration tests determine whether the application’s features work as expected, testing the application from the point of view of the user. Unit tests confirm that small, discrete portions of the application continue working as developers add features and refactor code. RSpec is a popular choice for unit testing. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up RSpec and provides example specs for use with Devise. Cucumber is a popular choice for integration testing and behavior driven development. The <a href="http://railsapps.github.com/tutorial-rails-devise-rspec-cucumber.html">rails3-devise-rspec-cucumber tutorial</a> shows how to set up Cucumber and provides example scenarios for use with Devise.</p>
<p>This tutorial assumes you’ve learned to write tests elsewhere (see a list of <a href="http://railsapps.github.com/rails.html">recommended resources for Rails</a>). I won’t spend time showing you how to write tests but you can use tests to make sure the application works as expected.</p>
<p>The Rails Composer tool creates a starter app that is set up for RSpec and Cucumber test frameworks.</p>
<h2>Assumptions</h2>
<p>Before beginning this tutorial, you need to install</p>
<ul>
<li>The Ruby language (version 1.9.3)</li>
	<li>Rails 3.2</li>
</ul><p>Check that appropriate versions of Ruby and Rails are installed in your development environment:<br><code>$ ruby -v</code><br><code>$ rails -v</code></p>
<p>Be sure to read <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a> to make sure your development environment is set up properly.</p>
<p>I recommend using <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager to manage your Rails versions and create a dedicated gemset for each application you build.</p>
<h2>Creating the Application</h2>
<p>You have several options for getting the code. You can <em>copy from the tutorial</em>, <em>fork</em>, <em>clone</em>, or <em>generate</em>.</p>
<p>Keep in mind that this is a starter application. If you want to add this code to an existing application, you can follow the tutorial and cut and paste the code into your existing application, resolving any conflicts as needed.</p>
<h3>Copy from the Tutorial</h3>
<p>To create the application, you can cut and paste the code from the tutorial into your own files. It’s a bit tedious and error-prone but you’ll have a good opportunity to examine the code closely. Before you start, the tutorial will ask you to use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate a starter app to save some steps. Then you can follow the tutorial step-by-step to build the complete application.</p>
<h3>Fork</h3>
<p>If you’d like to add features (or bug fixes) to improve the example application, you can fork the GitHub repo and <a href="http://help.github.com/send-pull-requests/">make pull requests</a>. Your code contributions are welcome!</p>
<h3>Clone</h3>
<p>If you want to copy and customize the app with changes that are only useful for your own project, you can download or clone the GitHub repo. You’ll need to search-and-replace the project name throughout the application. You probably should generate the app instead (see below). To clone:</p>
<pre>
$ git clone git://github.com/RailsApps/rails-stripe-membership-saas.git
</pre>

<p>You’ll need <a href="http://git-scm.com/">git</a> on your machine. See <a href="http://railsapps.github.com/rails-git.html">Rails and Git</a>.</p>
<h3 id="Generate">Generate</h3>
<p>If you wish to skip the tutorial and build the application immediately, use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool to generate the complete example app. You’ll be able to give it your own project name when you generate the app. Generating the application gives you additional options.</p>
<p>To build the complete example application immediately, see the instructions in the <span class="caps">README</span> for the <a href="http://github.com/RailsApps/rails-stripe-membership-saas/">rails-stripe-membership-saas</a> example application.</p>
<h2>Create the Rails Application</h2>
<p>Before you write any code, you’ll start by generating a starter app using an application template script.</p>
<p>If you’ve developed other applications in Rails, you’ll know that the <code>rails new</code> command creates a basic Rails application. Here we’ll use the <a href="http://railsapps.github.com/rails-composer/">Rails Composer</a> tool (“like the <code>rails new</code> command on steroids”) to create a starter app. The starter app saves us some steps. Devise will be installed with Cancan for authorization. Twitter Bootstrap will be set up as a front end for <span class="caps">CSS</span> styling. If you want a tutorial that shows you the steps that build the starter app, see the <a href="http://railsapps.github.com/tutorial-rails-bootstrap-devise-cancan.html">rails3-bootstrap-devise-cancan</a> tutorial.</p>
<p>For the starter app we need, use the command:</p>
<pre>
$ rails new rails-stripe-membership-saas -m https://raw.github.com/RailsApps/rails-composer/master/composer.rb -T
</pre>
<p>Use the <code>-T</code> flag to skip Test::Unit files since we’ll be using RSpec.</p>
<p>The <code>$</code> character indicates a shell prompt; don’t include it when you run the command.</p>
<p>This creates a new Rails app named <code>rails-stripe-membership-saas</code> on your computer. You can use a different name if you wish.</p>
<p>You’ll see a prompt:</p>
<pre>
question  Install an example application?
      1)  I want to build my own application
      2)  rails-stripe-membership-saas
      3)  rails-prelaunch-signup
      4)  rails3-bootstrap-devise-cancan
      5)  rails3-devise-rspec-cucumber
      6)  rails3-mongoid-devise
      7)  rails3-mongoid-omniauth
      8)  rails3-subdomains
</pre>
<p>Choose <strong>rails3-bootstrap-devise-cancan</strong>. The Rails Composer tool may give you other options (other choices may have been added since this tutorial was written). <strong>Note:</strong> Don’t choose “rails-stripe-membership-saas” (unless you want to skip the tutorial).</p>
<p>The application generator template will ask you for additional preferences:</p>
<pre>
 question  Web server for development?
       1)  WEBrick (default)
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Web server for production?
       1)  Same as development
       2)  Thin
       3)  Unicorn
       4)  Puma
 question  Template engine?
       1)  ERB
       2)  Haml
       3)  Slim
   extras  Set a robots.txt file to ban spiders? (y/n)
   extras  Create a project-specific rvm gemset and .rvmrc? (y/n)
   extras  Create a GitHub repository? (y/n)
</pre>
<h4>Web Servers</h4>
<p>Use the default WEBrick server for convenience. If you plan to deploy to Heroku, select “thin” as your production webserver.</p>
<h4>Template Engine</h4>
<p>The example application uses the default “<span class="caps">ERB</span>” Rails template engine. Optionally, you can use another template engine, such as Haml or Slim. See instructions for <a href="http://railsapps.github.com/rails-haml.html">Haml and Rails</a>.</p>
<h4>Other Choices</h4>
<p>Set a robots.txt file to ban spiders if you want to keep your new site out of Google search results.</p>
<p>It is a good idea to use <a href="https://rvm.io/">rvm</a>, the Ruby Version Manager, and create a project-specific rvm gemset and .rvmrc file (not available on Windows). See <a href="http://railsapps.github.com/installing-rails.html">Installing Rails</a>.</p>
<p>If you choose to create a GitHub repository, the generator will prompt you for a GitHub username and password.</p>
<p>After you create the application, switch to its folder to continue work directly in the application:</p>
<p><code>$ cd rails-stripe-membership-saas</code></p>
<h4>Troubleshooting</h4>
<p>If you get an error “OpenSSL certificate verify failed” or “Gem::RemoteFetcher::FetchError: SSL_connect” see the article <a href="http://railsapps.github.com/openssl-certificate-verify-failed.html">OpenSSL errors and Rails</a>.</p>
<p>If you get an error like this:</p>
<pre>
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
    composer  Running 'after bundler' callbacks.
The template [...] could not be loaded.
Error: You have already activated ..., but your Gemfile requires .... 
Using bundle exec may solve this.
</pre>
<p>It’s due to conflicting gem versions. See the article <a href="http://railsapps.github.com/rails-error-you-have-already-activated.html">Rails Error: “You have already activated (…)”</a>.</p>
<h4>Replace the READMEs</h4>
<p>Please edit the <span class="caps">README</span> files to add a description of the app and your contact info. Changing the <span class="caps">README</span> is important if your app will be publicly visible on GitHub. Otherwise, people will think I am the author of your app. If you like, add an acknowledgment and a link to the <a href="http://railsapps.github.com/">RailsApps project</a>.</p>
<h2>Set Up Source Control (Git)</h2>
<p>When you generate the starter app, the template sets up a source control repository and makes an initial commit of the code.</p>
<p>At your request, the template will also create a GitHub repository for your project.</p>
<p>See detailed instructions for <a href="http://railsapps.github.com/rails-git.html">Git and Rails</a>.</p>
<p>Git has already been initialized by the application template script. If you’ve selected the GitHub option, the template commits your code to your GitHub repository.</p>
<h2>Set Up Gems</h2>
<p>The Rails Composer program sets up your Gemfile and (if you are using rvm) creates a project-specific gemset.</p>
<p>Open your <strong>Gemfile</strong> and you should see the following. Gem version numbers may differ:</p>
<pre>
source 'https://rubygems.org'
gem 'rails', '3.2.8'
gem 'sqlite3'
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'
  gem 'uglifier', '&gt;= 1.0.3'
end
gem 'jquery-rails'
gem "rspec-rails", "&gt;= 2.11.0", :group =&gt; [:development, :test]
gem "email_spec", "&gt;= 1.2.1", :group =&gt; :test
gem "cucumber-rails", "&gt;= 1.3.0", :group =&gt; :test, :require =&gt; false
gem "database_cleaner", "&gt;= 0.9.1", :group =&gt; :test
gem "launchy", "&gt;= 2.1.2", :group =&gt; :test
gem "capybara", "&gt;= 1.1.2", :group =&gt; :test
gem "factory_girl_rails", "&gt;= 4.1.0", :group =&gt; [:development, :test]
gem "bootstrap-sass", "&gt;= 2.1.0.0"
gem "devise", "&gt;= 2.1.2"
gem "cancan", "&gt;= 1.6.8"
gem "rolify", "&gt;= 3.2.0"
gem "simple_form", "&gt;= 2.0.4"
gem "quiet_assets", "&gt;= 1.0.1", :group =&gt; :development
</pre>
<p>Add the following gems which will be needed for the rails-stripe-membership-saas application:</p>
<pre>
gem "stripe"
gem "stripe_event"
</pre>
<p>Check for the <a href="http://rubygems.org/gems/rails">current version of Rails</a> and replace <code>gem 'rails', '3.2.8'</code> accordingly.</p>
<p><em>Note:</em> Rails Composer templates are created by the <a href="https://github.com/RailsApps/rails_apps_composer">Rails Apps Composer Gem</a>. For that reason, groups such as <code>:development</code> or <code>:test</code> are specified inline. You can reformat the Gemfiles to organize groups in an eye-pleasing block style. The functionality is the same.</p>
<h3>Install the Required Gems</h3>
<p>When you add a new gem to the Gemfile, you should run the <code>bundle install</code> command to install the required gems on your computer. Run:</p>
<pre>
bundle install
</pre>
<p>You can check which gems are installed on your computer with:</p>
<pre>
$ gem list
</pre>
<p>Keep in mind that you have installed these gems locally. When you deploy the app to another server, the same gems (and versions) must be available.</p>
<h2>RSpec</h2>
<p>The starter app script sets up RSpec for unit testing. Run <code>rake -T</code> to check that rake tasks for RSpec are available. You should be able to run <code>rake spec</code> to run all specs provided with the example app. To learn more about using RSpec, refer to <a href="http://www.pragprog.com/titles/achbd/the-rspec-book">The RSpec Book</a>.</p>
<h2>Cucumber</h2>
<p>The starter app script sets up Cucumber for specifications and acceptance testing. To learn more about using Cucumber, refer to <a href="http://pragprog.com/book/hwcuc/the-cucumber-book">The Cucumber Book</a> or the free introduction to Cucumber, <a href="http://cuke4ninja.com/">The Secret Ninja Cucumber Scrolls</a>.</p>
<p>You should be able to run <code>rake cucumber</code>, or more simply, <code>cucumber</code>, to run the Cucumber scenarios and steps provided with the example app. You can run a single Cucumber feature with a command such as:</p>
<pre>
$ cucumber features/visitors/request_invitation.feature
</pre>
<p>If you’ve used Cucumber, you may know that you need to add <code>--require features</code> to run a single Cucumber feature. Here it is not necessary to do so; the starter app script sets up the <strong>config/cucumber.yml</strong> file so it is not necessary to add <code>--require features</code>.</p>
<h2>Configure Email</h2>
<p>The starter app script sets up a default email configuration. You must configure the application for your email account. See the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a>.</p>
<h3>Configure ActionMailer</h3>
<p>The starter app has already configured ActionMailer but you must set your email account details.</p>
<p>Replace <code>example.com</code> in the <strong>config/environments/production.rb</strong> file:</p>
<pre>
config.action_mailer.default_url_options = { :host =&gt; 'example.com' }
# ActionMailer Config
# Setup for production - deliveries, no errors raised
config.action_mailer.delivery_method = :smtp
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = false
config.action_mailer.default :charset =&gt; "utf-8"
</pre>
<p>The example application will deliver email in production. Email messages are visible in the log file so there is no need to send email in development.</p>
<h3>How to Use a Gmail Account</h3>
<p>In production, you should use an email service provider such as <a href="http://mandrill.com/">Mandrill</a> to increase deliverability for email messages from your app.</p>
<p>Use Gmail for experimenting, if you want to keep things simple.</p>
<p>The file <strong>config/environments/production.rb</strong> is set to use:</p>
<pre>
config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: "example.com",
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
</pre>
<p>You can replace <code>ENV["GMAIL_USERNAME"]</code> and <code>ENV["GMAIL_PASSWORD"]</code> with your Gmail username and password. However, committing the file to a public GitHub repository will expose your secret password. Instead, follow the instructions in the article <a href="http://railsapps.github.com/rails-send-email.html">Send Email with Rails</a> to set Unix environment variables to keep email account passwords secret.</p>
<h2>Set Up the Database</h2>
<h3>Create a Default User</h3>
<p>You’ll want to set up default users so you can test the application.</p>
<p>The file <strong>db/seeds.rb</strong> already contains:</p>
<pre>
puts 'CREATING ROLES'
Role.create([
  { :name =&gt; 'admin' }, 
  { :name =&gt; 'user' }, 
  { :name =&gt; 'VIP' }
], :without_protection =&gt; true)
puts 'SETTING UP DEFAULT USER LOGIN'
user = User.create! :name =&gt; 'First User', :email =&gt; 'user@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
puts 'New user created: ' &lt;&lt; user.name
user2 = User.create! :name =&gt; 'Second User', :email =&gt; 'user2@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
puts 'New user created: ' &lt;&lt; user2.name
user.add_role :admin
user2.add_role :VIP
</pre>
<p>The starter app contains a placeholder list of roles. One role is “admin,” for an adminstrator. We should remove the “user” and “<span class="caps">VIP</span>” roles and add three additional roles corresponding to our subscription plans, “silver”, “gold”, and “platinum.” Notice we have to supply the argument <code>:without_protection =&gt; true</code> to override the mass-assignment protection configured in the Role class.</p>
<p>Then we’ll add three users with different subscription plans.</p>
<p>Replace <strong>db/seeds.rb</strong> with:</p>
<pre>
puts 'CREATING ROLES'
Role.create([
  { :name =&gt; 'admin' }, 
  { :name =&gt; 'silver' }, 
  { :name =&gt; 'gold' },
  { :name =&gt; 'platinum' }
], :without_protection =&gt; true)
puts 'SETTING UP DEFAULT USER LOGIN'
user = User.create! :name =&gt; 'First User', :email =&gt; 'user@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user.add_role :admin
puts 'admin created: ' &lt;&lt; user.name
user2 = User.create! :name =&gt; 'Silver User', :email =&gt; 'user2@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user2.add_role :silver
user3 = User.create! :name =&gt; 'Gold User', :email =&gt; 'user3@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user3.add_role :gold
user4 = User.create! :name =&gt; 'Platinum User', :email =&gt; 'user4@example.com', :password =&gt; 'please', :password_confirmation =&gt; 'please'
user4.add_role :platinum
puts "added users: #{user2.name}, #{user3.name}, #{user4.name}"
</pre>
<p>The first user will be given an administrator role. You can log in with this account for access as an administrator.</p>
<p>We’ve added three users and assigned “silver,” “gold,” and “platinum” roles corresponding to a tiered subscription plan.</p>
<p>You can change the values for name, email, and password as you wish.</p>
<p>If you include your private password in the file, be sure to add the filename to your <strong>.gitignore</strong> file so that your password doesn’t become available in your public GitHub repository.</p>
<p>Note that it’s not necessary to personalize the <strong>db/seeds.rb</strong> file before you deploy your app. You can deploy the app with an example user and then use the application’s “Edit Account” feature to change name, email address, and password after you log in. Use this feature to log in as an administrator and change the user name and password to your own.</p>
<p>The <strong>db/seeds.rb</strong> file is the only place where we create a list of possible roles. There is no other configuration of roles.</p>
<p>It’s not strictly necessary to create the list of roles before creating the users. Any new role can be added to the roles datatable with a statement such <code>user.add_role :superhero</code>. Howver, I suggest you create a full list of roles in the <strong>db/seeds.rb</strong> file. If you don’t, users may not have a full range of subscription plans to choose from for an upgrade or downgrade of plans.</p>
<h3>Seed the Database</h3>
<p>The starter app script has already set up the database and added the default user by running:</p>
<pre>
$ rake db:migrate
$ rake db:seed
</pre>
<p>We’ll need to reset the database because we’ve added new users:</p>
<pre>
$ rake db:reset
</pre>
<p>You can run <code>$ rake db:reset</code> whenever you need to recreate the database.</p>
<p>You’ll also need to set up the database for testing:</p>
<pre>
$ rake db:test:prepare
</pre>
<p>If you’re not using <a href="https://rvm.io/">rvm</a>, you should preface each rake command with <code>bundle exec</code>. You don’t need to use <code>bundle exec</code> if you are using rvm version 1.11.0 or newer.</p>
<h2>Test the Starter App</h2>
<p>At this point, the app is identical to the <a href="https://github.com/RailsApps/rails3-bootstrap-devise-cancan">rails3-bootstrap-devise-cancan</a> starter app.</p>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>. You should see the default users listed on the home page. When you click on a user’s name, you should be required to log in before seeing the user’s detail page.</p>
<p>If you sign in as the first user, you will have administrative privileges. You’ll see an “Admin” link in the navigation bar. Clicking the “Admin” link will display the administrative dashboard. Each user will be listed with buttons to “Change role” or “Delete user.”</p>
<p>Stop the server with Control-C.</p>
<h4>When to Restart</h4>
<p>If you install new gems, you’ll have to restart the server to see any changes. The same is true for changes to configuration files in the config folder. This can be confusing to new Rails developers because you can change files in the app folders without restarting the server. As a rule, remember to restart the server when you add gems, change routes, or change anything in the config folder; leave the server running whn you change models, controllers, views or anything else in app folder.</p>
<h2>Replace the Home Page</h2>
<p>If you’ve tested the example app, you’ve seen that any user who logs in will see a list of all the users on the home page. That’s fine for an example app but it’s not what we want for a subscription site.</p>
<h3>Home Page with Subscription Plans</h3>
<p>We’ll put our subscription offer and pricing plan on the home page. For this tutorial, it’s simplest to show the offer and prices right on the home page. For a real application, you might describe your offer on the home page and show pricing on a separate page.</p>
<p>Replace the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_silver_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_gold_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', content_platinum_path, :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We apply <span class="caps">CSS</span> classes from Twitter Bootstrap to style the page. We’ll create a few additional <span class="caps">CSS</span> classes in the next step.</p>
<p>The page contains a “hero unit” for your key marketing message plus three boxes describing subscription plans.</p>
<p>Each box contains a link to a content page. The content pages don’t yet exist; we’ll need to create a Content controller, routes, and views to implement the content pages. Later, we’ll change the links to open a subsciption purchase page instead of a content page.</p>
<h3>
<span class="caps">CSS</span> for Subscription Plans</h3>
<p>We’ll provide some rudimentary <span class="caps">CSS</span> rules to style the home page. We’re using Twitter Bootstrap so we’ll get an attractive design with only a few <span class="caps">CSS</span> rules.</p>
<p>First, modify the <strong>app/assets/stylesheets/application.css.scss</strong> file to remove the following <span class="caps">CSS</span> rules. These rules were useful for the starter app but will not be used in our application:</p>
<pre>
.content {
  background-color: #eee;
  padding: 20px;
  margin: 0 -20px; /* negative indent the amount of the padding to maintain the grid system */
  -webkit-border-radius: 0 0 6px 6px;
  -moz-border-radius: 0 0 6px 6px;
  border-radius: 0 0 6px 6px;
  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  -moz-box-shadow: 0 1px 2px rgba(0,0,0,.15);
  box-shadow: 0 1px 2px rgba(0,0,0,.15);
}
</pre>
<p>Next we’ll add <span class="caps">CSS</span> assets to style the home page.</p>
<p>Create a file <strong>app/assets/stylesheets/pricing.css.scss</strong>:</p>
<pre>
.plans{
  text-align: center;
}
.featured{
  -webkit-transform:scale(1.15); 
  box-shadow: 0 0 30px rgba(0, 0, 0, 0.67);
}
.plan{
  background-color: #111575;
}
.plan.featured-plan{
  background-color: #CCAB00;
}
.plan h2{
  line-height: 100px;
  color: #fff;
}
</pre>
<p>This stylesheet gets added automatically to the asset pipeline because any files in the same folder as the <strong>app/assets/stylesheets/application.css.scss</strong> file are added by the <code>*= require_tree .</code> statement.</p>
<p>This <span class="caps">CSS</span> will provide the design elements that are commonly seen on a pricing page: boxes for each plan with an enlarged box for a “featured plan.”</p>
<p>The design is adequate for our tutorial but you may want to improve it to be more effective. If you’re not a designer, you may want to look at the Twitter Bootstrap themes available in the <a href="https://wrapbootstrap.com/">WrapBootstrap</a> marketplace. The theme for <a href="https://wrapbootstrap.com/theme/css3-pricing-tables-WB00H9006">CSS3 Pricing Tables</a> is particularly interesting. It is similar to our home page but adds animated effects. The theme only costs $6 and you can easily integrate it into our application by copying the contents of the designer’s <strong>css/custom.css</strong> file into our <strong>app/assets/stylesheets/pricing.css.scss</strong> file and replacing styles in our <strong>app/views/home/index.html.erb</strong> file.</p>
<h3>Modify the Home Controller</h3>
<p>Modify the file <strong>app/controllers/home_controller.rb</strong> to remove the <code>index</code> method:</p>
<pre>
class HomeController &lt; ApplicationController
end
</pre>
<h3>Commit to Git</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "home page update"
</pre>
<h2>Add Content Pages</h2>
<p>We’ll add placeholder pages for our valuable content.</p>
<p>First let’s consider a git workflow for adding a new feature.</p>
<h3>Git Workflow</h3>
<p>When you are using git for version control, you can commit every time you save a file, even for the tiniest typo fixes. If only you will ever see your git commits, no one will care. But if you are working on a team, either commercially or as part of an open source project, you will drive your fellow programmers crazy if they try to follow your work and see such “granular” commits. Instead, get in the habit of creating a git branch each time you begin work to implement a feature. When your new feature is complete, merge the branch and “squash” the commits so your comrades see just one commit for the entire feature.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b content-pages
</pre>
<p>The command creates a new branch named “content-pages” and switches to it, analogous to copying all your files to a new directory and moving to work in the new directory (though that is not really what happens with git).</p>
<h3>Create the Content Controller and Views</h3>
<p>Use the <code>rails generate</code> command to create a controller and associated views:</p>
<pre>
$ rails generate controller content silver gold platinum --skip-stylesheets --skip-javascripts
</pre>
<p>We’ve named the controller the “ContentController.” The default route will put our content pages in an apparent “content” directory with the <span class="caps">URL</span> path <a href="http://localhost:3000/content/">http://localhost:3000/content/</a>. You could give the controller another name if you want a different <span class="caps">URL</span> path but it’s easier to keep the same controller name and change the path in the <strong>config/routes.rb</strong> file (described below).</p>
<p>We’ve asked for three views, corresponding to the three subscription plans we’ll offer. We’ll use <code>--skip-stylesheets --skip-javascripts</code> to avoid cluttering our application with stylesheet and JavaScript files we don’t need.</p>
<p>The Rails generator will create these files for you:</p>
<pre>
app/controllers/content_controller.rb
app/helpers/content_helper.rb
app/views/content/gold.html.erb
app/views/content/platinum.html.erb
app/views/content/silver.html.erb
spec/controllers/content_controller_spec.rb
</pre>
<p>It also modifies the <strong>config/routes.rb</strong> file to add three routes:</p>
<pre>
get "content/silver"
get "content/gold"
get "content/platinum"
</pre>
<p>If you want a different <span class="caps">URL</span> path, you could specify a different path like this: <code>get "articles/silver" =&gt; "content#silver", :as =&gt; :content_silver</code>. Visitors will see a <span class="caps">URL</span> path <a href="http://localhost:3000/articles/silver">http://localhost:3000/articles/silver</a> but you won’t need to make any other changes to the application. We won’t do this; we’ll just use the supplied path.</p>
<p>If you look at <strong>app/controllers/content_controller</strong> controller, you’ll see it is very simple:</p>
<pre>
class ContentController &lt; ApplicationController

  def silver
  end

  def gold
  end
  
  def platinum
  end
end
</pre>
<p>It may be odd to see a controller that doesn’t contain the familar <code>index</code>, <code>show</code>, etc. methods of a RESTful controller. This is a case where a RESTful controller is not needed or appropriate. By default, the controller will render a view corresponding to each action.</p>
<h3>Check the Content Views</h3>
<p>Open each of the view files to see the placeholder content.</p>
<p><strong>app/views/content/silver.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#silver&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/silver.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/gold.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#gold&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/gold.html.erb&lt;/p&gt;
</pre>
<p><strong>app/views/content/platinum.html.erb</strong></p>
<pre>
&lt;h1&gt;Content#platinum&lt;/h1&gt;
&lt;p&gt;Find me in app/views/content/platinum.html.erb&lt;/p&gt;
</pre>
<p>If you’re building a real application, you’ll want to provide content that is more useful than our placeholders. For a membership site that delivers content such as ebooks or videos, you could use a structure such as this, where we’ll restrict access to pages in a <strong>content</strong> directory based on the user’s subscription plan. For a site that delivers software as a service, the structure of your application will necessarily be more complex.</p>
<h3>Test the Content Pages</h3>
<p>You can check that the example app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your subscription offer.</p>
<p>Visit <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a> to see one of the content pages.</p>
<p>Next we’ll set up access control to limit access to the content pages.</p>
<h3>Git Workflow</h3>
<p>If you haven’t commited any changes yet, commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add content pages"
</pre>
<p>Since the new feature is complete, merge the working branch to “master” and squash the commits so you have just one commit for the entire feature:</p>
<pre>
$ git checkout master
$ git merge --squash content-pages
$ git commit -m "add content pages"
</pre>
<p>You can delete the working branch when you’re done:</p>
<pre>
$ git branch -D content-pages
</pre>
<h2>Implement Authorization</h2>
<p>We’ve got a home page with links to content pages for Silver, Gold, and Platinum subscribers. And we have created three users: Silver User, Gold User, and Platinum User. Now we’ll set limits on access to the content.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b authorization
</pre>
<h3>Set CanCan Ability</h3>
<p>Modify the <strong>app/models/ability.rb</strong> class to set access limits:</p>
<pre>
class Ability
  include CanCan::Ability

  def initialize(user)
    user ||= User.new # guest user (not logged in)
    if user.has_role? :admin
      can :manage, :all
    else
      can :view, :silver if user.has_role? :silver
      can :view, :gold if user.has_role? :gold
      can :view, :platinum if user.has_role? :platinum
    end
  end
end
</pre>
<p>CanCan takes advantage of the Ruby language’s facility to create a <span class="caps">DSL</span> (Domain Specific Language). If you ignore the cryptic punctuation, it’s possible to read the <span class="caps">DSL</span> as if it was English. The statement <code>can :view, :silver if user.has_role? :silver</code> does what it says: If the user has a role of “silver” he or she can view “silver” content. Actually, a good portion of this is arbitrary. CanCan allows us to pass arbitrary parameters to the authorization method and I’ve simply chosen “view” and “silver” to be descriptive. All that matters is to use the same symbols in the Ability class as in the <code>authorize!</code> call in the controller. In the next step, you’ll see how we add the <code>authorize!</code> call to the controller.</p>
<h3>Set Access Limits in the Content Controller</h3>
<p>We’ll modify the <strong>app/controllers/content_controller</strong> file to set access limits:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!
  
  def silver
    authorize! :view, :silver, :message =&gt; 'Access limited to Silver Plan subscribers.'
  end
  
  def gold
    authorize! :view, :gold, :message =&gt; 'Access limited to Gold Plan subscribers.'
  end

  def platinum
    authorize! :view, :platinum, :message =&gt; 'Access limited to Platinum Plan subscribers.'
  end
end
</pre>
<p>We add <code>before_filter :authenticate_user!</code> (provided by Devise) to force a visitor to log in before any action.</p>
<p>We use the CanCan <code>authorize!</code> method to check the user’s role (corresponding to their subscription plan) on the actions that render the content pages. We pass two symbols to both <code>authorize!</code> (in the controller) and <code>can</code> (in the Ability class). The symbols can represent anything. By convention, the first symbol is the “action” one is trying to perform and the second symbol is the subject or target the action is being performed on. Our action is to “view” content but we could also say “see”, “access”, or “unlock.” We’ve defined one target as “silver” but it could be “silver_content”, “tier1”, or “plan-A” as long as we are consistent between the controller and Ability class. The CanCan documentation describes <a href="https://github.com/ryanb/cancan/wiki/Non-RESTful-Controllers">CanCan with Non-RESTful Controllers</a>.</p>
<h3>Alternative Implementation</h3>
<p>Keep in mind that we use CanCan only for convenience. You might not agree that CanCan provides benefit, especially when you consider that the CanCan <span class="caps">DSL</span> obscures the authorization mechanism. Cancan offers the advantage of collecting all authorization rules in the Ability class so the rules are easy to find and change. And it provides a familiar idiom for authorization so it is easy for other Rails developers (those who use CanCan) to understand your code.</p>
<p>If CanCan seems mysterious, it might help to see an alternative implementation without CanCan.</p>
<p>Here’s the <strong>app/controllers/content_controller</strong> file without CanCan:</p>
<pre>
class ContentController &lt; ApplicationController
  before_filter :authenticate_user!
  
  def silver
    if (current_user.has_role? :silver) || (current_user.has_role? :admin)
      render :silver
    else
      redirect_to :back, :notice =&gt; 'Access limited to Silver Plan subscribers.'
    end
  end
 
  def gold
   if (current_user.has_role? :gold) || (current_user.has_role? :admin)
      render :gold
    else
      redirect_to :back, :notice =&gt; 'Access limited to Gold Plan subscribers.'
    end
  end
  
  def platinum
    if (current_user.has_role? :platinum) || (current_user.has_role? :admin)
      render :platinum
    else
      redirect_to :back, :notice =&gt; 'Access limited to Platinum Plan subscribers.'
    end
  end
end
</pre>
<p>By using the <code>:authenticate_user!</code> before_filter, Devise makes available the <code>current_user</code> instance of the User model. We still use the <code>has_role?</code> method provided by Rolify. If the current_user has an appropriate role, we render the appropriate page. If not, we redirect to the previous page and display a notice. The code is much easier to understand without CanCan but it is lengthy and repetitive.</p>
<p><em>Note:</em> Please don’t blindly paste the alternative implementation into the <strong>app/controllers/content_controller</strong> file if you want to follow the tutorial. We’ll continue to use CanCan.</p>
<h3>Test Authorization</h3>
<p>You can check that the authorization limits work by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Log in as the first user (the administrator) with “user@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan grants you access as an administrator to any page. Log out.</p>
<p>Log in as the second user (assigned a “silver plan”) with “user2@example.com@” (password “please”). Click on the “Subscribe” button for any subscription plan. CanCan only grants access to the “silver” content page.</p>
<p>Next we’ll set up a page where a visitor can register to use the site after choosing a subscription plan.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add authorization"
$ git checkout master
$ git merge --squash authorization
$ git commit -m "add authorization"
$ git branch -D authorization
</pre>
<h2>Registration Page</h2>
<p>Now that we have a home page with links to our placeholder content pages, plus authorization limits to  restrict access based on subscription plan, let’s create a page where a visitor can register for the site and sign up for a subscription.</p>
<p>For the initial version of our registration page, we’ll let the visitor sign up for any subscription for free. Later, we’ll integrate Stripe payment for purchase of a subscription plan.</p>
<p>The Devise authentication gem provides user management, including signing up users on a registration page. Our starter app already has a User model and uses a Devise controller and views to sign up visitors, asking for a name and email address and creating a user account. We could add a new “subscription purchase” page. Instead, since we already have a sign-up form provided by Devise, it’ll be easier to adapt the existing Devise registration page.</p>
<p>Create a new git branch for this feature:</p>
<pre>
$ git checkout -b registration
</pre>
<h3>Modify the Home Page</h3>
<p>We’ll change the links on the home page to direct the visitors to the Devise registration page.</p>
<p>Update the contents of the file <strong>app/views/home/index.html.erb</strong>:</p>
<pre>
&lt;div id="welcome" class="hero-unit span7"&gt;
  &lt;h1&gt;Membership Site&lt;/h1&gt;
  &lt;h3&gt;Learn to build a successful subscription site.&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="row span8 plans"&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Silver&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;One lesson a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$9/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'silver'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well featured"&gt;
    &lt;div class="plan featured-plan"&gt;&lt;h2&gt;Gold&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Ten lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$19/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'gold'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
  &lt;div class="span2 well"&gt;
    &lt;div class="plan"&gt;&lt;h2&gt;Platinum&lt;/h2&gt;&lt;/div&gt;
    &lt;ul class="unstyled"&gt;
      &lt;li&gt;Thirty lessons a month&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3&gt;$29/month&lt;/h3&gt;
    &lt;%= link_to 'Subscribe', new_user_registration_path(:plan =&gt; 'platinum'), :class =&gt; 'btn btn-primary' %&gt; 
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>We’ve replaced the <span class="caps">URL</span> helper for each of the links:</p>
<ul>
<li>
<code>content_silver_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'silver')</code>
</li>
	<li>
<code>content_gold_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'gold')</code>
</li>
	<li>
<code>content_platinum_path</code> becomes <code>new_user_registration_path(:plan =&gt; 'platinum')</code>
</li>
</ul><p>Notice that we append a parameter to each link to indicate the subscription plan selected by the visitor. We are initiating an <span class="caps">HTTP</span> <span class="caps">GET</span> request so you’ll see a <span class="caps">URL</span> like this: <code>http://lvh.me:3000/users/sign_up?plan=silver</code>.</p>
<h3>Modify the Navigation Links</h3>
<p>Currently visitors see a “Sign up” link on the home page if they are not logged in. We’ll remove the “Sign up” link in the navigation bar because we want them to sign up by selecting a subscription plan.</p>
<p>Modify the file <strong>app/views/layouts/_navigation.html.erb</strong>:</p>
<pre>
&lt;%= link_to "Rails Membership Subscription Saas", root_path, :class =&gt; 'brand' %&gt;
&lt;ul class="nav"&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Logout', destroy_user_session_path, :method=&gt;'delete' %&gt;        
    &lt;/li&gt;
  &lt;% else %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Login', new_user_session_path %&gt;  
    &lt;/li&gt;
  &lt;% end %&gt;
  &lt;% if user_signed_in? %&gt;
    &lt;li&gt;
    &lt;%= link_to 'Edit account', edit_user_registration_path %&gt;
    &lt;/li&gt;
    &lt;% if current_user.has_role? :admin %&gt;
      &lt;li&gt;
      &lt;%= link_to 'Admin', users_path %&gt;
      &lt;/li&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;/ul&gt;
</pre>
<p>We’ve removed the “Sign up” link.</p>
<h3>Override the Devise Registrations Controller</h3>
<p>Create a file <strong>app/controllers/registrations_controller.rb</strong> to override the Devise registrations controller:</p>
<pre>
class RegistrationsController &lt; Devise::RegistrationsController

  def new
    @plan = params[:plan]
    super
  end

  private
  def build_resource(*args)
    super
    if params[:plan]
      resource.add_role(params[:plan])
    end
  end
end
</pre>
<p>We override the controller <code>new</code> action to set the <em>plan</em> variable. This allows us to display the name of the selected subscription plan on the registration page. When we modify the registration form, we’ll include the <em>plan</em> variable in a hidden input field. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons. We call the <code>super</code> method to inherit the original controller <code>new</code> action.</p>
<p>Devise provides a Registrations controller inside the Devise gem. It contains standard RESTful controller actions, including <code>new</code> and <code>create</code> (see <a href="https://github.com/plataformatec/devise/blob/master/app/controllers/devise/registrations_controller.rb">Devise::RegistrationsController</a> on GitHub). Before calling <code>new</code> or <code>create</code>, the Devise Registrations controller initializes a new User with a private method named <code>build_resource</code>. The default <code>build_resource</code> method won’t assign an authorization role to our user. We override the <code>build_resource</code> method, first using the <code>super</code> method to call the parent <code>build_resource</code> method. Then we check if the <em>plan</em> parameter is available. On a <code>new</code> action, it will be available as a parameter passed from the home page. On a <code>create</code> action, it will be passed as a parameter from a hidden input field on the registration form. Rolify has added the <code>add_role</code> method to the User model, so we call <code>add_role</code> to assign the plan as an authorization role. If you’re wondering why you don’t see the User model as a <em>@user</em> variable, Devise has aliased it as the <em>resource</em> instance variable (<em>resource</em> allows Devise to accommodate models with names other than User, such as Account or Person).</p>
<p>Instead of overriding the controller <code>new</code> action, we could use a <code>before_filter</code> to set the <em>plan</em> variable before the <code>new</code> method is called. We could do this:</p>
<pre>
  before_filter :set_plan, :only =&gt; :new

  def set_plan
    @plan = params[:plan]
  end
</pre>
<p>Either implementation is effective; we’ve chosen to  override the <code>new</code> method rather than using a <code>before_filter</code>.</p>
<h3>Override the Devise Routes</h3>
<p>Modify <strong>config/routes.rb</strong> to use the new controller. Replace <code>devise_for :users</code> with:</p>
<pre>
devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
</pre>
<p>You’ve modified the routes file, so you must restart the server for any changes to take effect.</p>
<h3>Modify the Devise Registration Page</h3>
<p>We’ll use the Devise registration page as our subscription sign-up form.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong> to add details about the subscription plan:</p>
<pre>
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;%= simple_form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'form-vertical' }) do |f| %&gt;
  &lt;h3&gt;&lt;%= @plan.titleize if @plan %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'plan', @plan %&gt;
  &lt;%= f.error_notification %&gt;
  &lt;%= f.input :name, :autofocus =&gt; true %&gt; 
  &lt;%= f.input :email, :required =&gt; true %&gt;
  &lt;%= f.input :password, :required =&gt; true %&gt;
  &lt;%= f.input :password_confirmation, :required =&gt; true %&gt;
  &lt;%= f.button :submit, 'Sign up', :class =&gt; 'btn-primary' %&gt;
&lt;% end %&gt;
</pre>
<p>We display the name of the selected subscription plan. The <code>titleize</code> method transforms the <em>plan</em> string from lowercase to titlecase.</p>
<p>We add a hidden input field with <code>hidden_field_tag</code> to include a parameter identifying the selected subscription plan. The <em>plan</em> parameter is passed from the home page when the visitor clicks one of the “Subscribe” buttons and set as a variable by our Registrations controller.</p>
<p>We remove the <code>&lt;%= render "devise/shared/links" %&gt;</code> navigation links because we already have a login link in the page navigation bar.</p>
<p>When we submit the form, Rails does its form processing magic, including validation of the model attributes, and saves the new User record to the database.</p>
<h3>Test Registration</h3>
<p>You can check that registration works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in and submit the form. You’ll see a message “Welcome! You have signed up successfully.” Note that we’re not using the Devise Confirmable module so the application doesn’t send a confirmation email. You’ll be logged in as the new user as soon as you submit the form.</p>
<p>If you’ve selected the Silver Plan for the new user, try visiting <a href="http://localhost:3000/content/silver">http://localhost:3000/content/silver.html</a>. You should be able to view the page. You should see an error message if you attempt to visit  <a href="http://localhost:3000/content/gold">http://localhost:3000/content/gold.html</a>.</p>
<p>Now we have a registration page that assigns a subscription plan when a visitor signs up for the site. In the next step, we’ll make sure the user gets redirected to an appropriate page after sign up or log in.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add registration"
$ git checkout master
$ git merge --squash registration
$ git commit -m "add registration"
$ git branch -D registration
</pre>
<h2>Redirect After Sign Up or Log In</h2>
<p>As currently implemented, when a user signs up or logs in, they see the home page with a confirmation message. Instead, we want a user to be redirected to a page that is an appropriate hub for their role or subscription tier.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b redirect
</pre>
<h3>Modify the Application Controller</h3>
<p>Modify the file <strong>app/controllers/application_controller.rb</strong>:</p>
<pre>
class ApplicationController &lt; ActionController::Base
  protect_from_forgery

  rescue_from CanCan::AccessDenied do |exception|
    redirect_to root_path, :alert =&gt; exception.message
  end

  def after_sign_in_path_for(resource)
    case current_user.roles.first.name
      when 'admin'
        users_path
      when 'silver'
        content_silver_path
      when 'gold'
        content_gold_path
      when 'platinum'
        content_platinum_path
      else
        root_path
    end
  end
  
end
</pre>
<p>The <code>after_sign_in_path_for(resource)</code> method will redirect a user to an appropriate page after sign in or sign up. The <code>case</code> statement checks the user’s role and redirects to the appropriate content page, or if an administrator, to the administrative dashboard.</p>
<p>When we use Rolify, each user can have multiple roles. We only assign a single role in this application, so we ask for the first role associated with the user. When a role object is displayed as a string, it will be a number, so we ask for the name attribute of the role.</p>
<p>Devise also offers an <code>after_sign_up_path_for(resource)</code> method that allows a different redirect after a user registers. You could implement the <code>after_sign_up_path_for(resource)</code> method if you wanted the new user to see a special page after sign up (for example, a thank you or introduction).</p>
<h3>Test Redirect</h3>
<p>You can check that the redirect works by entering the command:</p>
<p><code>$ rails server</code></p>
<p>Visit <a href="http://localhost:3000">http://localhost:3000/</a> to see your home page.</p>
<p>Subscribe to any subscription plan. You should be redirected to the appropriate page and see a message “Welcome! You have signed up successfully.” Log out and log in. You should be redirected to the appropriate page.</p>
<p>In the next step, we’ll integrate Stripe payment for subscription plans.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "redirect after log in"
$ git checkout master
$ git merge --squash redirect
$ git commit -m "redirect after log in"
$ git branch -D redirect
</pre>
<h2>Stripe Integration</h2>
<p>We’ve got a fully functional web application that serves up placeholder content to registered users and restricts access based on the subscription plan the user has selected. Now we’ll integrate Stripe billing so we can charge users for subscriptions.</p>
<p>Remember we’re using our Devise registration page for subscription sign up. We’ll make this our payment page. We’ll ask the visitor to enter credit card data on this page.</p>
<p>Here’s the most obvious way to implement billing:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>data is received by your application on your server</li>
	<li>an application controller <code>create</code> action initiates a request to the payment processor</li>
	<li>the <code>create</code> method receives an acknowledgment of a completed or declined transaction</li>
	<li>the <code>create</code> method saves the user data (and creates an account) or shows an error message</li>
</ul><p>There’s a big drawback to this approach: Credit card data is sent to your server. Your server becomes a target for thieves and you must secure the server and maintain <a href="http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard"><span class="caps">PCI</span> compliance</a> (the credit card industry security standard).</p>
<p>Instead, Stripe offers an architecture that cuts risk and makes it much easier to meet <span class="caps">PCI</span> compliance requirements. Stripe provides a JavaScript file that we add to our payment page. We set a public key in the JavaScript code to identify our Stripe account. We trigger the JavaScript code when the user submits the payment form. The JavaScript code obtains the credit card data from our form, transmits the data to Stripe’s servers, and returns a unique token that serves as a substitute for the credit card data. Stripe takes responsibility for the security of the credit card data and it never touches our server. We can safely use  the Stripe token as a substitute for credit card data when we make a request to Stripe to bill the user.</p>
<p>Here is our preferred program flow:</p>
<ul>
<li>the visitor enters credit card data on a form</li>
	<li>the visitor submits the form</li>
	<li>a JavaScript function sends the card data to Stripe’s servers</li>
	<li>a JavaScript callback receives a Stripe token or an error message</li>
	<li>the JavaScript function submits the form to your server, substituting the token for credit card data</li>
	<li>an application controller <code>create</code> action sends a request (with the token) to Stripe to create a customer account</li>
	<li>the <code>create</code> method receives an acknowledgment of a completed or declined transaction</li>
	<li>the <code>create</code> method saves the user data (and creates an account) or shows an error message</li>
</ul><p>Stripe’s multi-step JavaScript-based approach makes implementation more complex but the result is robust and secure.</p>
<p>Here are useful resources for understanding the implementation:</p>
<ul>
<li>RailsCast <a href="http://railscasts.com/episodes/288-billing-with-stripe">Billing with Stripe</a>
</li>
	<li><a href="https://stripe.com/docs">Stripe documentation</a></li>
	<li>Stripe’s <a href="https://github.com/stripe/monospace-rails">monospace-rails</a> sample Rails application</li>
	<li><a href="http://net.tutsplus.com/tutorials/other/so-you-want-to-accept-credit-cards-online/">Nettuts: Stripe Tutorial</a></li>
</ul><p>We’ve followed Ryan Bates’s implementation from his RailsCast on Stripe in several key areas. Thank you, Ryan!</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b stripe
</pre>
<h3>Stripe Initializer</h3>
<p>We’ve already installed the Stripe gem in our Gemfile.</p>
<p>The Stripe gem requires an <span class="caps">API</span> key to operate. We’ll also need to supply a public key when we initiate a transaction. You can find both keys on the Stripe website when you visit your <a href="https://manage.stripe.com/#account/apikeys">Stripe account page</a>. We’ll use an initializer file to store the <span class="caps">API</span> and public key.</p>
<p>Create a file <strong>config/initializers/stripe.rb</strong>:</p>
<pre>
Stripe.api_key = ENV["STRIPE_API_KEY"]
STRIPE_PUBLIC_KEY = ENV["STRIPE_PUBLIC_KEY"]
</pre>
<p>Remember you’ll need to restart your server before testing because you’ve made a change to configuration files.</p>
<p>The <code>STRIPE_PUBLIC_KEY</code> is a constant we’ll use in the JavaScript code that initiates the Stripe transaction.</p>
<p>For security, don’t record sensitive information in your application code where it might be exposed publicly on a GitHub repo. Instead, set Unix environment variables in the file that is read when starting an interactive shell (the <strong>~/.bashrc</strong> file for the bash shell). This will keep the password out of your repository.</p>
<p>Add this to your <strong>~/.bashrc</strong> file (or the equivalent file for your preferred Unix shell):</p>
<pre>
export STRIPE_API_KEY="secret"
export STRIPE_PUBLIC_KEY="secret"
</pre>
<p>Replace “secret” with your keys. You can find both keys on your <a href="https://manage.stripe.com/#account/apikeys">Stripe account page</a>. Two sets of keys are available: one for testing, one for live transactions. Use the tesing keys on your development machine. When you deploy, use the live keys. If you plan to use Heroku for hosting, make a note for yourself to set up the Heroku environment variables after deployment.</p>
<p>Here’s how to set Heroku environment variables to provide the same data your application obtains from your local shell environment:</p>
<pre>
$ heroku config:add STRIPE_API_KEY=secret STRIPE_PUBLIC_KEY=secret
</pre>
<p>You can’t set Heroku environment variables now; you’ll do that after you deploy.</p>
<h3>Use Page-Specific JavaScript</h3>
<p>In most projects, we copy external JavaScript libraries (such as jQuery plugins) to the <strong>vendor/assets/javascripts</strong> folder and let the Rails asset pipeline combine all the JavaScript, making it available throughout the application. That’s not how we want to handle the Stripe JavaScript library. Only a small portion of our site’s visitors will use it (only those visiting the payment page). And we don’t want to store it in our application where a trespasser could modify it to intercept credit card data. It’s best to manage it as page-specific JavaScript, loaded only on the payment page.</p>
<p>For details about using external JavaScript libraries and page-specific JavaScript, see our article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Unholy Rails: External Scripts, jQuery Plugins, and Page-Specific JavaScript</a>.</p>
<h3>Create a Registrations JavaScript File</h3>
<p>We’ll create a new file for our page-specific JavaScript and give the file the same name as the controller. For now, we’ll only create some test code.</p>
<p>Create a file <strong>app/lib/javascripts/registrations.js.erb</strong>:</p>
<pre>
$(function() {
  if (typeof Stripe != 'undefined') {
    alert('Stripe JavaScript file loaded.');
  }
  else
  {
    alert('Problem: Stripe JavaScript file not loaded.');
  }
});
</pre>
<p>This code will test if the Stripe JavaScript library has been successfully downloaded.</p>
<p>Later we will add the code that collects the credit card data from the subscription form, submits it to the Stripe server, and obtains the Stripe token.</p>
<p>We add the <strong>.erb</strong> file extension because we will want to use a Ruby constant in our code before the file is compiled into JavaScript.</p>
<h3>Configuration for Precompiling in Production</h3>
<p>Notice that we don’t add the file to the <em><strong>app</strong>/assets/javascripts/</em> folder. We add it to the <em><strong>lib</strong>/assets/javascripts/</em> folder. Our article <a href="http://railsapps.github.com/rails-javascript-include-external.html">Unholy Rails: External Scripts, jQuery Plugins, and Page-Specific JavaScript</a> explains that selecting the  <em>lib/assets/javascripts/</em> folder means we can continue to use our <em>app/assets/javascripts/</em> folder for site-wide scripts without configuration changes.</p>
<p>In development mode, nothing more is required to use our new <em>registrations.js</em> script on any page where it is needed. The asset pipeline “live compiles” all the JavaScript files it finds and makes them available for use.</p>
<p>For production, we must make an important configuration change so our new script is precompiled and available on deployment. Change the configuration now; don’t wait until it’s time to deploy.</p>
<p>Add this to the file <strong>config/environments/production.rb</strong>:</p>
<pre>
config.assets.precompile += %w( registrations.js )
</pre>
<p>We don’t need to include the <strong>.erb</strong> file extension.</p>
<p>When you precompile assets in production mode, the Rails asset pipeline will automatically process the <strong>app/assets/javascripts/application.js</strong> file and any additional files listed in its manifest to produce a concatenated and minified site-wide <em>application.js</em> script.</p>
<p>Any other scripts that you wish to use on a page in addition to the site-wide <em>application.js</em> script must be specified by the <code>config.assets.precompile</code> statement or else they will not be precompiled and made available.</p>
<p>If you don’t make this configuration change, you won’t see the error until your application is deployed in production.</p>
<h3>Add Page-Specific JavaScript</h3>
<p>To use Stripe on our payment page we need to obtain a JavaScript file from Stripe’s server. We’ll also need to include our custom <em>registrations.js</em> script.</p>
<p>Take a look at the application layout file <strong>app/views/layouts/application.html.erb</strong>:</p>
<pre>
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;
  &lt;title&gt;&lt;%= content_for?(:title) ? yield(:title) : "Rails Membership Subscription Saas" %&gt;&lt;/title&gt;
  &lt;meta name="description" content="&lt;%= content_for?(:description) ? yield(:description) : "..." %&gt;"&gt;
  &lt;%= stylesheet_link_tag "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  &lt;%= csrf_meta_tags %&gt;
  &lt;%= yield(:head) %&gt;
&lt;/head&gt;
</pre>
<p>The <code>&lt;%= yield(:head) %&gt;</code> statement makes it easy to add page-specific JavaScript files. The element is positioned to load scripts following our <em>application.js</em> script which loads jQuery and any application-wide JavaScript code.</p>
<p>We can use <code>content_for :head</code> in our view file to load our page-specific JavaScript code.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;
  &lt;%= javascript_include_tag 'registrations' %&gt;
&lt;% end %&gt;
&lt;h2&gt;Sign up&lt;/h2&gt;

&lt;%= form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name)) do |f| %&gt;

  &lt;h3&gt;&lt;%= @plan.humanize if @plan %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'user[role_ids][]', @user.role_ids %&gt;

  &lt;%= devise_error_messages! %&gt;
  &lt;p&gt;&lt;%= f.label :name %&gt;
  &lt;%= f.text_field :name %&gt;&lt;/p&gt;

  &lt;div&gt;&lt;%= f.label :email %&gt;
  &lt;%= f.email_field :email %&gt;&lt;/div&gt;

  &lt;div&gt;&lt;%= f.label :password %&gt;
  &lt;%= f.password_field :password %&gt;&lt;/div&gt;

  &lt;div&gt;&lt;%= f.label :password_confirmation %&gt;
  &lt;%= f.password_field :password_confirmation %&gt;&lt;/div&gt;

  &lt;div&gt;&lt;%= f.submit "Sign up" %&gt;&lt;/div&gt;
&lt;% end %&gt;
</pre>
<p>The <code>content_for :head</code> block will pass <code>&lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;</code> to the <code>&lt;head&gt;</code> section of the application layout. This will load Stripe’s JavaScript file via a secure connection when the payment page is rendered in the browser. After that, our <em>registrations.js</em> script will load.</p>
<p>You can verify it by starting the server and viewing the page source. You should see something similar to this:</p>
<pre>
&lt;head&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt;
  &lt;title&gt;Rails Membership Subscription Saas&lt;/title&gt;
  &lt;meta name="description" content="..."&gt;
  &lt;link href="/assets/application.css" media="all" rel="stylesheet" type="text/css" /&gt;
  &lt;script src="/assets/application.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;meta content="authenticity_token" name="csrf-param" /&gt;
  &lt;meta content="..." name="csrf-token" /&gt;
  &lt;script src="https://js.stripe.com/v1/" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="/assets/registrations.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
<p>Start the server and visit the page. You should see an alert indicating the Stripe JavaScript file loaded without a problem.</p>
<p>With the Stripe JavaScript file in place, we will add a virtual attribute to the User model.</p>
<h3>Add a Virtual Attribute to the User Model</h3>
<p>When a new user signs up for a subscription, we’ll use JavaScript on the registration page to submit credit card data to Stripe and obtain a Stripe token that substitutes for credit card data. The Stripe token will included as a hidden field when the user submits the registration form.</p>
<p>Before we can include a hidden field in the form, we must modify the User model to accept this field as a virtual attribute. It doesn’t need to be added to the User database schema as it will only be used when the form is processed by the Registrations controller. For more on virtual attributes, see the RailsCast <a href="http://railscasts.com/episodes/16-virtual-attributes-revised">Virtual Attributes</a>.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :role_ids, :stripe_token
  attr_accessor :stripe_token

end
</pre>
<p>We add the virtual attribute with <code>attr_accessor</code> which will automatically create getter and setter methods and store the value in an instance variable. Also we add the new <code>:stripe_token</code> field to the <code>attr_accessible</code> list so that it can be set through mass-assignment.</p>
<p>With the virtual attribute in place, we will add fields for credit card data to the form.</p>
<h3>Add Credit Card Data to the Registration Form</h3>
<p>We’ll need fields for a credit card number, security code, and expiration date.</p>
<p>We’ll also add a placeholder <code>div</code> for any error messages returned by the Stripe server.</p>
<p>Modify the file <strong>app/views/devise/registrations/new.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;
  &lt;%= javascript_include_tag 'registrations' %&gt;
&lt;% end %&gt;
&lt;h2&gt;Sign up&lt;/h2&gt;
&lt;div id="stripe_error" class="alert alert-error" style="display:none" &gt;
&lt;/div&gt;
&lt;%= form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; {:class =&gt; 'card_form'}) do |f| %&gt;
  &lt;h3&gt;&lt;%= @plan.humanize if @plan %&gt; Subscription Plan&lt;/h3&gt;
  &lt;%= hidden_field_tag 'user[role_ids][]', @user.role_ids %&gt;
  &lt;%= devise_error_messages! %&gt;
  &lt;p&gt;&lt;%= f.label :name %&gt;
  &lt;%= f.text_field :name %&gt;&lt;/p&gt;
  &lt;div&gt;&lt;%= f.label :email %&gt;
  &lt;%= f.email_field :email %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.label :password %&gt;
  &lt;%= f.password_field :password %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.label :password_confirmation %&gt;
  &lt;%= f.password_field :password_confirmation %&gt;&lt;/div&gt; 
  &lt;% if @user.stripe_token %&gt;
    Credit card has been accepted.
  &lt;% else %&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
      &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
      &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
    &lt;/div&gt;
    &lt;div class="field"&gt;
      &lt;%= label_tag :card_month, "Card Expiration" %&gt;
      &lt;%= select_month nil, {add_month_numbers_true: true}, {name: nil, id: "card_month"}%&gt;
      &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  &lt;%= f.hidden_field :stripe_token %&gt;
  &lt;div&gt;&lt;%= f.submit "Sign up" %&gt;&lt;/div&gt;
&lt;% end %&gt;
</pre>
<p>Take a look at <code>div id="stripe_error"</code>. We give it the “alert alert-error” style from Twitter Bootstrap. It remains hidden with a <code>style="display:none"</code> unless we use JavaScript to show it when we receive an error message from the Stripe server. We’ll add the necessary JavaScript soon.</p>
<p>If you examine the <span class="caps">HTML</span> source, you will see:</p>
<pre>
&lt;form accept-charset="UTF-8" action="/users" class="card_form" id="new_user" method="post"&gt;
</pre>
<p>The Rails form builder creates a form with the id <code>new_user</code>. The id is generated automatically from the controller and action names “user” and “new”. We assign the class <code>card_form</code> to the form. Our JavaScript code will interact with the form. We could select the form with the “new_user” id but instead we’ll use the “card_form” class in our jQuery selector. This gives us flexibility to use the same JavaScript code to interact with either a “new registration” or “edit registration” form.</p>
<p>Notice the differences between the credit card data fields and the previous data fields.</p>
<p>The name, email, and password fields correspond to attributes of the User model. We use the Rails form builder object (the <em>f</em> variable) to bind the form to the User model. Methods such as <code>f.text_field</code> create form controls using the form builder object which automatically populate the attributes of the User model.</p>
<p>The credit card data fields do not correspond to attributes of the User model so we can’t use the form builder object. We use the more primitive <code>label_tag</code> and <code>text_field_tag</code> instead. Notice we specify the <code>name:</code> of the element as nil. For the expiration <code>select_month</code> and <code>select_year</code> we also set an element ID to replace the ID that the Rails form helper generates. Thus the fields will be available to our JavaScript code but will not be submitted to the server.</p>
<p>We add a hidden field to the form named <code>stripe_token</code>. We’ll soon add JavaScript to submit credit card data from the form and obtain a Stripe token from the Stripe server. The JavaScript code will add the Stripe token to the hidden field before submitting the form to our server.</p>
<p>We’ve added fields for credit card data but we’ve made inclusion of the fields conditional on the absence of the <code>@user.stripe_token</code> attribute. This accommodates a situation where correct credit card data is provided but the form fails to pass a validation test (such as a blank email address). If Stripe accepts the credit card data and provides a <code>stripe_token</code> but there’s no email address, we’ll save the Stripe token in the hidden field and prompt the user to correct the email address.</p>
<h3>Add JavaScript for Form Processing</h3>
<p>We need code that runs in the browser to submit the credit card data to Stripe and obtain a Stripe token before the form is sent to our server.</p>
<p>Replace the contents of <strong>lib/assets/javascripts/registrations.js.erb</strong> with this:</p>
<pre>
$(function() {
  if (typeof Stripe != 'undefined') {
    console.log('Stripe JavaScript file loaded.');
  }
  else
  {
    console.log('Problem: Stripe JavaScript file not loaded.');
  }
  Stripe.setPublishableKey('&lt;%= STRIPE_PUBLIC_KEY %&gt;');
  console.log('set Stripe public key: &lt;%= STRIPE_PUBLIC_KEY %&gt;');
  var subscription = {
    setupForm: function() {
      console.log('function: setupForm')
      return $('.card_form').submit(function() {
        console.log('setupForm: form submitted')
        $('input[type=submit]').prop('disabled', true);
        subscription.processCard();
        return false;
      });
    },
    processCard: function() {
      console.log('function: processCard');
      var card;
      card = {
        name: $('#user_name').val(),
        number: $('#card_number').val(),
        cvc: $('#card_code').val(),
        expMonth: $('#card_month').val(),
        expYear: $('#card_year').val()
      };
      return Stripe.createToken(card, subscription.handleStripeResponse);
    },
    handleStripeResponse: function(status, response) {
      console.log('function: handleStripeResponse');
      if (status === 200) {
        return alert('Stripe response: ' + response.id);
      } else {
        return alert('Stripe response: ' + response.error.message);
      }
    }
  };
  return subscription.setupForm();
});
</pre>
<p>If you prefer CoffeeScript, you can convert JavaScript to CoffeeScript <a href="http://js2coffee.org/">here</a> or <a href="http://js2cs.nodejitsu.com/">here</a>.</p>
<p>Instead of using a JavaScript alert to confirm that Stripe JavaScript file loaded properly, we write a message to the JavaScript console.</p>
<p>Here’s how to use the JavaScript console. Every web browser provides access to the JavaScript console for debugging. In Chrome, choose the menu item <strong>View/Developer/Developer Tools</strong> and select the “Console” tab. Reload the page and you will the console messages. We’ve added console messages to trace the program flow as each function is executed. You can use the console messages for debugging if you have problems.</p>
<p>We read the Ruby constant STRIPE_PUBLIC_KEY before the file is compiled into JavaScript (that’s why we used the <strong>.erb</strong> file extension when we created the file).</p>
<p>Finally, we raise an alert displaying the response we get from the Stripe server.</p>
<p>Start the server and visit the page. Check the JavaScript console to observe the debugging messages. Fill out the form, using a fake credit card number. You should see an alert displaying the response from the Stripe server.</p>
<p>Stripe provides a set of fake credit card numbers which will force various responses. See the <a href="https://stripe.com/docs/testing">Stripe Testing</a> documentation. Here are some useful numbers:</p>
<ul>
<li>a fake Visa card: <em>4242424242424242</em>
</li>
	<li>incorrect number: use a number that fails the checksum, e.g. <em>4242424242424241</em>
</li>
	<li>invalid expiry month: use an invalid month, e.g. <em>13</em>
</li>
	<li>invalid expiry year: use a year in the past, e.g. <em>1970</em>
</li>
	<li>invalid cvc: use a two digit number, e.g. <em>99</em>
</li>
</ul><p>It’s fun (for a few minutes) to enter various numbers and observe the response from the Stripe server.</p>
<p>Now that you’ve confirmed you can send credit card data to the Stripe server, remove the debugging code from the script. While we’re at it, we’ll add the code to handle the response from the Stripe server.</p>
<p>Replace the contents of <strong>lib/assets/javascripts/registrations.js.erb</strong> with this:</p>
<pre>
$(function() {
  Stripe.setPublishableKey('&lt;%= STRIPE_PUBLIC_KEY %&gt;');
  var subscription = {
    setupForm: function() {
      return $('.card_form').submit(function() {
        $('input[type=submit]').prop('disabled', true);
        if ($('#card_number').length) {
          subscription.processCard();
          return false;
        } else {
          return true;
        }
      });
    },
    processCard: function() {
      var card;
      card = {
        name: $('#user_name').val(),
        number: $('#card_number').val(),
        cvc: $('#card_code').val(),
        expMonth: $('#card_month').val(),
        expYear: $('#card_year').val()
      };
      return Stripe.createToken(card, subscription.handleStripeResponse);
    },
    handleStripeResponse: function(status, response) {
      if (status === 200) {
        $('#user_stripe_token').val(response.id)
        $('.card_form')[0].submit()
      } else {
        $('#stripe_error').text(response.error.message).show();
        return $('input[type=submit]').prop('disabled', false);
      }
    }
  };
  return subscription.setupForm();
});
</pre>
<p>Here’s an explanation of the JavaScript.</p>
<p>The <code>$(function()</code> function is an alias for the <a href="http://api.jquery.com/jQuery/#jQuery3">jQuery object</a>. Nothing inside the jQuery object will execute until the <span class="caps">DOM</span> is ready.</p>
<p>We set the <code>STRIPE_PUBLIC_KEY</code> which is defined in the Stripe initializer file <strong>config/initializers/stripe.rb</strong>.</p>
<p>We create a <code>subscription</code> object with several functions: <code>setupForm</code>, <code>processCard</code>, and <code>handleStripeResponse</code>.</p>
<p>We call the <code>setupForm</code> function which listens for the form submission event. When the visitor submits the form, the submit button is disabled (so the user can’t press it repeatedly) and the <code>processCard</code> function is called. Returning <code>false</code> makes sure the form is not submitted to our server at this stage. Notice that we don’t call the <code>processCard</code> function if the credit card number is blank; instead we return “true” which submits the form. This will be true if the credit card data was previously accepted (and a Stripe token is included in the hidden field) but there was an error such as a missing email address.</p>
<p>The <code>processCard</code> function parses the form and obtains the credit card data. Then it calls a function from the Stripe library named <code>createToken</code> which submits the card data to the Stripe server. When the Stripe server returns a response, we call the <code>handleStripeResponse</code> function.</p>
<p>The <code>handleStripeResponse</code> function checks the <span class="caps">HTTP</span> status code. If it is okay (status code 200), the function sets the <code>:stripe_token</code> hidden field in the form (it has the <span class="caps">HTML</span> element ID “user_stripe_token”) and calls <code>submit</code> on the element with the “card_form” class (which is the form). If the <span class="caps">HTTP</span> status code is not okay, the function sets the error message from the Stripe server in the <code>stripe_error</code> div and re-enables the submit button.</p>
<p>In effect, we modify the form’s submit button so that the credit card data is first sent to the Striper server, the Stripe token is obtained and set in a hidden field, and then the form is submitted to our application for processing by our Registrations controller.</p>
<p>You can start the server and create a subscription. Use the fake credit card number <em>4242424242424242</em>. You’ll see an error message on the page if the credit card data is incomplete. If the credit card data is accepted, a new User account will be created and you’ll be redirected to the application home page where you’ll see a message “Welcome! You have signed up successfully.”</p>
<p>But wait. We’ve created a new User account but we haven’t charged the user for the subscription. To do so, we’ll modify the User model to create a new Stripe customer and initiate a credit card transaction when a new user is created.</p>
<h3>Prepare Your Stripe Account</h3>
<p>Before we can modify the User model to create a new Stripe customer, we have to prepare our Stripe account to recognize the parameters we’ll be saving. We have to set up our subscription plans in Stripe.</p>
<p>This step is necessary if you’re going to use Stripe to automatically handle recurring billing. We’ll tell Stripe that we have three plans named “Silver”, “Gold”, and “Platinum” that will be billed monthly at rates of $9, $19, and $29. Once a customer is created and assigned a plan, Stripe will do all the work of notifying the user, initiating monthly billing, and contacting the user when a credit card is declined or expires.</p>
<p>Go to the Stripe <a href="https://manage.stripe.com/#plans">plan management page</a> to create a subscription plan. Stripe offers <a href="https://stripe.com/docs/subscriptions">documentation about creating a plan</a> and <a href="https://stripe.com/docs/api#plans">additional detail about plans</a>.</p>
<p>Look for the toggle switch “Live/Test” and set it to “Test.” Click the button to “Create your first plan.”</p>
<p>Create three different plans with the following values:</p>
<table>
<tr>
<th>ID </th>
		<th>Name </th>
		<th>Amount </th>
		<th>Interval </th>
	</tr>
<tr>
<td> silver </td>
		<td> Silver </td>
		<td> 9.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> gold </td>
		<td> Gold </td>
		<td> 19.00 </td>
		<td> monthly </td>
	</tr>
<tr>
<td> platinum </td>
		<td> Platinum </td>
		<td> 29.00 </td>
		<td> monthly </td>
	</tr>
</table><p>“ID” is a unique string of your choice that is used to identify the plan when subscribing a customer. In our application, each plan should have an ID that corresponds to the roles we’ve created to manage access using CanCan. “Name” is displayed on invoices and in the Stripe web interface. “Amount” is the subscription price in US dollars. “Interval” is the billing frequency. Optionally, you can specify a trial period (in days). If you include a trial period, the customer won’t be billed for the first time until the trial period ends. If the customer cancels before the trial period is over, she’ll never be billed at all.</p>
<p>Now that Stripe knows about our subscription plans, we’ll modify the User model to create a new Stripe customer.</p>
<h3>Migration for the User Model</h3>
<p>We will need two extra fields in the database to accommodate Stripe:</p>
<ul>
<li>
<code>stripe_id</code> will store the Stripe customer ID</li>
	<li>
<code>last_4_digits</code> will store the last four digits of the user’s credit card number</li>
</ul><p>The <code>last_4_digits</code> field isn’t needed for integration with Stripe but we can use it to show the user which credit card was used for the subscription.</p>
<p>Create a database migration with this command:</p>
<pre>
$ rails generate migration AddStripeToUsers stripe_id:string last_4_digits:string
</pre>
<p>After you’ve created the migration, update the database:</p>
<pre>
$ rake db:migrate
</pre>
<p>Now we’ll modify the User model.</p>
<h3>Modify the User Model</h3>
<p>We want to make a request to Stripe to create a customer whenever a new user is created. There are several ways we could do this:</p>
<ul>
<li>modify the Registrations controller <code>create</code> action to initiate a request to Stripe</li>
	<li>add a new method such as <code>save_new_customer</code> to the User model and swap it for <code>save</code> method used in the Registrations controller <code>create</code> action</li>
	<li>add a <code>save_new_customer</code> method to the User model and call it with <code>before_create</code> in the User model</li>
	<li>add an <code>update_stripe</code> method to the User model and call it with <code>before_save</code> in the User model</li>
</ul><p>The first option, modifying the Registrations controller, results in the much-abhorred “fat controller” anti-pattern. We’ll avoid that. The second option moves the Stripe request to the model but there is no need to modify the Registrations controller to use an alternative to the <code>save</code> method. The third option requires no changes to the Registrations controller but only contacts Stripe when a new user is created. The fourth option is optimal. We’ll add an <code>update_stripe</code> method that is called whenever the user instance is saved. This approach allows us to either create a new Stripe customer on <code>create</code> or update the Stripe customer record on <code>update</code>.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :role_ids, :stripe_token
  attr_accessor :stripe_token
  before_save :update_stripe

  def update_stripe
    return if email.include?('@example.com')
    if stripe_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      customer = Stripe::Customer.create(
        :email =&gt; email,
        :description =&gt; name,
        :card =&gt; stripe_token,
        :plan =&gt; roles.first.name
      )
    else
      customer = Stripe::Customer.retrieve(stripe_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.stripe_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    stripe_token = nil
    false
  end
  
end
</pre>
<p>We add <code>before_save :update_stripe</code> to call the <code>update_stripe</code> method when the user is saved or updated.</p>
<p>The <code>before_save</code> callback is carried out after validation so there will be no attempt to create a Stripe customer if an email address is missing or if there are other validation errors.</p>
<p>The <code>update_stripe</code> method makes our request to the Stripe service. We skip the process if the email address includes “example.com”. This allows us to run <code>rake db:seed</code> or <code>rake db:reset</code> to set up our administrative user and default sample accounts for this tutorial. You should remove the statement <code>return if email.include?('example.com')</code> and modify the <strong>db/seeds.rb</strong> before deploying the application or your application will allow any visitor to create a free account by using an “example.com” email address.</p>
<p>The <code>update_stripe</code> method checks if the user instance already has a <code>stripe_id</code>. If it does not, and a <code>stripe_token</code> is present, we can create a new Stripe customer. We make a request using the Stripe <span class="caps">API</span> call <code>Stripe::Customer.create</code> and provide the customer’s email address and name. We don’t transmit any credit card data. Stripe already has the credit card data keyed to the stripe token; we transmit the token instead of providing credit card data. Stripe also needs to know what subscription plan the user wants. We’re using Rolify roles to designate subscription plans so we retrieve the role name and use it to designate the subscription plan.</p>
<p>If <code>stripe_id</code> is already available as an attribute of the user instance, we know that we’re updating a record rather than creating a new customer. We use the Stripe <span class="caps">API</span> call <code>Stripe::Customer.retrieve(stripe_id)</code> to obtain a customer object and then reset the email address and name. If a <code>stripe_token</code> is present, we tell Stripe to use a new credit card. We’ll implement this function when we modify the application’s “Edit Account” feature.</p>
<p>After create or update, we obtain the last four digits of the user’s credit card number. We finish by setting the <code>stripe_id</code> to match the Stripe customer ID and we set the stripe token to nil.</p>
<p>The <code>update_stripe</code> method sets user attributes <code>stripe_id</code> and <code>last_4_digits</code> which are saved with the attributes passed from the form when the Registration controller completes the <code>user.save</code> call.</p>
<p>We handle errors with a <code>rescue</code> condition. Errors in credit card data will be caught by the JavaScript functions before the form is submitted to the server. If another type of error prevents the Stripe customer from being created, the <code>rescue</code> condition will set an error message and return false which will prevent the user account from being saved.</p>
<h3>Test Stripe Integration</h3>
<p>We have all the code needed for visitors to sign up for new subscriptions. Let’s test the application.</p>
<p>Start the web server:</p>
<pre>
$ rails server
</pre>
<p>Visit <a href="http://localhost:3000/">http://localhost:3000/</a> to see your home page.</p>
<p>Click on the “Subscribe” button for any subscription plan. You’ll see the registration page. Fill in the form using the fake credit card number <em>4242424242424242</em>. Submit the form.</p>
<p>You’ll be redirected to an appropriate page and see a message “Welcome! You have signed up successfully.” You’ll be logged in as a new user. If you’ve selected the Silver Plan for the new user, you should be on the page  <a href="http://localhost:3000/content/silver.html">http://localhost:3000/content/silver.html</a>. You should see an error message if you attempt to visit <a href="http://localhost:3000/content/gold.html">http://localhost:3000/content/gold.html</a>.</p>
<p>Visit your Stripe dashboard at <a href="https://manage.stripe.com/#test/customers">https://manage.stripe.com/#test/customers</a> and see the new customer you’ve created. If you check the customer details, you should see that the fake credit card was billed and the subscription status is “active.”</p>
<p>Pat yourself on the back! You’ve reached a milestone. You now can take credit card payments for subscriptions.</p>
<p>There’s more to do, however:</p>
<ul>
<li>modify “edit account” so users can change credit cards, change plans, and unsubscribe</li>
	<li>implement Stripe “webhooks” so expired subscribers will be denied access to the site</li>
</ul><p>Let’s update our Git repository before we continue.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add stripe"
$ git checkout master
$ git merge --squash stripe
$ git commit -m "add stripe"
$ git branch -D stripe
</pre>
<h2>Account Changes</h2>
<p>We’ve completed integration with Stripe so we can sign up new subscribers. Stripe will automatically bill their credit cards every month. But what happens when a subscriber wants to use a different credit card for payments? We could require them to cancel their subscription and create a new one. It would be better if they could edit their account to change their credit card.</p>
<p>We’ll also make it easy for a subscriber to upgrade or downgrade a subscription plan and cancel a subscription.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b change-acct
</pre>
<h3>Change the Registration Form</h3>
<p>Our “Edit account” page is very similar to the registration page. In its rudimentary form, it contains a simple form to change the user’s name, email address, or password. We will add two additional forms that are hidden on the page and are revealed as modal windows when a “Change plan” or “Change card” button is clicked.</p>
<p>We’ve got a lot of code to add, so we’ll do it in stages.</p>
<p>Add the code to the file <strong>app/views/devise/registrations/edit.html.erb</strong>.</p>
<p>First, let’s include the Stripe JavaScript library and our <em>registrations.js</em> script.</p>
<p>Replace the line <code>&lt;h2&gt;Edit &lt;%= resource_name.to_s.humanize %&gt;&lt;/h2&gt;</code> with this:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;
  &lt;%= javascript_include_tag 'registrations' %&gt;
&lt;% end %&gt;
&lt;h2&gt;Account&lt;/h2&gt;
</pre>
<p>This identical to the code we added to the <strong>app/views/devise/registrations/new.html.erb</strong> file.</p>
<p>There’s no need to replace the existing form. It’s useful for changing the user’s name, email address, or password.</p>
<p>Add this code before the <code>&lt;h3&gt;Cancel my account&lt;/h3&gt;</code> statement:</p>
<pre>
&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Using card ending with &lt;%= @user.last_4_digits %&gt;
  &lt;a data-toggle="modal" href="#card-data" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;
</pre>
<p>We display the name of the current subscription plan, which is derived from the roles object associated with the user. Rolify lets us set multiple roles (a feature we will not use in this application). We pick the first role (the only role), obtain its name, and “titleize” it to display it in titlecase. We add a link that is styled as a Twitter button. The link will open a Twitter Bootstrap modal window labeled “plan-options”, which we will add soon.</p>
<p>We do something similar for the credit card. We show the last four digits of the card that was used to purchase the subscription. Then we add a link that will open a Twitter Bootstrap modal window labeled “card-data”. The link will be styled as a miniature button.</p>
<p>For stylistic consistency, replace this statement with the following:</p>
<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete %&gt;.&lt;/p&gt;
</pre>

<pre>
&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;
</pre>
<p>We’ve added a Twitter Bootstrap class that styles the link as a miniature button.</p>
<p>Now we’ll add the first of two modal windows containing a form. It doesn’t matter where the forms are placed in the file as they will be hidden when the page is initially displayed and will appear as an overlay when revealed by a click on the appropriate link.</p>
<p>The first form is identifed as “plan-options”:</p>
<pre>
&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name) , :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
      &lt;div&gt;&lt;%= f.label :current_password %&gt; &lt;i&gt;(we need your current password to confirm your changes)&lt;/i&gt;&lt;br /&gt;
      &lt;%= f.password_field :current_password %&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn.btn-success" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>We include this form in a div designated with the Twitter Bootstrap “modal” class. It will be displayed as an overlay when the user clicks the “Change plan” button.</p>
<p>We’re using helper methods provided by the <a href="http://simple-form.plataformatec.com.br/">simple_form gem</a>. It looks as if we <a href="http://guides.rubyonrails.org/form_helpers.html#binding-a-form-to-an-object">bind the form to an object</a> named “resource”; in fact, we bind the form to the User object. Devise abstracts the User object and names it “resource” which makes it possible to use objects with other names (such as Account or Member) in similar implementations. “Binding the form to the object” means the values for the form fields will be set with the attributes stored in the database.</p>
<p>The form has a section named “modal-header” that contains a link to close the modal window. We follow Twitter Bootstrap’s example and use <span class="caps">HTML</span> entity #215 (an “x” character) for the link.</p>
<p>The next section is named “modal-body” and it contains some of the most complex code we’ll use in this application.</p>
<p>We want to display a set of radio buttons that display a collection of all the subscription plans and, when selected, set a role id. A user’s subscription plan is encoded as a role id. Role ids are nested attributes of a User object and can be set as <code>user.role_ids</code>. So <code>:role_ids</code> is the first parameter we pass to the input field helper.</p>
<p>The input field helper wants a collection as the second parameter. We supply <code>Role.all</code> but we have to massage the list to remove the “admin” role. The Hash <code>delete_if</code> method is useful here. The block we supply to the <br><code>delete_if</code> method removes any role named “admin”.</p>
<p>We tell the input field helper we want to display the selection field as radio buttons. The <code>:item_wrapper_class =&gt; 'inline'</code> will display the radio buttons and labels horizontally.</p>
<p>The simple_form <code>label_method</code> parameter allows us to set a label for each radio button. If we didn’t set the <code>label_method</code>, the radio buttons would be labeled with an integer. We need to obtain the name attribute of each role and then apply the <code>titleize</code> method to display titlecase. The <code>label_method</code> parameter does not take a block but we can use a programming construct called an anonymous function (a Ruby language “lambda”) to manipulate the Role instance, obtaining the name attribute and making it titlecase, before passing it to the <code>label_method</code> parameter. This is a bit of advanced Ruby magic that is particularly useful here.</p>
<p>Confusingly, we set the <code>label</code> parameter to false. If we didn’t do this, the entire field would be automatically labelled “Roles.”</p>
<p>Finally, the form has a section named “modal-footer” that contains a submit button and another link to close the modal window.</p>
<p>Here’s the complete version of the file <strong>app/views/devise/registrations/edit.html.erb</strong>:</p>
<pre>
&lt;% content_for :head do %&gt;
  &lt;%= javascript_include_tag 'https://js.stripe.com/v1/' %&gt;
  &lt;%= javascript_include_tag 'registrations' %&gt;
&lt;% end %&gt;
&lt;h2&gt;Account&lt;/h2&gt;

&lt;%= form_for(resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name), :html =&gt; { :method =&gt; :put }) do |f| %&gt;
  &lt;%= devise_error_messages! %&gt;
  &lt;p&gt;&lt;%= f.label :name %&gt;
  &lt;%= f.text_field :name %&gt;&lt;/p&gt;
  &lt;div&gt;&lt;%= f.label :email %&gt;
  &lt;%= f.email_field :email %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.label :password %&gt; &lt;i&gt;(leave blank if you don't want to change it)&lt;/i&gt;&lt;br /&gt;
  &lt;%= f.password_field :password, :autocomplete =&gt; "off" %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.label :password_confirmation %&gt;
  &lt;%= f.password_field :password_confirmation %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.label :current_password %&gt; &lt;i&gt;(we need your current password to confirm your changes)&lt;/i&gt;&lt;br /&gt;
  &lt;%= f.password_field :current_password %&gt;&lt;/div&gt;
  &lt;div&gt;&lt;%= f.submit "Update" %&gt;&lt;/div&gt;
&lt;% end %&gt;

&lt;h3&gt;Subscription Plan&lt;/h3&gt;
&lt;p&gt;
  &lt;%= @user.roles.first.name.titleize %&gt;
  &lt;a data-toggle="modal" href="#plan-options" class="btn btn-mini" type="button"&gt;Change plan&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Card&lt;/h3&gt;
&lt;p&gt;
  Using card ending with &lt;%= @user.last_4_digits %&gt;
  &lt;a data-toggle="modal" href="#card-data" class="btn btn-mini" type="button"&gt;Change card&lt;/a&gt;
&lt;/p&gt;

&lt;h3&gt;Cancel my account&lt;/h3&gt;

&lt;p&gt;Unhappy? &lt;%= link_to "Cancel my account", registration_path(resource_name), :data =&gt; { :confirm =&gt; "Are you sure?" }, :method =&gt; :delete, :class =&gt; 'btn btn-mini' %&gt;&lt;/p&gt;

&lt;div id="plan-options" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name) , :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Plan&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;%= f.input :role_ids, :collection =&gt; Role.all.delete_if {|i| i.name == 'admin'}, :as =&gt; :radio_buttons, :label_method =&gt; lambda {|t| t.name.titleize}, :label =&gt; false, :item_wrapper_class =&gt; 'inline' %&gt;
      &lt;div&gt;&lt;%= f.label :current_password %&gt; &lt;i&gt;(we need your current password to confirm your changes)&lt;/i&gt;&lt;br /&gt;
      &lt;%= f.password_field :current_password %&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Plan", :class =&gt; "btn.btn-success" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;

&lt;div id="card-data" class="modal" style="display: none;"&gt;
  &lt;%= simple_form_for resource, :as =&gt; resource_name, :url =&gt; registration_path(resource_name) , :html =&gt; {:method =&gt; :put, :class =&gt; 'form-horizontal card_form' } do |f| %&gt;
    &lt;div class="modal-header"&gt;
      &lt;a class="close" data-dismiss="modal"&gt;&amp;#215;&lt;/a&gt;
      &lt;h3&gt;Change Credit Card&lt;/h3&gt;
    &lt;/div&gt;
    &lt;div class="modal-body"&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_number, "Credit Card Number" %&gt;
        &lt;%= text_field_tag :card_number, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_code, "Card Security Code (CVV)" %&gt;
        &lt;%= text_field_tag :card_code, nil, name: nil %&gt;
      &lt;/div&gt;
      &lt;div class="field"&gt;
        &lt;%= label_tag :card_month, "Card Expiration" %&gt;
        &lt;%= select_month nil, {add_month_numbers_true: true}, {name: nil, id: "card_month"}%&gt;
        &lt;%= select_year nil, {start_year: Date.today.year, end_year: Date.today.year+10}, {name: nil, id: "card_year"}%&gt;
      &lt;/div&gt;
      &lt;div&gt;&lt;%= f.label :current_password %&gt; &lt;i&gt;(we need your current password to confirm your changes)&lt;/i&gt;&lt;br /&gt;
      &lt;%= f.password_field :current_password %&gt;&lt;/div&gt;
      &lt;%= f.hidden_field :name %&gt;
      &lt;%= f.hidden_field :email %&gt;
      &lt;%= f.hidden_field :stripe_token %&gt;
    &lt;/div&gt;
    &lt;div class="modal-footer"&gt;
      &lt;%= f.submit "Change Credit Card", :class =&gt; "btn.btn-success" %&gt;
      &lt;a class="btn" data-dismiss="modal" href="#"&gt;Close&lt;/a&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/div&gt;
</pre>
<p>There’s a lot of new code in the Devise user edit view but we don’t need to change the Devise registrations controller. We already accommodate the “Change card” and “Change plan” features with the <code>update_stripe</code> method that is called by a <code>before_save</code> callback in the User class.</p>
<p>The “Cancel my account” feature is not complete, however. The Devise registrations controller will delete the user’s account but we also need to send a request to Stripe to de-activate monthly billing for the customer.</p>
<h3>Modify the User Model for Subscription Cancellations</h3>
<p>It’s easy to handle a subscription cancellation request. Devise does the work of deleting the user account and we just piggyback on the Devise registration controller action with a <code>before_destroy</code> callback so we can notify Stripe to cancel subscription billing.</p>
<p>Modify the file <strong>app/models/user.rb</strong>:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :role_ids, :stripe_token
  attr_accessor :stripe_token
  before_save :update_stripe
  before_destroy :cancel_subscription
  
  def update_stripe
    return if email.include?('@example.com')
    if stripe_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      customer = Stripe::Customer.create(
        :email =&gt; email,
        :description =&gt; name,
        :card =&gt; stripe_token,
        :plan =&gt; roles.first.name
      )
    else
      customer = Stripe::Customer.retrieve(stripe_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.stripe_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    stripe_token = nil
    false
  end
  
  def cancel_subscription
    unless stripe_id.nil?
      customer = Stripe::Customer.retrieve(stripe_id)
      if (!customer.nil?) &amp;&amp; (customer.subscription.status == 'active')
        customer.cancel_subscription
      end
    end
  rescue Stripe::StripeError =&gt; e
    logger.error e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}"
    false
  end
  
end
</pre>
<p>We’ve added a <code>cancel_subscription</code> method that is activated by the <code>before_destroy</code> callback. The method uses the Stripe <span class="caps">API</span> to obtain a Stripe customer object and then initiates a subscription cancellation call. We return false to cancel the <code>destroy</code> action if Stripe returns an error.</p>
<p>The <code>cancel_subscription</code> method only takes action if the user has a Stripe id. You may want to delete the example users created by the <code>db:seed</code> process. The example users don’t have a Stripe id and the <code>destroy</code> action would fail for them unless we make the <code>cancel_subscription</code> method conditional. We also make sure the Stripe customer exists and has an active subscription before attempting to cancel the subscription.</p>
<p>We’re done adding the features that allow users to change credit cards, change plans, and unsubscribe.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "accommodate changes to account"
$ git checkout master
$ git merge --squash change-acct
$ git commit -m "accommodate changes to account"
$ git branch -D change-acct
</pre>
<h2>Stripe Webhooks</h2>
<p>When a user visits your site, he or she can cancel a subscription. But what happens when a credit card expires or a monthly transaction is declined? Stripe will automatically retry a recurring payment after it fails. After a number of attempts (set in your Stripe account settings), Stripe will cancel the subscription. But how will your application know to deny access for a subscriber with an expired account? Stripe provides webhooks to communicate events to you (for details, see the <a href="https://stripe.com/docs/webhooks">Stripe webhooks documentation</a>).</p>
<p>A Stripe webhook is an <span class="caps">HTTP</span> request from Stripe’s servers to your site. It is not a visit to your website from a web browser; rather it is an <span class="caps">HTTP</span> <span class="caps">POST</span> request (like a form submission) to your application from the Stripe servers. The <span class="caps">HTTP</span> request contains <span class="caps">JSON</span> data that provides data about the event, plus an event id that can be used to retrive the data from the Stripe server. It is best to ignore the event data (because it could be falsified) and immediately use the event id to obtain the event data from Stripe.</p>
<p>There are a few ways we could handle webhook requests. We could create a new controller with an index action to process webhook requests. We could use the existing Registrations or Users controller, adding a new non-RESTful action to process the webhook requests. Both these approaches have merit. Instead, we’ll take a different approach. We’ll use Danny Whalen’s <a href="https://github.com/integrallis/stripe_event">stripe_event</a> gem. With this gem, we don’t need to add a new controller or action.</p>
<p>Get started by creating a new git branch for this feature:</p>
<pre>
$ git checkout -b webhooks
</pre>
<h3>Stripe Event gem</h3>
<p>We already added the <a href="https://github.com/integrallis/stripe_event">stripe_event</a> gem when we set up our Gemfile. If not, add the gem to the Gemfile:</p>
<pre>
gem "stripe_event"
</pre>
<p>and run the <code>bundle install</code> command to install the required gem on your computer.</p>
<h3>Mount the Engine</h3>
<p>The stripe_event gem is a <a href="http://edgeguides.rubyonrails.org/engines.html">Rails engine</a>, which is a miniature Rails application that can be added to an application. As a miniature Rails application, it has its own controller and routes hidden in the gem. The engine’s functionality becomes available when you mount it in your routes file.</p>
<p>Modify <strong>config/routes.rb</strong> to mount the engine:</p>
<pre>
RailsMembershipSubscriptionSaas::Application.routes.draw do
  mount StripeEvent::Engine =&gt; '/stripe'
  get "content/gold"
  get "content/silver"
  get "content/platinum"
  authenticated :user do
    root :to =&gt; 'home#index'
  end
  root :to =&gt; "home#index"
  devise_for :users, :controllers =&gt; { :registrations =&gt; 'registrations' }
  resources :users
end
</pre>
<p>We’ve chosen to mount the engine so it responds to requests to <a href="http://localhost:3000/stripe">http://localhost:3000/stripe</a>. You can specify a different path. You’ll supply this address when you set the webhooks <span class="caps">URL</span> in your Stripe account settings.</p>
<p>You will need to restart your server for the new route to become available.</p>
<h3>Modify the Stripe Initializer</h3>
<p>We need to specify what happens when the stripe_event engine receives a webhook request. Conveniently, we can specify this in the Stripe initializer file.</p>
<p>Modify the <strong>config/initializers/stripe.rb</strong> file:</p>
<pre>
Stripe.api_key = ENV["STRIPE_API_KEY"]
STRIPE_PUBLIC_KEY = ENV["STRIPE_PUBLIC_KEY"]

StripeEvent.setup do
  subscribe 'customer.subscription.deleted' do |event|
    user = User.find_by_stripe_id(event.data.object.customer)
    user.expire
  end
end
</pre>
<p>By default, Stripe will make three attempts to rebill after a failed payment. On each failure, Stripe will send a webhook request with an <code>invoice.payment_failed</code> event. On the third failure, Stripe will send a <code>customer.subscription.deleted</code> event.</p>
<p>With this code, we’re telling the stripe_event engine to respond when the application receives a webhook with a <code>customer.subscription.deleted</code> event. We use the Stripe event data to find the appropriate User instance. Then we call the <code>User.expire</code> method. We’ll add the <code>expire</code> method to the User class in the next step.</p>
<p>The <a href="https://github.com/integrallis/stripe_event">stripe_event gem readme</a> handles other possibilities, including multiple event types. Refer to the <a href="https://stripe.com/docs/api?lang=ruby#event_types">Stripe <span class="caps">API</span> documentation</a> for a list of all event types. You can configure your application to respond to other events, such as sending a thank you email in response to an “invoice.payment_succeeded” event.</p>
<p>Remember you’ll need to restart your server before testing because you’ve made a change to configuration files.</p>
<h3>Add an Expire Method to the User Class</h3>
<p>Now that our application responds to webhook requests from Stripe, we must consider how to process an expired  customer subscription.</p>
<p>There are several possible approaches to handling an expired subscription. One option is to keep the customer record and change the subscription plan to a role named “expired” or something similar. If we did that, we’d have to provide a form to allow an expired subscriber to log in, change a credit card, and update the subscription. It’s easier to simply delete the account and expect the user to create a new account to re-subscribe.</p>
<p>When a user visits the website and cancels a subscription, we delete the customer record. Similarly, we could simply delete the customer record when a subscription expires. Instead we can encourage the user to resubscribe by notifying the user with an email message when the subscription has ended due to a payment failure. We’ll add a custom <code>expire</code> method to our User class that will send an email message before deleting the user.</p>
<p>Modify the file <strong>app/models/user.rb</strong> to add an <code>expire</code> method:</p>
<pre>
class User &lt; ActiveRecord::Base
  rolify
  # Include default devise modules. Others available are:
  # :token_authenticatable, :confirmable,
  # :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

  # Setup accessible (or protected) attributes for your model
  attr_accessible :name, :email, :password, :password_confirmation, :remember_me, :role_ids, :stripe_token
  attr_accessor :stripe_token
  before_save :update_stripe
  before_destroy :cancel_subscription
  
  def update_stripe
    return if email.include?('@example.com')
    if stripe_id.nil?
      if !stripe_token.present?
        raise "Stripe token not present. Can't create account."
      end
      customer = Stripe::Customer.create(
        :email =&gt; email,
        :description =&gt; name,
        :card =&gt; stripe_token,
        :plan =&gt; roles.first.name
      )
    else
      customer = Stripe::Customer.retrieve(stripe_id)
      if stripe_token.present?
        customer.card = stripe_token
      end
      customer.email = email
      customer.description = name
      customer.save
    end
    self.last_4_digits = customer.active_card.last4
    self.stripe_id = customer.id
    self.stripe_token = nil
  rescue Stripe::StripeError =&gt; e
    logger.error e.message
    errors.add :base, "Unable to create your subscription. #{e.message}"
    stripe_token = nil
    false
  end
  
  def cancel_subscription
    unless stripe_id.nil?
      customer = Stripe::Customer.retrieve(stripe_id)
      if (!customer.nil?) &amp;&amp; (customer.subscription.status == 'active')
        customer.cancel_subscription
      end
    end
  rescue Stripe::StripeError =&gt; e
    logger.error e.message
    errors.add :base, "Unable to cancel your subscription. #{e.message}"
    false
  end
  
  def expire
    UserMailer.expire_email(self).deliver
  	destroy
  end
  
end
</pre>
<p>Our new <code>expire</code> method is simple. We call a method on an ActionMailer method to send an email. Then we destroy the user.</p>
<h3>Send an Expiration Email</h3>
<p>We’ll use an ActionMailer method to send an email when we receive a Stripe webhook request indicating a subscription has been cancelled for pyament failure.</p>
<p>Generate a mailer with accompanying views:</p>
<pre>
$ rails generate mailer UserMailer
</pre>
<p>Add an <code>expire_email</code> method to the mailer by editing the file <strong>app/mailers/user_mailer.rb</strong>:</p>
<pre>
class UserMailer &lt; ActionMailer::Base
  default :from =&gt; "notifications@example.com"
  
  def expire_email(user)
    mail(:to =&gt; user.email, :subject =&gt; "Subscription Cancelled")
  end
end
</pre>
<p>Replace the “notifications@example.com” string with your email address.</p>
<p>Create a mailer view by creating a file <strong>app/views/user_mailer/expire_email.html.erb</strong>. This will be the template used for the email, formatted in <span class="caps">HTML</span>:</p>
<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html; charset=UTF-8" http-equiv="Content-Type" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Subscription Cancelled&lt;/h1&gt;
    &lt;p&gt;
      Your subscription has been cancelled.
    &lt;/p&gt;
    &lt;p&gt;
      We are sorry to see you go. We'd love to have you back. 
      Visit example.com anytime to create a new subscription.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It is a good idea to make a text-only version for this message. Create a file  <strong>app/views/user_mailer/expire_email.text.erb</strong>:</p>
<pre>
Subscription Cancelled

Your subscription has been cancelled.
 
We are sorry to see you go. We'd love to have you back. 
Visit example.com anytime to create a new subscription.
</pre>
<p>When you call the mailer method, ActionMailer will detect the two templates (text and <span class="caps">HTML</span>) and automatically generate a multipart/alternative email. If you use the Mandrill email service, you can skip this step if you configure Mandrill to automatically generate a plain-text version of all emails.</p>
<p>Now the User model is equipped to send an email message when a Stripe webhook notifies the application of a cancelled subscription.</p>
<h3>Set Your Webhook Address in Your Stripe Account Settings</h3>
<p>After you’ve implemented handling of Stripe webhooks, you need to set your webhook address in your Stripe account settings.</p>
<p>Visit your Stripe dashboard at <a href="https://manage.stripe.com/#account/webhooks">https://manage.stripe.com/#account/webhooks</a> and add a <span class="caps">URL</span> such as <a href="https://example.com/stripe">https://example.com/stripe</a>.</p>
<h3>Testing a Stripe Webhook Event</h3>
<p>It’s not easy to test a Stripe webhook event.</p>
<p>You can watch your development log file when you visit <a href="http://localhost:3000/stripe">http://localhost:3000/stripe</a>. You should see:</p>
<pre>
Started GET "/stripe" for 127.0.0.1 at ...
Processing by StripeEvent::WebhookController#event as HTML
Completed 401 Unauthorized in 0ms (ActiveRecord: 0.0ms)
</pre>
<p>The “401 Unauthorized” response indicates that the stripe_event gem received a request but was unable to retrieve a Stripe event from the Stripe servers.</p>
<p>You can deploy the application so it is running on a production web server and then use the “Test Webhook” button on your Stripe dashboard. Stripe will send fake event to the <span class="caps">URL</span> you’ve specified in your account settings. However, your log file will again show a “401 Unauthorized” response because the “Test Webhook” button sends a fake event (“id”=&gt;"evt_00000000000000") that can’t be retrieved from Stripe.</p>
<p>The most expedient test is to deploy the application on a production web server and trigger an actual event on your Stripe dashboard in “Test” mode by creating a customer and then canceling a subscription. If you are not getting the results you expect, you can include the following debug code in the <strong>config/initializers/stripe.rb</strong> file:</p>
<pre>
subscribe do |event|
  Rails.logger.info event
end
</pre>
<p>The debug code should show you the results of any request to the stripe_event gem in your log file.</p>
<p>If you need to test requests to the stripe_event gem on your local development machine, you can install the <a href="http://progrium.com/localtunnel/">localtunnel gem</a> (<a href="https://github.com/progrium/localtunnel">localtunnel on GitHub</a>) which will expose your local web server to the Internet so you can receive webhook requests from the Stripe servers.</p>
<h3>Git Workflow</h3>
<p>Commit your changes to git:</p>
<pre>
$ git add -A
$ git commit -m "add Stripe webhooks"
$ git checkout master
$ git merge --squash webhooks
$ git commit -m "add Stripe webhooks"
$ git branch -D webhooks
</pre>
<h2>Additional Features</h2>
<p>You’ve created a fully functional membership site that’s ready to take credit card payments and serve access to restricted content.</p>
<p>It uses Stripe for payment processing, allows users to change credit cards or subscription plans, and uses Stripe webhooks to delete users who have expired or declined credit cards.</p>
<p>You might consider a few enhancements. For example, you might want the application to respond to a Stripe webhook event when a credit card payment is successful by sending a “paid” invoice. Or you might respond to Stripe webhook events when credit card payments are unsuccessful by sending a friendly note encouraging the user to check for an expired credit card before the subscription is cancelled.</p>
<p>If you have suggestions for additional features, please create an <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">issue</a> on GitHub.</p>
<h2>Test the App</h2>
<p>You can check that your app runs properly by entering the command:</p>
<p><code>$ rails server</code></p>
<p>To see your application in action, open a browser window and navigate to <a href="http://localhost:3000">http://localhost:3000/</a>.</p>
<p>Sign in as the first user (the administrator) using:</p>
<ul>
<li>email: user@example.com</li>
	<li>password: please</li>
</ul><p>You’ll see a navigation link for Admin. Clicking the link will display a page with a list of users at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<p>To sign in as the second user, use</p>
<ul>
<li>email: user2@example.com</li>
	<li>password: please</li>
</ul><p>The second user will not see the Admin navigation link and will not be able to access the page at<br><a href="http://localhost:3000/users">http://localhost:3000/users</a>.</p>
<h2>Deploy to Heroku</h2>
<p>Heroku provides low cost, easily configured Rails application hosting. For your convenience, see <a href="http://railsapps.github.com/rails-heroku-tutorial.html">Tutorial: Rails on Heroku</a>.</p>
<h2>Credits</h2>
<p>Daniel Kehoe implemented the application and wrote the tutorial.</p>
<h2 id="comment">Did You Like the Tutorial?</h2>
<p>Was this useful to you? Follow <a href="http://twitter.com/rails_apps">rails_apps</a> on Twitter and tweet some praise. I’d love to know you were helped out by the tutorial.</p>
<p>Get some link juice! Add your website to the list of <a href="http://railsapps.github.com/rails-applications-from-examples.html">Rails Applications Built from the Examples</a>. I love to see what people have built with these examples.</p>
<p>Any issues? Please create an <a href="http://github.com/RailsApps/rails-stripe-membership-saas/issues">issue</a> on GitHub. Reporting (and patching!) issues helps everyone.</p>
    </div><!-- class="content" -->
    
    <div class="comments">
      <div class="content wikistyle gollum">
        <h2>Comments</h2>
      </div>
      <p>Is this helpful? Your encouragement fuels the project. Please tweet or add a comment. Couldn't get something to work? For the example apps and tutorials, it's best to open an issue on GitHub so we can help you.</p> 
      <div id="disqus_thread"></div>
      <script type="text/javascript">
          /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
          var disqus_shortname = 'railsapps'; // required: replace example with your forum shortname
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div><!-- class="comments" -->

    <div class="footer row">
      <div class="span4">
      </div>
    
      <div class="span4">
       </div>

      <div class="span4">
      </div>
    </div>

  </div>
            
  </body>
</html>
